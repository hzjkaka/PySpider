{'author': 'Rolan',
 'content': 'newticket是微信开发者工具和微信后台交互的凭证。大多数工具的操作都是需要newticket。如何获取newticket?打开开发者工具，依次点击菜单设置->通用设置->代理，使用代理监听接口请求。（这里使用fiddler代理）点击头像，选择切换登录，使用开发者的微信扫码登录。\xa0'
            'PS：获取到的凭证是有时效的，重新登录凭证会失效，建议不要使用自己的开发账号登录。代理工具查看https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/qrcode接口，选择查看响应的头部，得到newticket如何更新newticket?因为newticket是有时效性的，在过期后需要更新newticket后才能正常使用。而更新newticket需要开发者工具的signature和openid，这两个参数的值可以从上一步的请求中找到。\xa0'
            'PS：这两个参数的值在重新登录前是固定不变的，需要存储起来更新备用通过接口更新newticket，需要注意的是返回的newticket是存放在header里面。const '
            'request = require("request");\r\n'
            'exports.getNewTick = ({signature,openid})=>{\r\n'
            '    return new Promise((resolve, reject) => {\r\n'
            '        request({\r\n'
            '            '
            'url:"https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/refreshticket?os=win&clientversion=1032006090",\r\n'
            '            method:"POST",\r\n'
            '            body:JSON.stringify({signature,openid})\r\n'
            '        },(error, response, body) => {\r\n'
            '            const newTicket = '
            "response.headers['debugger-newticket'];\r\n"
            '            if (error) {\r\n'
            '              reject(error);\r\n'
            '              return;\r\n'
            '            }\r\n'
            '            if(response.statusCode != 200){\r\n'
            '                reject({statusCode:response.statusCode})\r\n'
            '                return;\r\n'
            '            }\r\n'
            '            try{\r\n'
            '              const result = JSON.parse(body)\r\n'
            '              result.newTicket = newTicket;\r\n'
            '              resolve(result);\r\n'
            '            }catch{\r\n'
            '              resolve({code:-1});\r\n'
            '            }\r\n'
            '          })\r\n'
            '    })\r\n'
            '}\r\n'
            '最后，获取这个newticket只是开始，后面我会更新如何使用newticket上传代码，获取预览的二维码。',
 'date': '2020-8-11 15:03',
 'title': '微信小程序开发着工具获取和更新newticket '}
****************************************
{'author': 'Rolan',
 'content': '微信小程序开发很重要的一步就是微信授权登录与服务器用户信息保存，很多同学并不了解流程，下面我为大家讲解一下最简单的登录流程。微信小程序授权、服务器保存信息到数据库通过 '
            'wx.login() 获取到用户登录态之后，需要维护登录态。开发者要注意不应该直接把 session_key、openid '
            '等字段作为用户的标识或者 session 的标识，而应该自己派发一个 session 登录状态\xa0'
            '（请参考登录时序图）。对于开发者自己生成的 session，应该保证其安全性且不应该设置较长的过期时间。session '
            '派发到小程序客户端之后，可将其存储在 storage '
            '，用于后续通信使用。微信小程序授权登录与用户信息保存流程图里其实说的很清楚了，清理下流程：1.前端调用wx.login()获取code值2.前端通过调用wx.getUserInfo获取iv、rawData、signature、encryptedData等加密数据，传递给后端3.服务器通过code请求api换回session_key和openid4.服务器通过前端给的rawData '
            '加获取的session_key使用sha1加密，计算出signature15.比对前端传的signature和自己算出来的signature1是否一致（防止数据不一致）6.用AES算法解密encryptedData里的敏感数据7.拿着敏感数据后做自己的逻辑8.通知前端登陆成功这里只是想拿到用户的openid，则直接1,3就可以做到了。1第一步：通过wx.login（微信前端--小程序）接口获取code，将code传到后台注意：code的来源：是用户打开小程序的时候，随机生成的，是腾讯生成的，每个code只能使用一次，因此，理论上这个code是安全的2第二步：后台通过code访问微信（腾讯）接口，微信（腾讯）接口返回当前登录的信息：session_key及openid。返回的openid是每个用户唯一的，通过这个\xa0'
            '可以匹配 微信（腾讯）的用户\xa0跟\xa0'
            '我们的用户，就是我们后台通过openid来判断这个人是谁，UserController.java\xa0 \xa0 '
            '微信小程序登录其中：就是下面的第三步//调用service.weChatLogin(model)WeChatLoginResult<UserAccount> '
            'loginResult =\xa0'
            'service.weChatLogin(model);3第三步：后台检查openid是否存在，去UserService.java去数据库中检查openid是否存在：UserAccountMapper.java如果不存在：就是该用户的第一次登录，后台数据库新添加一个用户信息\xa0'
            '如果存在：就不是该用户的第一次登录，以前登陆过，就更新后台数据库中该用户的第一次登录时间返回用户信息4第四步：下发token其中生成token的步骤：BaseController.java\xa0'
            '利用JWT框架生成token至此，再理一下上面的步骤：微信小程序通过访问wx.login获得一个code，返回给后台后台拿着这个code，调用腾讯的接口，获取到openid、seesion-key等信息，openid是用户唯一的后台拿着openid去数据库中检查，该用户是否是第一次登陆。如果是第一次登陆，那么就新建一个用户--UserAcount；如果不是第一次登陆，就修改该用户的最后登录时间不管是不是第一次登录，都有了一个用户然后根据用户的信息利用JWT生成token，下发给微信小程序5第五步微信小程序收到token后，存起来6第六步微信小程序请求后台微信小程序把token放在请求头中7第七步先介绍一个注解：Authorize说明：如果有这个注解，就需要验证token用拦截器，验证token流程：1、从http请求头中取出tokenString '
            'token = '
            'httpServletRequest.getHeader("authorization");2、如果没有token，抛出异常，请用户登录。如果有token，利用JWT从token中取出userid，添加到request参数3、根据userid去后台数据库中查询用户是否存在，如果不存在，抛出异常：用户不存在，请重新登录User '
            'user = '
            'userService.getUserById(userId);这个方法：4、如果用户存在，再利用JWT从token中取出seesion-key，添加到request参数Stringsession_key=JWT.decode(token).getClaim("session_key").as(String.class);拦截器介绍一下：preHandle：在业务处理器处理请求之前被调用。预处理，可以进行编码、安全控制、权限校验等处理；postHandle：在业务处理器处理请求执行完成后，生成视图之前执行。后处理（调用了Service并返回ModelAndView，但未进行页面渲染），有机会修改ModelAndView；afterCompletion：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；8第八步：request里面有userid，后台就可以识别是对哪个用户做处理总结微信小程序授权登录和信息保存，看起来是有点麻烦 '
            '，但是这个流程是很清晰的 ，大家只要理解了逻辑控制流程 ，就能很好的完成开发。',
 'date': '2020-8-10 14:31',
 'title': '微信小程序：授权登录 + 基于token的身份验证详解 '}
****************************************
{'author': 'Rolan',
 'content': '本文首发于DCloud公众号2017年，微信发布小程序，掀起小程序大战。2018年，阿里、百度、字节跳动、手机厂商等各大巨头纷纷发布自己的小程序。2019年，QQ也加入战局，各家全面开花。时至2020年，各家小程序发展的到底怎么样？我们根据数据和访谈，形成了这份报告，希望能给开发者带来指引帮助。作为开发者，我们关心的问题，说白了就2个：各家有多大量？各家流量质量怎么样？一、各家小程序流量到底有多大小程序还有流量红利吗？微信的红利是不是已经过去了？不少人存有这种疑问。如果以2018年微信小程序的火爆对比，那么2019年的微信确实没有那么大的红利了。随着用户对群里的小程序由新鲜转向反感，以及微信的严格封杀策略，很多开发者开始抱怨在微信平台裂变不起来了。当然微信小程序平台自身的流量仍在增长，只是增长主要来自于品牌主，比如自带流量的政府、商户，而不是独立开发商了。压下葫芦起了瓢，其他小程序平台给开发者提供了更大的爆发机会。我们来看看各家的流量天花板，也就是小程序宿主应用的月活，微信月活10亿、字节跳动（抖音+今日头条+西瓜+火山）月活10亿、QQ和支付宝月活都是6亿、百度App月活也有4亿。但各家的小程序月活并不是这个顺序，因为：\xa0'
            '小程序的月活 = 宿主月使用时长 * '
            '小程序使用频次各家小程序的宿主和小程序流量数据平台宿主月活小程序月活微信10亿日活3亿，未公布月活支付宝6亿+5亿百度4亿+3亿字节跳动10亿+3亿QQ6亿+未公布平台宿主月活里，百度最低，只有4亿。这让人一度担心百度小程序能不能起来。从最终结果来看，百度小程序的月活并不低。因为它的“小程序使用频次”高。用户使用百度App的主需求，就是为了查信息。而百度的百科、贴吧、知道等业务已经全部转为了小程序。其他平台，都有自己的核心功能，小程序属于外延生态。宿主月活虽高，但其中使用小程序的人未必很多。当然支付宝有个例外，很多人打开支付宝，就是为了用蚂蚁森林小程序，而不是为了用支付宝支付，出现了神奇的反客为主效应。。。在近期，有3个平台的小程序表现尤为抢眼，分别是字节跳动、微信、支付宝。字节跳动的App群，从春节开始，流量暴增，然后一直维持在高位。这是一个令人佩服的成绩，在这段时间，字节跳动给小游戏分发了大量流量，宅家的人们一边消费着可观的短视频流量，一边玩小游戏消遣时间。在春节后，各地防疫战打响，每个城市都开始上线抗疫相关的项目，健康登记、出入管理、口罩预约、实名乘车......引发了一大波新应用热潮。这些小程序仅承载在微信和支付宝的平台上。其他小程序平台没有抓到这拨红利。倒不是因为微信或支付宝的给量能力强，流量来自于政府和商户。而他们之所以选择微信和支付宝平台，完全是因为民众对于扫码的使用习惯依赖。人们看到一个码，不是用微信扫，就是用支付宝扫。其他小程序平台还没有给民众培养出扫码的使用习惯。支付宝小程序，从1月起原本是大幅下滑的状态，线下商户陆续放假，严重依赖线下渠道的支付宝小程序受到很大影响。直到现在，随着线下商户复工才有了起色。所幸健康码挽救了支付宝小程序的日活。不过老实讲，健康码对于微信和阿里的商业价值都不大，也只能当做培养用户使用习惯和拉近政府关系了。支付宝小程序不擅长线上分发应用流量，线下商户连接价值才是支付宝小程序的核心，赋能商户、提升交易，是它的真正使命。值得支付宝警惕的是，一些餐饮行业的开发者，使用uni-app多端框架开发应用后，明明可以发布为支付宝小程序，却仅仅发布了H5端，让顾客在线下使用支付宝扫码后打开H5页面。根据DCloud的访谈，这些开发者认为支付宝里扫码打开小程序，并不会比打开H5页强多少，而且小程序审核麻烦，导致很多支付宝小程序的流量跑到了支付宝内置浏览器里了。这需要支付宝改进策略，为小程序开发者提供更多的吸引力，同时减少开发者的麻烦。百度小程序，恰恰是支付宝小程序的对立面，它是纯纯的线上流量。对于很多中小开发者，从百度获取流量，比任何其他平台都容易。做好seo、甚至付费买点流量，总会让你有用户的。不少中小开发者反馈，提交到多个平台小程序，发现百度的流量是大于其他家的。尤其是内容类小程序。在春节和疫情期间，百度小程序的流量有所下滑，近期随着复工复产，又开始快速增长。各家巨头，除了利用自己的主App的体量，也在通过搞联盟来扩大流量池。百度和阿里，都计划通过联合多个头部App组成流量联盟，来帮助开发者获取更大流量。但从目前运行的情况看，这类计划的效果不太明显。阿里小程序和百度小程序的流量，基本都集中在支付宝和百度App上。不管是开发者还是用户，都还没有对流量联盟的其他小程序形成大范围认知和使用习惯。阿里系小程序里，值得期待的新兵是淘宝小程序。近期淘宝小程序已经开始崭露头角，相信随着产品和运营的完善，淘宝小程序会开辟一片新蓝海，因为赋能卖家，确实是一个大市场。QQ小程序发布较晚，它没有采取同为后来者的字节跳动小程序那般中心化疯狂配量模型，目前处于稳定增长中，但整体体量暂时和其他几家还不在一个量级。再分享一个数据：各个平台的应用数量。除了月活流量外，我们还应该关注一个指标，是应用数量。uni-app的开发者发布到各个平台的“应用数量”，看下图：虽然使用uni-app框架可以发布到所有小程序平台，但大多数开发者不会全平台提交应用。上面的饼图有2种解读：微信小程序的应用数量远远超过其他平台，是绝对数量级的差距。说明它已经成为一种生活方式而不只是一个流量平台。微信小程序非常拥挤，大量开发者聚集在微信平台，但得不到足够的流量百度和字节跳动，应用数量少，但小程序月活体量却非常大，有更多红利机会。如果你是一个自带流量的品牌主，比如政府单位，那微信小程序是很好的选择。如果你是一个独立开发者，现在在微信里获取流量其实已经很难了，不妨试试其他平台。与微信、支付宝的给量逻辑不同，百度和字节跳动是卖流量的。在微信里获客，一般是给用户利益，比如拼团砍价；在百度、字节跳动里获客，是给平台利益，花钱投放立即带来用户。从难度来讲，在微信里已经变得很难，而在百度和字节跳动则很简单。百度里小程序的权重高于H5，投资到百度小程序上比投放H5页面更有性价比。至于字节跳动，不得不佩服它家的流量实在太大了，大到什么地步呢？这么说吧，只要肯投钱，快速获取上千万用户很easy。当然，不花钱投放，一样可以得到流量，那对应的要求就是你的内容过硬。以DCloud的开发者社区App为例，每天在百度小程序上得到的流量是最大的。很多用户在百度上搜索技术问题，被导流到DCloud社区的百度小程序中，拉新效果远优于其他小程序、App和H5。在2020年，手机厂商的快应用也出现了更积极的变化。过去快应用的数量很少，不过几千款，与微信的百万级应用数差距很大。最近快应用在原生渲染引擎之外，推出了兼容小程序架构的新应用引擎。对快应用平台而言，新策略有助于增加快应用的开发者数量。对开发者而言，这或许是拿到一个巨大流量的新机会。uni-app在第一时间也跟踪了快应用的新引擎适配，欢迎开发者关注。二、各家小程序平台的流量质量怎么样？有量，还不够。开发者还关心流量质量。流量质量怎么看？我们来看这两个指标：1、单用户页面访问数量；2、次日留存大家都知道，小程序的流量质量，比App要差。但具体差多少呢？我们把App的数据请出来，一起比一下。不同平台用户访问应用的页面数量可以看到，App的一个日活用户，平均访问49个页面，远超小程序。虽然小程序的拉新能力甩开App几条街，但深度用户，还是更喜欢用App。在各家小程序里，微信小程序的表现最接近App，领先其他小程序不少。从这个数据可以明显看出，用户对在支付宝、百度、字节跳动的App中重度使用小程序的习惯没有养成。基于这个现状，开发者若在百度、字节跳动平台推广小程序，需要注意缩短流程，在尽可能短的页面完成自己的业务。比如获取注册表单、获取商机线索、直购低价商品等。而另一方面，也需要微信以外的其他小程序运营平台，努力学习微信，改进运营策略。尤其是百度、字节跳动和QQ小程序，还比较重视应用内广告的收益，如果页面访问次数上不去，广告位的曝光量就上不去，导致美梦落空。我们再来看第二个指标：次日留存。各平台次日留存表首先，所有小程序的留存，都比App差不少。然后看各家小程序。微信小程序，在众多小程序里，留存遥遥领先，平均次日留存超过了10%。其他小程序的平均次日留存，都在5%以下。为什么会有这么大差距。从留存入口来看，微信的下拉二楼、发现选项卡的小程序栏目，已经成功的培养起了用户的使用习惯。用户第一次不管从哪里得到一个小程序，第二次还可以比较顺畅的找到它，从而形成留存。但其他平台在这方面做得不好。百度App的二楼，经常和信息流刷新冲突。支付宝的二次使用入口，打开很慢，远不及微信的体验。字节跳动、QQ的二次使用入口则非常深。当然，这里还有另一个关键问题，对于非微信的其他小程序平台，它们还有一个尴尬，二次使用的入口，到底做的多方便为好？字节跳动和百度，都是卖流量为生的公司。开发商投放了搜索关键字或信息流广告，如果后续用户可以方便的在二次使用入口获取这个应用，那对于字节跳动和百度来说，第一次卖流量的钱就会越来越少。这和微信不同，微信不卖初次获取的流量，它的变现是后向的，来自于持续使用的微信支付、应用内广告。后向支付和广告收益如何平衡？初次流量销售收益和小程序留存如何平衡？这是2个需要它们妥善取舍的问题。三、结语本文给开发者提供了数据参考，也给小程序平台提出了一些问题。衷心希望各家小程序平台能解决好问题，取得更大的发展；更祝愿开发者把握住新红利，在大潮中实现自己的梦想。文章转载自：https://zhuanlan.zhihu.com/p/130332829作者：崔红保。转载标注出处',
 'date': '2020-8-11 10:32',
 'title': '2020了，各家小程序发展的怎么样？ '}
****************************************
{'author': 'Rolan',
 'content': 'uni-app\xa0是一个遵循\xa0Vue.js\xa0'
            '语法的跨端框架，开发者编写一套代码，可发布到App、H5、小程序（微信/阿里/百度/字节跳动）及快应用。近期，uni-app新增支持发行到360小程序平台，目前hello '
            'uni-app\xa0已上线360小程序，可以在360浏览器中点击链接打开体验如下是简易体验教程，Enjoy~通过 '
            'HBuilderX 可视化界面下载HBuilderX 创建uni-app项目在HBuilderX开发者工具中，点击文件 -> 新建 '
            '-> 项目：选择uni-app类型，输入工程名，选择模板，点击创建，即可成功创建。3. 进入已创建的项目，点击工具栏的运行 -> '
            '运行到小程序模拟器 -> 360开发者工具，等待编译完成时自动调起\xa0360浏览器4. '
            '在360浏览器中导入编译后的目录，见\xa0HBuilderX\xa0控制台输出5. '
            '在HBuilderX中修改代码，uni-app编译器会热更新到\xa0360浏览器注意: '
            '运行时为未压缩代码，正式上线时需要点击发行菜单通过vue-cli命令行习惯cli脚手架的同学，可以通过vue-cli创建uni-app项目。全局安装vue-clinpm '
            'install -g @vue/cli2. 创建uni-app项目，选择项目模板vue create -p '
            'dcloudio/uni-preset-vue my-project此时，会提示选择项目模板，初次体验建议选择\xa0hello '
            'uni-app\xa0项目模板，如下所示：3. 使用如下命令进行360小程序的编译预览及发行打包# npm script\r\n'
            '# dev 模式，编译预览\r\n'
            '$ npm run dev:mp-360\r\n'
            '# build 模式，发行打包\r\n'
            '$ npm run '
            'build:mp-360发行到360小程序，需要你下载并打开360浏览器，然后选择项目编译目录（dev模式、build '
            '模式编译目录不同，见下方说明）进行预览或发行。dev模式 和 build 模式的区别：dev 模式编译目录为项目根目录下的\xa0'
            '/dist/dev/\xa0目录build 模式编译目录为项目根目录下的\xa0/dist/build/\xa0目录dev 模式有 '
            'SourceMap 可以方便的进行断点调试build '
            '模式会将代码将会进行压缩，体积更小更适合发布为正式版应用开发规范uni-app\xa0'
            '内置的组件及API已兼容360小程序，详见uni-app官网对于 360 '
            '小程序特殊的组件及API，可以通过条件编译调用360原生能力。',
 'date': '2020-8-11 14:54',
 'title': 'uni-app 支持开发PC版的 360 小程序 '}
****************************************
{'author': 'Rolan',
 'content': '编写第一个云函数通过云函数，我们将拥有编写服务端代码的能力。我们可以在服务端执行一些逻辑，可以上传图片，可以调用其他网络服务的api，可以对数据库进行操作。重要的是，云函数的编写相当简洁，便利。\xa0'
            '在这一节，我们将通过云函数获取“为你推荐”的产品数据，实现数据动态化。实现这一功能，我们需要学习以下三块内容：❝1 '
            '创建第一个云函数 2 调用云函数 3 学会绑定点击事件❞一 '
            '创建第一个云函数如何创建云函数呢？我们这里通过“微信开发者工具”来完成云函数的创建和代码编写。\xa0'
            '首先，我们右键单击“cloudfunctions”，选择“新建Node.js云函数” '
            '写上我们的函数名“client_home_get_best”，这时候，工具会为我们创建一个同名文件夹，文件夹下面有一些文件，如下图：\xa0'
            '接下来我们要做的是安装wx-server-sdk依赖，怎么做呢？右键点击新建的云函数文件夹，选择“在终端打开”。在打开的终端中输入“npm '
            'install --save wx-server-sdk@latest” '
            '敲下回车并等待依赖下载完成。如下图：当安装完依赖后，我们的云函数文件夹也起了变化。多了node_modules文件夹和package-lock.json文件。对于目前的我们来讲，只有index.js文件是最重要的，之后我们会在这个js文件中编写我们的代码。先来看看工具默认都生成了什么代码：//\xa0'
            '云函数入口文件const\xa0cloud\xa0=\xa0'
            "require('wx-server-sdk')cloud.init()//\xa0云函数入口函数exports.main\xa0"
            '=\xa0async\xa0(event,\xa0context)\xa0=>\xa0{\xa0\xa0const\xa0'
            'wxContext\xa0=\xa0cloud.getWXContext()\xa0\xa0\xa0\xa0return\xa0'
            '{\xa0\xa0\xa0\xa0event,\xa0\xa0\xa0\xa0openid:\xa0'
            'wxContext.OPENID,\xa0\xa0\xa0\xa0appid:\xa0'
            'wxContext.APPID,\xa0\xa0\xa0\xa0unionid:\xa0'
            'wxContext.UNIONID,\xa0\xa0'
            '}}从上往下解读代码，先是引入了wx-server-sdk，接着进行了初始化了。\xa0'
            '诚如注释所述，我们的主要工作就是在“云函数入口函数”内编写代码。我们要写什么代码呢？我们要在这里返回“为你推荐”模块的数据，在这一节，我们只返回4个产品。在下一节，我们会结合数据库，从产品数据库中随机抽取4个返回。Ok，在具体编码之前，我想先对返回的数据做一个约定。\xa0'
            '我需要status字段来告诉客户端，获取数据是成功了（success）还是失败了（fail）。\xa0'
            '我需要一个msg字段来返回一些信息，虽然，这次用不着，但是我还是想先做好约定。\xa0'
            '我还需要一个data字段来返回推荐产品的数据。所以返回数据的格式应该像下面这个样子。return\xa0'
            '{\xa0\xa0\xa0\xa0status:\xa0status,\xa0\xa0\xa0\xa0msg:\xa0'
            'msg,\xa0\xa0\xa0\xa0data:\xa0data,}我们还需要做的是，把推荐的产品数据赋值给data。\xa0'
            '那么，云函数入口函数的完整代码就该是这样：//\xa0云函数入口函数exports.main\xa0=\xa0async\xa0'
            '(event,\xa0context)\xa0=>\xa0{\xa0\xa0const\xa0wxContext\xa0=\xa0'
            'cloud.getWXContext()\xa0\xa0const\xa0status\xa0=\xa0'
            '"success"\xa0\xa0const\xa0msg\xa0=\xa0""\xa0\xa0const\xa0data\xa0'
            '=\xa0[{\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0'
            '"拿铁",\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '24,\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa012,\xa0\xa0\xa0\xa0\xa0\xa0'
            'thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/88F34543128D-1.jpeg"\xa0\xa0\xa0\xa0'
            '},\xa0\xa0\xa0\xa0{\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0'
            '"提拉米苏爱摩卡",\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '19,\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa028,\xa0\xa0\xa0\xa0\xa0\xa0'
            'thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/7B69340506EC-1.jpeg"\xa0\xa0\xa0\xa0'
            '},\xa0\xa0\xa0\xa0{\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0'
            '"陨石拿铁",\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '28,\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa0'
            '16.8,\xa0\xa0\xa0\xa0\xa0\xa0thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/82B1B9FDDB21-1.jpeg"\xa0\xa0\xa0\xa0'
            '},\xa0\xa0\xa0\xa0{\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0'
            '"榛果拿铁",\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '28,\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa0'
            '16.8,\xa0\xa0\xa0\xa0\xa0\xa0thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/FBD8B7AADBD9-1.jpeg"\xa0\xa0\xa0\xa0'
            '}\xa0\xa0]\xa0\xa0return\xa0{\xa0\xa0\xa0\xa0status:\xa0'
            'status,\xa0\xa0\xa0\xa0msg:\xa0msg,\xa0\xa0\xa0\xa0data:\xa0'
            'data,\xa0\xa0'
            '}}当我们写完云函数之后，我们需要把云函数上传到云开发的服务器上。怎么做呢？其实也很简单，我们只需要右键单击云函数的文件夹，选择“上传并部署：云端安装依赖（不上传node_modules）”至此我们就完成了云函数的编写，接下来我们需要对云函数进行调用。二 '
            '调用云函数在小程序中，调用云函数是一件非常简单的事。我们只需要用过wx.cloud.callFunction即可。同时，小程序对云函数的调用是支持Promise风格的。什么是Promise？这对于js来说是个神器啊。我们有没有必要讲一下Promise，是有必要呢？还是有必要呢？\xa0'
            '我们还是简单说一下Promise吧。简单的说，就是用来处理异步回调的神器。像获取网络数据就是一个典型的异步操作。对于我们来讲，只需要熟练使用.then()和.catch()就好。\xa0'
            '现在，让我们回到云函数的回调上来。我们回想一下，什么时候会去调用云函数？1是界面初始化的时候，还有就是“换一批”和“刷新”图标被点击的时候。所以我们需要把调用云函数的代码写成一个函数：onGetBest这个函数我们写在methods块内。/***\xa0'
            '组件的方法列表*/methods:\xa0{onGetBest:function(){\xa0\xa0'
            'wx.cloud.callFunction({\xa0\xa0\xa0\xa0'
            'name:"client_home_get_best"\xa0\xa0}).then(res=>{\xa0\xa0\xa0\xa0'
            'if\xa0(res.result.status\xa0==\xa0"success"\xa0'
            '&&res.result.data){\xa0\xa0\xa0\xa0\xa0\xa0'
            'this.setData({\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0'
            'products:res.result.data\xa0\xa0\xa0\xa0\xa0\xa0})\xa0\xa0\xa0\xa0'
            '}\xa0\xa0}).catch(err=>{\xa0\xa0\xa0\xa0console.log(err)\xa0\xa0'
            '})}},我们需要注意，在什么地方传入name的属性，也就是我们云函数的函数名“client_home_get_best”。\xa0'
            '我们在then中接收云函数返回的数据。我们在云函数中返回的数据，都保存在res.result中。想想我们都返回了什么？status，msg和data。在这里，我们将以status是否为“success”和data是否存在为依据，来判断是否要更新“为你推荐”的数据。\xa0'
            '调用云函数的函数就写完了，如果我有什么没讲清楚的，可以留言给我。\xa0'
            '因为我们在界面初始化的时候，会调用一次云函数。所以我们要把onGetBest函数在attached中调用一次。接下来，我们要绑定点击事件。三 '
            '绑定点击事件在小程序的组件中，我们可以通过bindtap来绑定点击事件bindtap=“onGetBest"在这个界面中，我们要在两个组件上绑定点击事件，1是“换一批”文字，2是刷新图标，代码如下：<view\xa0'
            'class="change"\xa0bindtap="onGetBest">换一批</view><van-icon\xa0'
            'color="gray"\xa0size="28rpx"\xa0name="replay"\xa0'
            'bindtap=“onGetBest"/>是不是很简单？\xa0'
            '我们再来做一个简单的处理是用户体验更好一些。是什么处理呢？就是当我们接受到数据后，我们再来显示“为你推荐”模块。怎么做到呢？我们可以通过wx:if来实现。怎么实现呢？通过判断绑定的数据products数组来判断，只有当products数组元素大于0时，才显示“为你推荐”模块。代码如下：<view\xa0'
            'class="mid_menu"\xa0'
            'wx:if=“{{products.length>0}}">云数据库初体验在上一节，我们创建了第一个云函数，在这一节，我们来一起学习一下云数据库的使用。当我们学会了小程序界面的绘制，逻辑的编码，云函数的编写，云数据库的使用，我们会变成什么？变成一个什么都会做的全栈工程师，由于我们什么都会做。所以我们什么都要做，于是时间就不够啦，就要开始996，然后007，这是福报，马爸爸说的。\xa0'
            '开个玩笑啦，我们先成为全栈工程师，然后目标是成为一个10x程序猿。随着能力的提高，升职加薪是必然的。小程序的流行势不可挡，它还没有停止进化，当我们一个人就可以快速的完成一个小程序的开发时，我们就可以依靠个人力量去做一些产品，万一这个产品火爆了呢？没准就实现财务自由了。这是一个很美好的梦想对不对？马爸爸也说过，人总是要有梦想的，万一实现了呢？如果马爸爸没说过，那就算作我说的。\xa0'
            '好了，废话不多说，今天我们一起来学习以下三块内容：❝1 创建集合 2 添加记录 3 云函数读取云数据库❞一 '
            '创建集合集合的概念，顾名思义，就是同类数据的集合。例如我们有个产品的集合里面放的都是产品的数据。我们的“为你推荐”模块就是从产品集合里面随机读取4条数据。\xa0'
            '我们先来看看在开发者工具中如何创建集合。首先，点击“云开发”\xa0然后点击“数据库”，并通过点击“+”号，创建集合。\xa0'
            '在弹出的窗口中输入集合的名称，这里我们输入products：\xa0点击“确定”，我们就能在左侧看到我们创建的集合了。二 '
            '添加记录接下里我们来添加记录，先点击我们的集合“products”，再点击“添加记录按钮”。在弹出窗口，我们可以通过加号按钮添加该条记录的属性及值。\xa0'
            '我们以添加产品名为例。字段名输入“name”，类型选择string，值输入“陨石拿铁”。对于我们来讲，一条产品的记录光有name是不够的。一共有以下这几个字段：name：产品名nPrice：折后价格oPrice：原始价格thum：产品缩略图image：产品大图categoryId：产品分类id其中image和categoryId暂时用不着，但我们预留着。\xa0'
            '除了手动一条一条的添加记录之外，我们还可以批量导入数据。在我们点击集合名称“products”之后，我们选择“导入”按钮\xa0'
            '在打开的窗口中点击“选择文件”，\xa0找到我们的json文件（该文件我会在源代码中提供）：\xa0'
            '完成导入后我们就能看到我们导入的数据了：\xa0'
            '我们来简单分析一下导入的数据。也就是我们的products.json文件。它虽然是以json结尾，但是又和我们平时接触的json不太一样。那我们就来做一个对比。普通的json文件如下[\xa0\xa0'
            '{name:”拿铁”},\xa0\xa0'
            '{name:”陨石拿铁”}]我们可以看到中括号清晰的表示这是一个数组，数组内的每条记录之间还有逗号“,”相隔。\xa0'
            '而云数据库中的集合用的是jsonline格式如下：{name:”拿铁”}{name:”陨石拿铁”}数据外面没有中括号，记录之间也没有逗号“,”相隔。接下来，我们就要进入编码环节了。三 '
            '云函数读取云数据库接下来，我们要改造之前的云函数，将里面写死的数据，改成随机从数据库中读取。\xa0'
            '我们打开“cloudfunctions/client_home_get_best/index.js”文件。在第四行添加两行代码：const\xa0'
            'db\xa0=\xa0cloud.database()const\xa0products\xa0=\xa0'
            'db.collection("products")这两行代码什么意思呢？第一行，是用一个常量db表示我们对数据库的引用。接着再声明一个常量product表示我们对创建的集合“products”的引用。这样，我们就能通过products对产品数据进行操作了。\xa0'
            '接下来，我们要实现的是，随机读取4条记录。const\xa0data\xa0=\xa0await\xa0'
            'products\xa0\xa0\xa0\xa0.aggregate()\xa0\xa0\xa0\xa0'
            '.sample({\xa0\xa0\xa0\xa0\xa0\xa0size:\xa04\xa0\xa0\xa0\xa0'
            '})\xa0\xa0\xa0\xa0'
            '.end()我们一行一行的解释，第一行，我们要注意到一个关键字“await”，这表示我们的数据读取是同步的，为什么要这么做呢？因为数据库的操作默认是异步的。如果我们不改成同步的，那么我们在获取数据之前，云函数就直接返回结果了，那我们就什么数据都拿不到了。所以，关键字await是必须的。\xa0'
            '第二行 aggregate()，这表示我们要对集合进行聚合操作。\xa0'
            '聚合操作能对记录进行一些复杂的处理，例如随机挑选数据。它通常end()做结束。\xa0'
            '而第三行sample就是我们这次的关键了，它接收的参数size就表示是随机取出记录的数量。data是我们拿到的数据，但是data里面的list才是我们所要的，所以返回的时候要这么写：return\xa0'
            '{\xa0\xa0\xa0\xa0……\xa0\xa0\xa0\xa0data:\xa0data.list,\xa0\xa0'
            '}最后来看看完整的代码：//\xa0云函数入口文件const\xa0cloud\xa0=\xa0'
            "require('wx-server-sdk')cloud.init()const\xa0db\xa0=\xa0"
            'cloud.database()const\xa0products\xa0=\xa0'
            'db.collection("products")//\xa0云函数入口函数exports.main\xa0=\xa0'
            'async\xa0(event,\xa0context)\xa0=>\xa0{const\xa0wxContext\xa0=\xa0'
            'cloud.getWXContext()const\xa0status\xa0=\xa0"success"const\xa0'
            'msg\xa0=\xa0""const\xa0data\xa0=\xa0await\xa0'
            'products\xa0\xa0\xa0\xa0.aggregate()\xa0\xa0\xa0\xa0'
            '.sample({size:\xa04\xa0\xa0\xa0\xa0})\xa0\xa0\xa0\xa0'
            '.end()console.log(data)return\xa0{status:\xa0status,msg:\xa0'
            'msg,data:\xa0data.list,\xa0\xa0'
            '}}当我们写完index.js的代码，记得要将云函数的代码上传到云服务器上。怎么做呢？如下：完整代码我放在了github上，地址是：https://github.com/gogoswift/luckin[1]本文作者 '
            '：「曾伟@喵先森」 ，文章转载自公众号【图雀社区】',
 'date': '2020-8-12 11:12',
 'title': '使用原生开发高仿瑞幸小程序（四）：编写云函数并连接云数据库 ... '}
****************************************
{'author': 'Rolan',
 'content': '完成 Layout '
            '布局十年前，张小龙说过：“一个产品，要加多少功能，才能成为一个垃圾产品。”仅此一句话，道尽他做产品的理念。小程序就是其产品理念的最佳实践，少即是多，小即是大。今天，我们来绘制如下的界面要实现以上布局，我们需要学习以下三块内容❝1 '
            '通过图片的宽度计算出图片的高度 2 学会使用row组件 3 学会使用col组件❞一 '
            '分析布局看看我们要实现的布局，横平竖直，方方正正，比例匀称。其实这是非常容易实现的。我们将要用到vant组件库的layout布局系统。我们可以通过其中的row来实现横向布局。使用col实现竖向布局。row和col搭配起来，就能完成我们今天的布局了。首先我们来分析一下布局，我们可以把整个布局分为上下两个row，如下：ok，接下来，我们再用col填充row，如下图：\xa0'
            '最后一步是什么呢？我们在每个col之中放入image组件即可。至此，我们就完成了布局的分析。为什么要用row和col？因为它们有个非常厉害的属性span。利用这个属性，我们能实现按比例布局。怎么个按比例法呢？在vant的layout系统中，横向被分为24分。如果要在row中放两个一样大小的col，只需要将将col的span设为24 '
            '/ 2 = 12。以此类推，如果要放三个一样宽的col，只需要将每个col的span设为24 / 3 = '
            '8。这就实现了我们第二个row的布局。现在我们来分析一下第一个row怎么布局。我们通过观察可知，第一个Row中有两个col，他们的比例是2:1，所以第一个col的span为 '
            '（24 / 3）* 2 = 16，第二个col的span为 24 / 3 = 8 。这样就实现了2:1的布局。二 '
            '通过图片的宽度计算出图片的高度我们需要六张图片，把它们放在云存储中。图片资源我放在了github中，github的地址会在文章末尾放出。 '
            '让我们来想想，要完成布局我们需要知道什么？我们知道屏幕宽度，知道图片左右边距，知道图片之间的距离，知道图片之间的比例，那么我们就知道了图片的宽度。所以我们需要通过计算获得图片在屏幕上的高度。为了让图片不变形，图片在屏幕上的高宽比要等于图片真实的高宽比，这就是我们计算的基础。图片在屏幕的高/图片在屏幕上的宽=图片真实的高/图片真实的宽 '
            '图片在屏幕上的高 =\xa0 图片在屏幕上的宽 * 图片真实的高/图片真实的宽 '
            '拿第一个row中的第一张图片来说，它真实高是666，宽是330。那么怎么得到它在屏幕上的宽呢？可通过以下的简单公式进行计算：屏幕宽度-左右外边距(margin)-左右内边距(padding)-与右边图片的距离 '
            '即是750\xa0-\xa040\xa0-\xa040\xa0-\xa06\xa0=\xa0664所以它在屏幕上的高度就是 664 '
            '* 330 / 666 通过以上的方法，我们能算出每一张图片在屏幕上的高度三 '
            'row与col组件我们该怎么理解row与col呢？其实就是表格中的“行”与“列”。它们除了有能设置占位比例的span属性，row还有能设置元素间间距的gutter属性。还有一些其他属性，例如布局方式type，对齐方式justify，align，偏移量offset。点击时触发的click事件。这里就不做详细介绍了，有兴趣的同学可以去官方查看，地址如下https://youzan.github.io/vant/#/zh-CN/col[1]让我们来看看，我们在这一节中是如何实际运用的。首先，我们需要打开app.json，在“usingComponents”属性中引入我们今天要用到的三个组件，row，col和image"usingComponents":\xa0'
            '{\xa0\xa0"van-image":\xa0"@vant/weapp/image/index",\xa0\xa0'
            '"van-row":\xa0"@vant/weapp/row/index",\xa0\xa0"van-col":\xa0'
            '"@vant/weapp/col/index"}接下来，我们来创建一个view用来存放我们的row<view\xa0'
            'class="mid_menu"></view>给它一个样式.mid_menu{\xa0\xa0margin-top:\xa0'
            '50rpx;\xa0\xa0margin-left:\xa020rpx;\xa0\xa0margin-right:\xa0'
            '20rpx;\xa0\xa0background-color:\xa0white;\xa0\xa0'
            'border-radius:\xa030rpx;\xa0\xa0padding:\xa0'
            '20rpx;}margin-top设置了顶边距 margin-left 和 '
            'margin-right分别设置了左边距与右边距。background-color:设置了背景色为白色 padding设置了内边距 '
            'border-radius:设置了圆角半径 '
            '对于第一个row来讲，我们需要放量个col进来，还记得它们的比例吗？是2:1，也就是16:8<van-row\xa0'
            'gutter="6">\xa0<van-col\xa0span=“16">\xa0放一张图片\xa0</van-col>\xa0'
            '<van-col\xa0span=“8">\xa0放两张图片\xa0'
            '</van-col></van-row>别忘了我们要设置这两个col之间的间距为6，也就是设置row的gutter的值。接下来，我们只要在col中放入image组件就好，这里我们使用了vant组件库中的vant-image，这是一个非常方便的同时封装了很多强大功能的组件。例如我们可以直接设置它的高宽属性。由于我们已经使用span属性分配了它们的宽度比例，所以每一个image的宽只需要设置100%就好，而它的高，我们会绑定在一个计算好的属性中。例如rowHeight，height=“{{rowHeight}}rpx"\xa0'
            '别忘了单位是rpx。而这个属性放在哪里呢？如果大家有印象的话，我们存放在js文件的data对象中。data:\xa0'
            '{……rowHeight:0,……}而rowHeight的计算，我们会放在attached函数中。而attached又是什么呢？我们来复习一下，这是当组件完成初始化，进入页面节点树后会被触发的函数。如此就完成了第一个row的绘制。第二个row来说就更加简单了，它分为三个等比例的col<van-row\xa0'
            'gutter="6">\xa0\xa0<van-col\xa0span="8">\xa0\xa0</van-col>\xa0\xa0'
            '<van-col\xa0span="8">\xa0\xa0</van-col>\xa0\xa0<van-col\xa0'
            'span="8">\xa0\xa0'
            '</van-col></van-row>同样，col中的image的宽度设为100%，而高度需要计算。让我们来看看完整代码<view\xa0'
            'class="mid_menu">\xa0<van-row\xa0gutter="6">\xa0\xa0<van-col\xa0'
            'span="16">\xa0\xa0\xa0<van-image\xa0width="100%"\xa0'
            'height="{{rowHeight}}rpx"\xa0'
            'src="cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/01.png"\xa0'
            '/>\xa0\xa0</van-col>\xa0\xa0<van-col\xa0span="8">\xa0\xa0\xa0'
            '<van-image\xa0width="100%"\xa0height="{{(rowHeight\xa0-\xa0'
            '6)/2}}rpx"\xa0'
            'src="cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/02.png"\xa0'
            '/>\xa0\xa0\xa0<van-image\xa0width="100%"\xa0'
            'height="{{(rowHeight\xa0-\xa06)/2}}rpx"\xa0'
            'src="cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/03.png"\xa0'
            '/>\xa0\xa0</van-col>\xa0</van-row>\xa0<van-row\xa0'
            'gutter="6">\xa0\xa0<van-col\xa0span="8">\xa0\xa0\xa0<van-image\xa0'
            'width="100%"\xa0height="{{\xa0rowHeight2\xa0}}rpx"\xa0'
            'src="cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/04.png"\xa0'
            '/>\xa0\xa0</van-col>\xa0\xa0<van-col\xa0span="8">\xa0\xa0\xa0'
            '<van-image\xa0width="100%"\xa0height="{{\xa0rowHeight2\xa0'
            '}}rpx"\xa0'
            'src="cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/05.png"\xa0'
            '/>\xa0\xa0</van-col>\xa0\xa0<van-col\xa0span="8">\xa0\xa0\xa0'
            '<van-image\xa0width="100%"\xa0height="{{\xa0rowHeight2\xa0'
            '}}rpx"\xa0'
            'src="cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/06.png"\xa0'
            '/>\xa0\xa0</van-col>\xa0'
            '</van-row></view>//在rpx的单位下，屏幕的宽度都为750const\xa0winWidth\xa0=\xa0'
            '750const\xa0rowWidth\xa0=\xa0(winWidth\xa0-\xa080-6)*2/3const\xa0'
            'rowHeight\xa0=\xa0rowWidth\xa0*\xa0330/666\xa0const\xa0'
            'rowWidth2\xa0=\xa0(winWidth\xa0-\xa080\xa0-12)/3const\xa0'
            'rowHeight2\xa0=\xa0rowWidth2\xa0*\xa0'
            '315/324为你推荐“为你推荐”模块我们将分成三个部分❝1 静态数据的界面 2 通过云函数获取数据 3 '
            '通过云数据库获取数据❞今天，我们讲的是第一部分如何绘制静态数据的“为你推荐”。也将分为三块内容❝1 布局分析 2 编写静态数据 3 '
            '绑定数据，循环渲染❞一 我们来分析一下布局我们可以看出，这个模块由上下两个row组成\xa0'
            '我们来分析一下，上面的row由三个col组成。第二个col利用offset属性，与第一个col拉开了距离。如下图：\xa0'
            '略微复杂的是下面的row，等分城了4个col。\xa0'
            '现在我们来分析单个col。我们知道，在col中，元素是从上而下布局的。所以从上到下，依次为image，view。下面的价格由于我们要用到横向布局，所以是一个row，如下图：\xa0'
            '让我们来重点分析一下最下面的row的布局。我用了三个col，第一个col用来放价格，第二个是加号按钮，第三个col实现的是右编剧。他们的比例分别是18:4:2 '
            '我们知道col是垂直布局，所以放置价格的col中我们会放入两个view。我比较喜欢在view中放文字。至此，我们就完成了布局的分析。二 '
            '静态数据“为你推荐”模块的数据是从云数据库中读取的，只不过在这一节中，我们将先采用静态数据模拟一下。我们该怎么写静态数据呢？首先，我们要认识到，为你推荐这个模块推荐的是4个产品。所以这个数据应该是一个数组。而每个产品的参数是一致的，应该有缩略图：thum，产品名：name，原价：oPrice，折扣价：nPrice。所以我们在“pages/home/cmponents/home/home.js”文件中的静态数据编写如下：data:\xa0'
            '{\xa0\xa0\xa0\xa0......\xa0\xa0\xa0\xa0products:\xa0'
            '[{\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0'
            '"拿铁",\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '24,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa0'
            '12,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/88F34543128D-1.jpeg"\xa0\xa0\xa0\xa0\xa0\xa0'
            '},\xa0\xa0\xa0\xa0\xa0\xa0{\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0'
            'name:\xa0"提拉米苏爱摩卡",\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '19,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa0'
            '28,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/7B69340506EC-1.jpeg"\xa0\xa0\xa0\xa0\xa0\xa0'
            '},\xa0\xa0\xa0\xa0\xa0\xa0{\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0'
            'name:\xa0"陨石拿铁",\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '28,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa0'
            '16.8,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/82B1B9FDDB21-1.jpeg"\xa0\xa0\xa0\xa0\xa0\xa0'
            '},\xa0\xa0\xa0\xa0\xa0\xa0{\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0'
            'name:\xa0"榛果拿铁",\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0oPrice:\xa0'
            '28,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0nPrice:\xa0'
            '16.8,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0thum:\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/FBD8B7AADBD9-1.jpeg"\xa0\xa0\xa0\xa0\xa0\xa0'
            '}\xa0\xa0\xa0\xa0]\xa0\xa0},\xa0\xa0'
            '......}这里所涉及的图片我会放在github上。大家可以存到自己的云存储上。「三 '
            '绑定静态数据」最后，让我们来看看界面上的代码该怎么写，打开“pages/home/cmponents/home/home.wxml”，新增一个view<view\xa0'
            'class="mid_menu">\xa0<van-row\xa0gutter="6">\xa0\xa0<van-col\xa0'
            'span="8">\xa0\xa0\xa0<view\xa0'
            'class="menu_title">为你推荐</view>\xa0\xa0</van-col>\xa0\xa0'
            '<van-col\xa0span="6"\xa0offset="8">\xa0\xa0\xa0<view\xa0'
            'class="change">换一批</view>\xa0\xa0</van-col>\xa0\xa0<van-col\xa0'
            'span="2">\xa0\xa0\xa0<van-icon\xa0color="gray"\xa0size="28rpx"\xa0'
            'name="replay"\xa0/>\xa0\xa0</van-col>\xa0</van-row>\xa0'
            '<van-row\xa0gutter="10">\xa0\xa0<block\xa0'
            'wx:for="{{products}}"\xa0wx:key="*this">\xa0\xa0\xa0<van-col\xa0'
            'span="6">\xa0\xa0\xa0\xa0<van-image\xa0radius="16rpx"\xa0'
            'width="{{productWidth}}rpx"\xa0height="{{productWidth}}rpx"\xa0'
            'src="{{item.thum}}"\xa0/>\xa0\xa0\xa0\xa0<view\xa0'
            'class="pTitle">{{item.name}}</view>\xa0\xa0\xa0\xa0'
            '<van-row>\xa0\xa0\xa0\xa0\xa0<van-col\xa0'
            'span="18">\xa0\xa0\xa0\xa0\xa0\xa0<view\xa0'
            'class="nPrice">¥{{item.nPrice}}</view>\xa0\xa0\xa0\xa0\xa0\xa0'
            '<view\xa0'
            'class="oPrice">¥{{item.oPrice}}</view>\xa0\xa0\xa0\xa0\xa0'
            '</van-col>\xa0\xa0\xa0\xa0\xa0<van-col\xa0'
            'span="4">\xa0\xa0\xa0\xa0\xa0\xa0<image\xa0'
            'style="width:30rpx;height:30rpx;margin-top:10rpx;"\xa0'
            'src="./images/btnAdd.png"\xa0/>\xa0\xa0\xa0\xa0\xa0'
            '</van-col>\xa0\xa0\xa0\xa0\xa0<van-col\xa0'
            'span="2">\xa0\xa0\xa0\xa0\xa0</van-col>\xa0\xa0\xa0\xa0'
            '</van-row>\xa0\xa0\xa0</van-col>\xa0\xa0</block>\xa0'
            '</van-row></view>这里面的知识点，其实我们之前都讲过。无非就是以下几点：❝1 '
            'row和col的使用，它们是如何按比例布局的，今天的新知识点是偏移量属性offset，用来实现间隔布局。2 '
            '推荐的产品，我们用block和wx:for实现了数据的绑定和产品的循环渲染。wx:key和item的意义也是学过的内容。❞所以，如果大家是从头一路看过来的，这节将是非常轻松的。如果对样式有什么疑问，可以参看home.wxss里面的内容。下一节，将会有新的内容，云函数，这是一个非常强大的功能。学会使用后，我们就离10x程序员又近了一步。❝本文转载自公众号【图雀社区】，作者 '
            '：「曾伟@喵先森」',
 'date': '2020-8-12 11:22',
 'title': '使用原生开发高仿瑞幸小程序（三）：完成 Layout 布局和为你推荐模块 ... '}
****************************************
{'author': 'Rolan',
 'content': '创建轮播图轮播图是我们常见的一种表现形式，通常，图片之间要做到无缝衔接循环需要花一些功夫，而小程序提供的组件就已经可以实现。可以说省去了开发者不少的时间。所以，今天我们要一起来学习以下几件事：❝1 '
            '学会使用云存储 2 学会使用image组件 3 简单自定义navigation 4 学会使用swiper组件来创建轮播图❞一 '
            '云存储的使用让我们一步一步的来，首先我们需要给小程序的首页创建一个背景。如下图\xa0'
            '在这里，背景图片我放到了云存储上。要知道，当我们创建小程序后，我们有5G存储空间和5G的流量可以免费使用。这足够我们开发使用了。那么，怎么把背景图图片放到云存储上呢？我们在微信开发者工具的顶部找到“云开发”按钮。这时候，我们会打开“云开发控制台”。我们再点击“存储”按钮，就来到了云存储的管理界面。如下图我们可以通过“新建文件夹”来进行分类管理。想我，我就创建了“images”文件夹，同时在images文件夹下面根据Tabbar又创建了。“home”，“menu”，“cart”，“order”和“my”五个文件夹。因为我们现在在创建首页嘛，所以我会把首页下的相关图片都放在home文件夹下。云存储不仅能存图片，还能存放其他文件，这里就不细讲了。我们可以点击“上传文件”按钮，将今天所需的图片素材，传到云存储上。我将背景图和今天轮播图所需的图片都传到了“images/home”文件夹下。我们的image组件能直接使用File '
            'ID，省却了地址转换的麻烦。File ID的地址如下图所示。\xa0'
            '上图红框所标示的地址就是我们背景图片的地址，让我们复制一下，接下来马上就会用到。二 '
            '利用image组件创建背景接下来，我们需要使用的是image组件，我们将通过改变它的z坐标将它放置在其他组件的“下面”，这样就变成了home页面的背景了。为什么不用css中的background-image呢？因为这个属性必须使用网络图片或者base64图片。而我们的云存储的File '
            'ID地址必须要转换一下才能获得真实地址，所以太麻烦，不如直接用image来的快。好，接下来看看怎么使用image组件。首先，我们用view给整个试图创建一个根容器，仿造html，我们给class起名为body<view\xa0'
            'class="body"></view>接着，我们在其中放入image组件，背景图片<view\xa0'
            'class="body"><image\xa0class="bg"\xa0'
            'src="cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/homebg.png"></image></view>我们给image '
            '的class属性赋值为bg。接下我们到home.wxss中做一些工作。首先，我们让body横向撑满整个屏幕.body{\xa0\xa0'
            'width:\xa0100%;}接下来，我们要将改变image组件的z坐标了。.bg{\xa0\xa0/*fixed\xa0'
            '固定位置\xa0absolute\xa0跟随屏幕滚动\xa0*/\xa0\xa0position:\xa0'
            'absolute;\xa0\xa0\xa0top:\xa00;\xa0\xa0z-index:\xa0'
            '-100;}z-index就是我们所说的z坐标了。什么是z坐标呢，我们知道横轴是x坐标，竖轴是y坐标。xy组成了一个平面，也就是我们的手机屏幕。那么垂直与手机屏幕的就是z坐标。z坐标的值越小，就在越后面，也就会被挡住。那么当我们把z-index设为-100的时候，image就位于其他组件的下方了。很好，如果一切正确，将会看到如下画面。这和我们所期望的效果有些不一样？我们期待的效果是没有顶部的navigation的对不对？不要着急，接下来我们就来解决这个问题。三 '
            '简单自定义navigation其实要让顶部的navigation消失非常简单，我们只需要打开“pages/home/home.json”，添加"navigationStyle":\xa0'
            '“custom",即可，这行代码的意思就是，我们将使用自定义的navigation。我们只要什么都不做，就让将默认的navigarion消失了。如下图所示四 '
            '创建轮播图如何创建轮播图呢？答案是，使用小程序提供的swiper组件。使用swiper组件，一切都将变得非常的简单。❝1 '
            '我们将在home.wxml中创建swiper 2 我们将在home.js中定义轮播图的数据 3 '
            '我们将在home.js中定义swiper所需要的定位数据❞首先，让我们创建swiper<view\xa0'
            'class="swiper"><swiper\xa0circular\xa0=\xa0"{{true}}"\xa0'
            'indicator-active-color="#ffffff"\xa0'
            'bindanimationfinish="onFinish"\xa0'
            'indicator-dots="{{indicatorDots}}"\xa0autoplay="{{autoplay}}"\xa0'
            'interval="{{interval}}"\xa0duration="{{duration}}"><block\xa0'
            'wx:for="{{swiperData}}"\xa0wx:key="*this"><swiper-item>\xa0\xa0'
            '<image\xa0src="{{item}}"\xa0'
            'mode="widthFix"></image></swiper-item></block></swiper></view>我在创建swiper之前，会在其外面套一层view，用来做定位以及样式相关控制。那么就来看看我都对view做了什么样的样式控制。.swiper{\xa0\xa0'
            'margin-left:\xa020rpx;\xa0\xa0margin-right:\xa020rpx;\xa0\xa0'
            'border-radius:\xa030rpx;\xa0\xa0/*\xa0使内容同样获得圆角\xa0*/\xa0\xa0'
            'overflow:\xa0hidden;\xa0\xa0/*\xa0transform:\xa0translateY(0);\xa0'
            '*/}在这里，我们通过margin-left设置了左边距离屏幕20rpx，margin-right右边距也是20rpx，border-radius设置了圆角矩形的半径为30rpx，最后，为了让view所包含的swiper也能有圆角效果，我们还需要将overflow设置为hidder。知识点，我们知道px是像素的意思，那么rpx是什么样的尺寸呢？以往我们在开发手机app的时候，为了在不同尺寸的屏幕上显示一样的设计效果，我们需要根据尺寸的不同进行一定的换算。如果使用rpx则可以进行自适应了，省却了换算的麻烦。至此，我们就完成了外层样式的设定，接下来，让我们回到home.wxml中，看看swiper的代码都是什么意思。在swiper标签中，我们能看到属性circular '
            '设为了truecircular\xa0=\xa0'
            '“{{true}}"这表示，我们开启了循环轮播，大家可以把这个属性去掉，看看有什么不同的效果。bindanimationfinish=“onFinish”标示，我们在每个图片切换动画完成后，会执行onFinish函数。indicator-dots=“{{true}}" '
            '表示轮播图将会显示指示小圆点 indicator-active-color=“#ffffff" '
            '表示选中的小圆点的颜色，这里我设置为了白色。interval=“{{2000}}” 表示图片的切换相隔2000毫秒也就是2秒 '
            'duration=“{{500}}" 表示切换动画持续时间为0.5秒 '
            '以上就是关于swiper的基本设置。接下来，我们将会用block来设置swiper的数据源以及通过swiper-item来设置轮播的图片。在代码中，我们可以看到block标签。这是wxml的语法标签。在这个标签下，我们能够有限的使用一些流程控制语法。例如在这一节中，我们使用的 '
            'wx:for，它可以绑定一个数组，将多个字节点渲染出来。wx:for '
            '我们绑定的是组件home.js中的一个数组swiperData，和页面的js一样，放在data对象中。data:\xa0'
            '{\xa0\xa0\xa0\xa0swiperData:\xa0[\xa0\xa0\xa0\xa0\xa0\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/DC240B320F4-1.jpeg",\xa0\xa0\xa0\xa0\xa0\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/6C04DA13FC28-1.jpeg",\xa0\xa0\xa0\xa0\xa0\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/DA98AD7CF153-1.jpeg",\xa0\xa0\xa0\xa0\xa0\xa0'
            '"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/87542BE16ED7-1.jpeg"\xa0\xa0\xa0\xa0'
            '],}而wx:key这是用来给for中的每一个子项一个唯一标识的，这样可以在数据源有改动时，原有的子对象能保留状态，例如文本框里输入的内容。wx:key '
            '的值以两种形式提供❝1 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property '
            '的值需要是列表中唯一的字符串或数字，且不能动态改变。2 保留关键字 *this 代表在 for 循环中的 item '
            '本身，这种表示需要 item 本身是一个唯一的字符串或者数字。❞我们的轮播图，用的是*this。swiper-item '
            '标签仅可放在swiper标签中，宽高自动设置为100%。我们在swiper-item中再放一个image组件。我们只需要把image的属性src赋值即可。那么我们怎么获得swiperData数组中的元素呢？很简单，在wx:for遍历数组的时候，item就代表着数组中的元素。即：<image\xa0'
            'src="{{item}}"\xa0'
            'mode="widthFix"></image>我们发现，轮播图的位置距离顶部太近了，我们至少要把状态栏和标题栏空出来。状态栏和标题栏的高度，我们可以通过系统动态获取。所以我们组件home.js中，预留两个属性statusBarHeight: '
            '0,titleBarHeight: '
            '0,这两个属性的值，我们会在组件进入页面时进行赋值。这样，在组件被渲染时就能拿来用了。我们要做什么来着？为了让轮播组件下来一点。所以我们可以在承载swiper的view中这么写。style="margin-top:{{(titleBarHeight\xa0'
            '+\xa0statusBarHeight)}}rpx;height\xa0'
            '{{((wx.getSystemInfo().windowWidth\xa0-\xa0'
            '40)*540/1065)}}rpx;”这是一种编写样式的方式，为什么写在在wxml中，这是为了能够动态的使用statusBarHeight和titleBarHeight。我们注意到，除了使用margin-top，这个用来设定定边距的属性之外，我们还设置了height的值，也就是轮播组件的高度。这里有一个小公式。用来根据屏幕宽度动态计算轮播组件的高度。按比例拉升的公式是这样的：根据 '
            '轮播组件高/轮播组件的宽 = 图片高/图片宽 可以推导出 轮播组件的高 = 轮播组件的宽 * 图片高/图片宽 '
            '图片的高宽，我们是可以知道的，分别为540和1065，自己搞得图片嘛，当然知道saize。那轮播组件的宽呢？等于屏幕的宽wx.getSystemInfo().windowWidth '
            '减去 左右边距即40 所以轮播组件的高 = wx.getSystemInfo().windowWidth - '
            '40)*540/1065 '
            '如果看到这里还没有头昏脑胀的话，我们继续往下看，如何获得statusBarHeight和titleBarHeight的值？我们可以通过微信提供的api：getSystemInfo获得。代码如下代码如下attached()\xa0'
            '{\xa0\xa0\xa0\xa0var\xa0statusBarHeight\xa0=\xa00\xa0\xa0\xa0\xa0'
            'var\xa0titleBarHeight\xa0=\xa00\xa0\xa0\xa0\xa0'
            'wx.getSystemInfo({\xa0\xa0\xa0\xa0\xa0\xa0success:\xa0(res)\xa0'
            '=>\xa0{\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0statusBarHeight\xa0=\xa0'
            'res.statusBarHeight\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0'
            'titleBarHeight\xa0=\xa0'
            'wx.getMenuButtonBoundingClientRect().bottom\xa0+\xa0'
            'wx.getMenuButtonBoundingClientRect().top\xa0-\xa0'
            '(res.statusBarHeight\xa0*\xa02)\xa0\xa0\xa0\xa0\xa0\xa0'
            '},\xa0\xa0\xa0\xa0\xa0\xa0failure()\xa0'
            '{\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0statusBarHeight\xa0=\xa0'
            '0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0titleBarHeight\xa0=\xa0'
            '0\xa0\xa0\xa0\xa0\xa0\xa0}\xa0\xa0\xa0\xa0})\xa0\xa0\xa0\xa0'
            'this.setData({\xa0\xa0\xa0\xa0\xa0\xa0statusBarHeight:\xa0'
            'statusBarHeight,\xa0\xa0\xa0\xa0\xa0\xa0titleBarHeight:\xa0'
            'titleBarHeight\xa0\xa0\xa0\xa0'
            '})},大家注意到，我们在计算titleBarHeight的时候，调用了wx.getMenuButtonBoundingClientRect这个api，这是什么呢？这个api能获取微信右上角胶囊按钮的布局信息。好有一个新的知识点需要学习一下，就是在组件中，attached函数是干嘛的？这是组件生命周期的一个函数，当在组件实例进入页面节点树时就会执行，在我们的实例中，我们正是利用这个函数给我们的组件的顶边距赋值的。小程序的全局数据这一节我们只讲一件事，就是如何在小程序里面使用全局数据。涉及三个方面❝1 '
            '为什么要使用全局数据 2 怎么存储全局数据 3 '
            '怎么读取全局数据❞那么，为什么要使用全局数据？我们试想一下，如果有些数据所有界面都要用呢，该怎么办？一个页面一个页面的传会不会太麻烦了？我们就在首页中尝试着使用一下全局数据。我们在小程序的项目文件中能看到app.js这个文件。\xa0'
            '这个文件用来干什呢？是用来注册小程序用的，同时小程序的一系列事件都会在这个文件里得到响应。例如小程序初始化了，小程序前后台切换，还有就是可以用来存储一些全局数据。重要的是，整个小程序只会有一个app.js的实例。这也是为什么它适合用来存储全局数据。怎么存放呢？我们注意到app.js中有这么一行代码this.globalData\xa0'
            '=\xa0'
            '{}这行代码的意思是，app的实例中，有个对象叫globalData，我们通常会把全局数据存放在globalData这个对象中。那么，当我们把全局数据存放到app.js中的话，我们又该如何读取出来呢？首先，我们能够通过全剧函数getApp()获得app.js的唯一实例。接着就能通过点语法取出数据了，完整代码差不多就是这个样子。getApp().globalData.数据所以整个过程就这么简单，分两步，放进去，取出来。好，还记得上一节我们讲过的如何计算轮播图的顶边距吗？我们需要得到statusBarHeight和titleBarHeight。那我们现在就把这两个值放入全局数据中。所以我们把home.js中attached函数中的代码移到app.js中，并将statusBarHeight和titleBarHeight的值赋给globalData。代码如下this.globalData\xa0'
            '=\xa0{}wx.getSystemInfo({\xa0\xa0success:\xa0(res)\xa0=>\xa0'
            '{\xa0\xa0\xa0\xa0this.globalData.statusBarHeight\xa0=\xa0'
            'res.statusBarHeight\xa0\xa0\xa0\xa0'
            'this.globalData.titleBarHeight\xa0=\xa0'
            'wx.getMenuButtonBoundingClientRect().bottom\xa0+\xa0'
            'wx.getMenuButtonBoundingClientRect().top\xa0-\xa0'
            '(res.statusBarHeight\xa0*\xa02)\xa0\xa0},\xa0\xa0failure()\xa0'
            '{\xa0\xa0\xa0\xa0this.globalData.statusBarHeight\xa0=\xa0'
            '0\xa0\xa0\xa0\xa0this.globalData.titleBarHeight\xa0=\xa00\xa0\xa0'
            '}})这完成了第一步，把数据放进去。现在我们把数据取出来。回到home.js的attached函数中，以下是取出数据的代码attached()\xa0'
            '{this.setData({\xa0\xa0statusBarHeight:\xa0'
            'app.globalData.statusBarHeight,\xa0\xa0titleBarHeight:\xa0'
            'app.globalData.titleBarHeight})},我们注意到更新数据用的是this.setData函数。使用这个函数更新数据，绑定数据的界面才会更新。更正轮播组件的高度计算❝首先是一个知识点，当我们在小程序中使用rpx单位的时候，屏幕的宽度都为750rpx。我们通过wx.getSystemInfoSync().windowWidth获得的是px为单位的屏幕宽度。如果涉及到需要使用屏幕宽度来计算尺寸，请使用750，因为我们在小程序中，使用的单位是rpx。❞现在，我们来重新计算轮播图的高度。之前，我们把高度的计算直接写在了wxml中，现在我们把它剥离出来，同时用变量swiperHeight做为高度的绑定。`如下：style="margin-top:{{(titleBarHeight\xa0'
            '+\xa0'
            'statusBarHeight)}}rpx;height:{{swiperHeight}}rpx;"于是，我们的精力将集中在swiperHeight的计算上。首先，我们需要在data中声明swiperHeightdata:\xa0'
            '{\xa0\xa0\xa0\xa0'
            'swiperHeight:0,......接着，我们来计算swiperHeight，而我们之前推导过高度的计算，还记得吗？如下：轮播组件的高度\xa0'
            '=\xa0(wx.getSystemInfo().windowWidth\xa0-\xa0'
            '40)*540/1065现在我们知道了，不该使用wx.getSystemInfo().windowWidth，而该直接使用750.所以我们的计算公式就该改为如下：const\xa0'
            'winWidth\xa0=\xa0750const\xa0swiperHeight\xa0=\xa0(winWidth\xa0'
            '-\xa040\xa0)\xa0*\xa0'
            '540/1065计算完后，别忘了使用setData更新swiperHeight的值。这下，轮播图的显示终于完美。\xa0'
            '本文转载自公众号【图雀社区】，作者 ：「曾伟@喵先森」',
 'date': '2020-8-12 11:42',
 'title': '使用原生开发高仿瑞幸小程序（二）：使用云存储并实现轮播图 ... '}
****************************************
{'author': 'Rolan',
 'content': '鉴于在下使用微信小程序开发时使用\xa0setData\xa0的蹩脚体验，开发了个库函数\xa0wx-updata\xa0'
            '，项目上线之后，我把这个自用的库函数整理放到 Github 上开源出来\xa0wx-updata\xa0'
            '，这个库函数在开发的时候对我很有帮助，希望也可以帮到大家 :clap:如果大家在使用中遇到了问题，可以给我提 pr，提 '
            'issue，一起来改善小程序开发体验加油～1. setData 不方便的地方你在使用\xa0setData\xa0'
            '的时候，是不是有时候觉得很难受，举个简单的例子：// 你的 data\r\n'
            'data: {\r\n'
            "    name: '蜡笔小新',\r\n"
            "    info: { height: 140, color: '黄色' }\r\n"
            '}\r\n'
            '复制代码如果要修改\xa0info.height\xa0为 155，使用\xa0setData\xa0要怎么做呢：// 这样会把 '
            'info 里其他属性整不见了\r\n'
            'this.setData({ info: { height: 155 } })\r\n'
            '\r\n'
            '// 你需要取出 info 对象，修改后整个 setData\r\n'
            'const { info } = this.data\r\n'
            'info.height = 155\r\n'
            'this.setData({ info })\r\n'
            '复制代码似乎并不太复杂，但如果\xa0data\xa0是个很大的对象，要把比较深且不同的对象、数组项挨个改变：data: {\r\n'
            "    name: '蜡笔小新',\r\n"
            '    info: {\r\n'
            "        height: 140, color: '黄色',\r\n"
            "        desc: [{ age: 8 }, '最喜欢大象之歌', '靓仔', { dog: '小白', color: "
            "'白色' }]\r\n"
            '    }\r\n'
            '}\r\n'
            '复制代码比如某个需求，需要把\xa0info.height\xa0改为 155，同时改变\xa0info.desc\xa0数组的第 '
            '0 项的\xa0age\xa0为 12，第 3 项的\xa0color\xa0为灰色呢？// 先取出要改变的对象，改变数字后 '
            'setData 回去\r\n'
            'const { info } = this.data\r\n'
            'info.height = 155\r\n'
            'info.desc[0].age = 12\r\n'
            "info.desc[3].color = '灰色'\r\n"
            'this.setData({ info })\r\n'
            '\r\n'
            '// 或者像某些文章里介绍的，这样可读性差，也不太实用\r\n'
            'this.setData({\r\n'
            "    'info.height': 155,\r\n"
            "    'info.desc[0].age': 12,\r\n"
            "    'info.desc[3].color': '灰色'\r\n"
            '})\r\n'
            '复制代码上面这两种方法，是我们平常小程序里经常用的，和其他 Web '
            '端的框架相比，就很蹩脚，一种浓浓的半成品感扑面而来，有没有这样一个方法：this.upData({\r\n'
            '    info: {\r\n'
            '        height: 155,\r\n'
            "        desc: [{ age: 12 }, , , { color: '灰色' }]\r\n"
            '    }\r\n'
            '})\r\n'
            '复制代码这个方法会帮我们深度改变嵌套对象里对应的属性值，跳过数组项里不想改变的，只设置我们提供了的属性值、数组项，岂不是省略了一大堆蹩脚的代码，而且可读性也极佳呢。这就是为什么我在上线的项目中使用\xa0'
            'wx-updata\xa0，而不是\xa0setData2. wx-updata 的优点支持\xa0setData\xa0'
            '对象自动合并，不用写蹩脚的对象路径了支持对象中嵌套数组，数组中嵌套对象；如果数组的某个值你不希望覆盖，请使用数组空位来跳过这个数组项，比如\xa0'
            '[1,,3]\xa0这个数组中间就是数组空位；如果数组空位你的\xa0Eslint\xa0报错，可以使用\xa0'
            'wx-updata\xa0提供的 Empty 来代替：\xa0[1, Empty, 3]3. wx-updata '
            '安装你也可以直接把\xa0dist\xa0目录下的\xa0wx-updata.js\xa0拷贝到项目里使用使用\xa0npm\xa0'
            '、\xa0yarn\xa0安装方式：$ npm i -S wx-updata\r\n'
            '# or\r\n'
            '$ yarn add wx-updata\r\n'
            '复制代码然后：详情 - 本地设置 - 使用npm模块\r\n'
            '工具 - 构建npm\r\n'
            '构建后成功生成\xa0miniprogram_npm\xa0文件夹就可以正常使用了4. wx-updata '
            '使用方法使用方式一可以使用直接挂载到\xa0Page\xa0上的方式，这样就可以在\xa0Page\xa0实例中像使用\xa0'
            'setData\xa0一样使用\xa0upData\xa0了// app.js\r\n'
            "import { updataInit } from './miniprogram_npm/wx-updata/index'  "
            '// 你的库文件路径\r\n'
            '\r\n'
            'App({\r\n'
            '    onLaunch() {\r\n'
            '        Page = updataInit(Page, { debug: true })\r\n'
            '    }\r\n'
            '})\r\n'
            '复制代码// 页面代码中\r\n'
            '\r\n'
            'this.upData({\r\n'
            '    info: { height: 155 },\r\n'
            "    desc: [{ age: 13 }, '帅哥'],\r\n"
            "    family: [, , [, , , { color: '灰色' }]]\r\n"
            '})\r\n'
            '复制代码使用方式二有的框架可能在\xa0Page\xa0对象上进行了进一步修改，直接替换\xa0Page\xa0'
            '的方式可能就不太好了，\xa0wx-updata\xa0同样暴露了工具方法，用户可以在页面代码中直接使用工具方法进行处理：// '
            '页面代码中\r\n'
            '\r\n'
            "import { objToPath } from './miniprogram_npm/wx-updata/index'  // "
            '你的库文件路径\r\n'
            '\r\n'
            'Page({\r\n'
            '    data: { a: { b: 2}, c: [3,4,5]},\r\n'
            '\r\n'
            '    // 自己封装一下\r\n'
            '    upData(data) {\r\n'
            '        return this.setData(objToPath(data))\r\n'
            '    },\r\n'
            '\r\n'
            '    // 你的方法中或生命周期函数\r\n'
            '    yourMethod() {\r\n'
            '        this.upData({ a: { b: 7}, c: [8,,9]})\r\n'
            '    }\r\n'
            '})\r\n'
            '复制代码使用 Empty 代替数组空位可以使用\xa0wx-updata\xa0提供的 Empty 来代替数组空位，由于 '
            'Empty 本质上是一个 Symbol，所以只能使用\xa0wx-updata\xa0导出的，而不能自己新建。// '
            '页面代码中\r\n'
            "import { Empty } from './miniprogram_npm/wx-updata/index'\r\n"
            '\r\n'
            'this.upData({\r\n'
            '    info: { height: 155 },\r\n'
            "    desc: [{ age: 13 }, '帅哥'],\r\n"
            "    family: [Empty, Empty, [Empty, Empty, Empty, { color: '灰色' "
            '}]]\r\n'
            '})\r\n'
            '复制代码5. wx-updata 相关 APIPage.prototype.upData(Object data, '
            'Function callback)data\xa0： 你希望设置的 datacallback\xa0： 跟\xa0'
            'setData\xa0第二个参数一样，引起界面更新渲染完毕后的回调函数updataInit(Page, '
            'config)Page\xa0： 页面对象，需要在\xa0app.js\xa0中调用；config\xa0： 若提供配置参数\xa0'
            '{ debug: true }\xa0，会将路径化后的 data 打印出来，帮助用户进行调试；objToPath(Object '
            'data)data\xa0： 你希望设置的 data '
            '对象网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~',
 'date': '2020-8-3 15:12',
 'title': '开发微信小程序，我为什么使用 upData '}
****************************************
{'author': 'Rolan',
 'content': 'mpvuempvue是一个使用vue.js开发小程序的框架。其官网的介绍是，mpvue框架基于Vue.js核心，mpvue修改了Vue.js的runtime和compiler实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套Vue.js开发体验。使用mpvue框架开发小程序，能够直接使用vue语法进行开发。Vant '
            'WeappVant '
            'Weapp是一套小程序UI组件库，可以使用这个UI库封装好的一些组件来实现某些功能，类似element组件的引入使用。flyiogithub：\xa0'
            'https://github.com/wendux/flyFlyio帮助文档：\xa0'
            'https://wendux.github.io/dist...如官网所说，Fly.js是一个支持所有JavaScript运行环境的基于Promise、支持请求转发的http请求库，它可最大限度地在多个端上实现代码复用。其拥有的特点：1、提供统一的PromiseAPI2、浏览器环境下非常轻量3、支持多种JavaScript运行环境4、支持请求/响应拦截器5、自动转换JSON数据6、支持切换底层 '
            'HTTP '
            'Engine，可轻松适配各种运行环境7、浏览器端支持全局Ajax拦截8、H5页面内嵌到原生APP时，支持将HTTP请求转发到Native，支持直接请求图片本次搭建的小程序环境，将使用flyio这个http请求库来实现数据的请求，目前用到的方法为get、post。两者的使用示例在官网帮助文档有示例：项目初始化1、搭建mpvue脚手架基于mpvue-quickstart模版创建新项目vue '
            'init mpvue/mpvue-quickstart '
            'one_hour_app2、打开并跑起项目新建的项目打开，dist文件夹尚未存在跑起项目cd one_hour_appnpm '
            'run '
            'dev这样跑起来后项目中便多了一个dist文件夹，里面有个wx文件夹这个wx文件夹就是要导入到微信开发者工具中的文件。安装微信开发者工具，打开微信官网文档页面可下载：\xa0'
            'https://developers.weixin.qq....安装好微信开发者工具后点击导入项目弹窗内输入导入的目录目录就是刚才说的那个在one_hour_app项目中npm '
            'run '
            'dev之后生成的dist下的wx。AppID的获取，需要先在微信公众平台注册，然后打开开发-开发设置找到。导入成功后显示这样这样，就可以在编辑器写我们的代码，然后在微信开发者工具里面可以像浏览器一样查看页面效果。查看项目vue文件可以发现，我们基本上可以像写vue一样写里面的vue文件。之后对项目结构进行删减，把原本提供的那些没用到的文件先删除。保留一个架构。开发主要关注的是src这个目录。statics里面的images、tabs删掉src/main.js保持不变src/App.vue里的代码删掉，剩下src/app.json对应到页面路由pages配置、头部windows的样式和文字设置、脚部tabBar菜单配置，现在只保留如下：src/utils文件先保持不变src/components/card.vue删掉src/pages只留下index那块的内容。接着是删掉index.vue的东西。修整完后，只剩下首页至此，基于mpvue的小程序项目架构已经搭建好了。接着是css扩展语言scss、Vant '
            'Weapp '
            'UI组件库、flyio、mpvue路由插件mpvue-router-patch。1、安装scss，sass-loader的版本是7.3.1，如果使用最新的版本会报错，这里安装这个低版本的。npm '
            'i -D sass-loader node-sass测试下：2、安装Vant Weappnpm i vant-weapp -S '
            '--production打开Vant '
            'Weapp的官网找一个button的例子测试下，但是使用之前需要在app.json文件中配置引入组件。由于把这个组件安装到了node_modules/vant-weapp/dist，所以引入组件的路径跟官网给的不一样，需要手动修改一下路径：同时由于我们需要在微信开发者工具查看，而那里导入了的是dist/wx，跟编辑器里的目录是不一样的，所以为了能在微信开发者工具正常显示组件，还需要做一个配置，将整个node_modules/vant-weapp/dist目录拷贝到dist/wx/vant-weapp/dist目录，在wepack.base.conf.js添加如下配置：if '
            '(/^wx$/.test(PLATFORM)) {\r\n'
            '  baseWebpackConfig = merge(baseWebpackConfig, {\r\n'
            '    plugins: [\r\n'
            '      new CopyWebpackPlugin([{\r\n'
            "        from: resolve('node_modules/vant-weapp/dist'),\r\n"
            "        to: resolve('dist/wx/vant-weapp/dist'),\r\n"
            "        ignore: ['.*']\r\n"
            '      }])\r\n'
            '    ]\r\n'
            '  })\r\n'
            '}使用一个button组件测试下：<van-button '
            'type="primary">主要按钮</van-button>这样组件就成功引入了，而且也可以看到刚才那个拷贝目录的配置也生效了，可以看到vant-weapp目录已在wx里生成。3、安装flyio、mpvue-router-pushnpm '
            'i -S flyio\r\n'
            'npm i -S '
            'mpvue-router-patch现在用不到这个路由插件，先安装着放着。接着是使用flyio来实现小程序授权登录的请求。首先在utils里创建request.js用来封装flyio的请求。// '
            '初始化flyio请求\r\n'
            'function createFly () {\r\n'
            "  if (mpvuePlatform === 'wx') {\r\n"
            "    const Fly = require('flyio/dist/npm/wx')\r\n"
            '    return new Fly()\r\n'
            '  } else {\r\n'
            '    return null\r\n'
            '  }\r\n'
            '}// 处理get请求、post请求，\r\n'
            '//如果是post，就把get改成post就行，这里为了节省篇幅，省去了post的那段代码\r\n'
            'export function get (url, params = {}, showErr = true) {\r\n'
            '  const fly = new createFly()\r\n'
            '  if (fly) {\r\n'
            '    return new Promise((resolve, reject) => {\r\n'
            '      fly.get(url, params).then(response => {\r\n'
            '        const data = (response && response.data) || {}\r\n'
            '        if (data.error_code === 0) {\r\n'
            '          resolve(response)\r\n'
            '          console.log(response)\r\n'
            '        } else {\r\n'
            '          if (showErr) {\r\n'
            '            mpvue.showToast({\r\n'
            "              title: data.msg || '请求失败',\r\n"
            "              icon: 'none',\r\n"
            '              duration: 1500\r\n'
            '            });\r\n'
            '          }\r\n'
            '          reject(response)\r\n'
            '        }\r\n'
            '      }).catch(err => {\r\n'
            '        console.log(err)\r\n'
            '      })\r\n'
            '    })\r\n'
            '  }\r\n'
            '}如果遇到了 TypeError: __webpack_require__(...) is not a '
            'function这样的问题，就关闭微信开发者工具，删除dist包，再重新npm run '
            'dev跑一下，重新打开微信开发者工具应该就没问题了。接下来是用户授权的内容。授权登录首页的展示，需要调用mpvue.getSetting获取用户的当前设置。已授权就展示正常页面，未授权就展示auth.vue授权登录页面。未授权的状态，当用户同意授权使用的时候，这时首页就会变成正常的页面，同时，需要获取用户的信息userInfo。在成功获取了用户信息之后，需要使用存储器mpvue.setStorageSync把它存储起来供之后需要的时候使用getStorageSync来获取。这时会存在两种情况，一种是已存在openId的情况，另一种是还没获取openId的情况。当未取到openId时，需要调用接口获取openId，而调用这个接口需要获得code，这个code可以通过mpvue.login '
            'API获取到。当取得code之后就调用获取openId的接口，返回openId并存储起来。取得openId后，就可以把这个openId作为参数，传给获取首页数据的接口。当已经取得openId时，就直接调用首页接口数据并传openId作为接口的参数。在此之后，需要调用register注册接口，调用这个接口能够把用户的行为数据存储在后台，辨别不同的用户。流程示意图：auth.vue组件主要的按钮事件：<button '
            'class="auth-btn" \r\n'
            '              open-type="getUserInfo"\r\n'
            '              @getuserinfo="getUserInfo">授权登录</button>getUserInfo '
            '() {\r\n'
            "      this.$emit('getUserInfo')\r\n"
            '    }src/api/index.js用来存放接口import { get, post } from '
            '"@/utils/request.js"\r\n'
            "const API_BASE = '后台接口前缀'\r\n"
            '\r\n'
            'export function getOpenId (params) {\r\n'
            '  return get(`${API_BASE}/openId/get`, params)\r\n'
            '}\r\n'
            '\r\n'
            'export function getHomeData (params) {\r\n'
            '  return get(`${API_BASE}/book/home/v2`, params)\r\n'
            '}\r\n'
            '\r\n'
            'export function register (params) {\r\n'
            '  return post(`${API_BASE}/user/register`, params)\r\n'
            '}src/api/wechat.js用来存放微信平台相关的APIimport { getOpenId } from '
            "'@/api'\r\n"
            "const APP_ID = '填写微信公众平台的App_ID'\r\n"
            "const SECRET = '填写微信公众平台的secret'\r\n"
            '\r\n'
            '// 请求getSetting获取用户当前的授权\r\n'
            'export function getSetting (auth, onSuccess, onFail) {\r\n'
            '  mpvue.getSetting({\r\n'
            '    success (res) {\r\n'
            '      if (res.authSetting[`scope.${auth}`]) {\r\n'
            '        onSuccess(res)\r\n'
            '      } else {\r\n'
            '        onFail(res)\r\n'
            '      }\r\n'
            '    },\r\n'
            '    fail (res) {\r\n'
            '      console.log(res)\r\n'
            '    }\r\n'
            '  })\r\n'
            '}// 获取用户信息\r\n'
            'export function getUserInfo (onSuccess, onFail) {\r\n'
            '  mpvue.getUserInfo({\r\n'
            '    success (res) {\r\n'
            '      onSuccess(res)\r\n'
            '      console.log(res)\r\n'
            '    },\r\n'
            '    fail (res) {\r\n'
            '      onFail(res)\r\n'
            '    }\r\n'
            '  })\r\n'
            '}// 获取openId\r\n'
            'export function getUserOpenId (callback) {\r\n'
            '  mpvue.login({   // 调用login API 获得code\r\n'
            '    success (res) {\r\n'
            '      console.log(res)\r\n'
            '      const { code } =  res // 这个code是获取openId的前提\r\n'
            '      getOpenId({ code, appId: APP_ID, secret: SECRET '
            '}).then(response => {\r\n'
            '        const { openid } = response.data.data\r\n'
            "        mpvue.setStorageSync('openId', openid)\r\n"
            '        callback && callback(openid)\r\n'
            '      }).catch(err => {\r\n'
            '        console.log(err)\r\n'
            '      })\r\n'
            '    },\r\n'
            '    fail (res) {\r\n'
            '      console.log(res)\r\n'
            '    }\r\n'
            '  })\r\n'
            '}index.vue页面：<template>\r\n'
            '  <div>\r\n'
            '    <div v-if="isAuth">\r\n'
            '      <div class="index">首页</div>\r\n'
            '      <van-button type="primary">主要按钮</van-button>\r\n'
            '      <div>\r\n'
            '        获取userInfo示例：\r\n'
            '        <div>\r\n'
            '          {{ userInfo.nickName }}\r\n'
            '        </div>\r\n'
            '        获取homeData数据示例：\r\n'
            '        <div>{{ homeData.hotSearch && homeData.hotSearch.num '
            '}}</div>\r\n'
            '      </div>\r\n'
            '    </div>\r\n'
            '    <auth v-if="!isAuth" @getUserInfo="init" />\r\n'
            '  </div>\r\n'
            "</template>import { get, post } from '@/utils/request'\r\n"
            "import Auth from '@/components/base/auth.vue'\r\n"
            "import { getHomeData, register } from '@/api'\r\n"
            'import { getSetting, getUserInfo, getUserOpenId } from '
            "'@/api/wechat'data () {\r\n"
            '    return {\r\n'
            '      isAuth: false,\r\n'
            '      userInfo: {},\r\n'
            '      homeData: {}\r\n'
            '    }\r\n'
            '  },\r\n'
            '  mounted () {\r\n'
            '    this.init()\r\n'
            '  },// 获取首页数据\r\n'
            'getIndexData (openId, userInfo) {\r\n'
            '    getHomeData({ openId }).then(response => {\r\n'
            "        console.log('getHomeData-----', response)\r\n"
            '        this.homeData = response.data.data\r\n'
            '    })\r\n'
            '},// 在获得授权信息后调用以获得用户信息\r\n'
            'getUserInfoData () {\r\n'
            '    const onCompleteGetOpenId = (openId, userInfo) => {\r\n'
            '        this.getIndexData(openId, userInfo)  // 获取首页数据\r\n'
            '        register({ openId, platform: mpvuePlatform, ...userInfo '
            '})  // 注册\r\n'
            '    } \r\n'
            '    getUserInfo( // 获取用户信息\r\n'
            '        (res) => {\r\n'
            '            const { userInfo } = res\r\n'
            '            this.userInfo = userInfo\r\n'
            "            mpvue.getStorageSync('userInfo', userInfo)\r\n"
            "            const openId = mpvue.getStorageSync('openId')\r\n"
            '            if (!openId || openId.length === 0) { // 未存在openId\r\n'
            '                getUserOpenId((openId) => { // 需要请求接口获得\r\n'
            '                    onCompleteGetOpenId(openId, userInfo)\r\n'
            '                })\r\n'
            '            } else {\r\n'
            '                onCompleteGetOpenId(openId, userInfo) // '
            '已存在openId\r\n'
            '            }\r\n'
            '        },\r\n'
            '        (res) => {\r\n'
            '            console.log(res)\r\n'
            '        }\r\n'
            '    )\r\n'
            '}// 一开始就需要获取授权信息，mounted里调用\r\n'
            'init () {\r\n'
            '    getSetting(\r\n'
            "        'userInfo',\r\n"
            '        (res) => {\r\n'
            '            this.isAuth = true\r\n'
            '            console.log(res)\r\n'
            '            this.getUserInfoData()\r\n'
            '        },\r\n'
            '        (res) => {\r\n'
            '            this.isAuth = false\r\n'
            '            console.log(res)\r\n'
            '        }\r\n'
            '    )\r\n'
            '}最后放上授权的过程示意图：',
 'date': '2020-8-4 10:51',
 'title': 'mpvue开发小程序——项目初始化及实现授权登录 '}
****************************************
{'author': 'admin',
 'content': '编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 '
            'userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 '
            '基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength '
            '属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 '
            '即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 '
            'modalHidden2 是模态框开关。另外 proptText '
            '是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 '
            'bindsubmit 事件组件，在 button 组件上添加 formType=”submit” '
            '即可，还有点需注意的是使用表单提交功能时 input 需加上 name '
            '属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 '
            '页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 '
            'wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 '
            '个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug '
            '吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload '
            '时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* '
            'requiredGroupEn 必填英文信息* notRequiredGroupEn '
            '选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no '
            '开头requester.getOfflineCardInfoGroupFields(userId, cardId,function '
            '(res) {//debuggervar userName = res.card.userName;var mobile = '
            'res.card.mobile;var requiredGroup = res.requiredGroupCh;var '
            'notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = '
            'res.requiredGroupEn;var notRequiredGroupEn = '
            'res.notRequiredGroupEn;var reqLen = '
            'requiredGroup.fields.length;var nreqLen = '
            'notRequiredGroup.fields.length;var reqLenEn = '
            'requiredGroupEn.fields.length;var nreqLenEn = '
            'notRequiredGroupEn.fields.length;self.setData({userName: '
            'userName,mobile: mobile,requireFields: '
            'requiredGroup.fields,notRequireFields: '
            'notRequiredGroup.fields,requireFieldsEn: '
            'requiredGroupEn.fields,notRequireFieldsEn: '
            'notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: '
            'reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function '
            '(code, msg) {console.info("code=" + code + "&msg=" + '
            'msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 '
            'A、B、C '
            '定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 '
            'sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 '
            'id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 '
            'ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 '
            '100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id '
            '上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B '
            '同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter '
            '就是 # 底部）。',
 'date': '2016-10-12 22:14',
 'title': '微信小程序开发系列教程第七章：编辑名片页面开发 '}
****************************************
{'author': 'Rolan',
 'content': '1、bindtap和catchtap的区别(1) '
            '相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分。\r\n'
            '(2) '
            '不同点：他们的不同点主要是bindtap是冒泡的，catchtap是非冒泡的。2、例子1、假如有三个view点击事件都是用的bindtap，三个view是层级包含关系?123456789<view '
            'id="outer"\xa0bindtap="out">\xa0\xa0\xa0\xa0outer '
            'view\xa0\xa0\xa0\xa0<view id="middle"\xa0'
            'bindtap="middle">\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0middle '
            'view\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<view id="inner"\xa0'
            'bindtap="inner">\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0'
            'inner view\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0</view>\xa0\xa0\xa0\xa0'
            '</view></view>\u3000\u3000\xa0'
            '2、我么在js里代码是在相对应的事件打印出log，代码如下?out:function(e){\r\n'
            '    console.log("--out bindtap click")\r\n'
            '}, middle: function (e) {\r\n'
            '    console.log("--middle bindtap click")\r\n'
            '}, inner: function (e) {\r\n'
            '    console.log("--inner bindtap click")\r\n'
            '}\xa03、bindtap执行结果点击out view打印出一条log --> out bindtap click\r\n'
            '\r\n'
            '点击middle view打印出两条log --> middle bindtap click--out bindtap '
            'click\r\n'
            '\r\n'
            '点击innew view打印出三条log --> inner bindtap click--middle bindtap '
            'click--out bindtap click\r\n'
            '\r\n'
            '可以看出bindtap不阻止向上冒泡，所以点击inner一直冒泡到了最外层。\xa04、如果我们只修改middle '
            'view的bindtap为catchtap点击out view打印出一条log --> out bindtap '
            'click（因为没有上层元素故而无法向上冒泡）\r\n'
            '\r\n'
            '点击middle view打印出一条log --> middle bindtap click（catchtap阻止向上冒泡）\r\n'
            '\r\n'
            '点击innew view打印出两条log --> inner bindtap '
            'click（catchtap阻止向上冒泡）本博客主要记录自己的学习点滴~，文章来源于总结，还有在工作中实际碰到的问题以记录。',
 'date': '2020-5-26 00:22',
 'title': '微信小程序bindtap与catchtap的区别 '}
****************************************
{'author': 'Rolan',
 'content': '一、需求说明\r\n'
            '\r\n'
            '可选取相册照片，可拍照\r\n'
            '可选择压缩大小，可选择原图大小\r\n'
            '每次最多可选择 5 张图片\r\n'
            '\r\n'
            '二、需求实现\r\n'
            '2.1 选取照片实现\r\n'
            '通过调用小程序 api - chooseImage 来实现选取照片功能\r\n'
            '// 定义一个变量，用来存储用户选取的图片路径\r\n'
            'let imagePaths\r\n'
            'wx.chooseImage({\r\n'
            '  count: 5,    // 限制每次最多选择 5 张\r\n'
            "  sizeType: ['original', 'compressed'],  // 可选择压缩大小，可选择原图大小\r\n"
            "  sourceType: ['album', 'camera'],   // 可选取相册照片，可拍照\r\n"
            '  success: res => {   // 选取图片成功的回调函数\r\n'
            '    imagePaths = res.tempFilePaths   // 存储选取的图片路径，是个数组\r\n'
            '  }\r\n'
            '})\r\n'
            '复制代码2.2 上传照片实现\r\n'
            '// 定义一个变量，用来存储上传成功的图片路径\r\n'
            'let successPaths = []\r\n'
            '// wx.uploadFile 接口只能一次上传 1 张图片，所以需要先遍历\r\n'
            'imagePaths.forEach((path) => {\r\n'
            '  wx.uploadFile({\r\n'
            "    url: api.apiRootUrl + '/distribution/addPicture',   // "
            '接口地址\r\n'
            '    filePath: path,\t// 当前图片路径\r\n'
            "    name: 'file',\r\n"
            '    header: { "Content-Type": "multipart/form-data" }, \r\n'
            '    success: res => {\t\t\t\t\t// 上传成功的回调函数\r\n'
            '      if (res.code == 200) {\r\n'
            '        successPaths.push(res.filePath)\r\n'
            '      } else {\r\n'
            '        this.showToast({\r\n'
            '\t\t\ttitle: res.msg\r\n'
            '\t\t  })\r\n'
            '      }\r\n'
            '      let filePaths = `formData.filePaths`\r\n'
            '\t\t// 存储上传成功的图片路径\r\n'
            '      this.setData({\r\n'
            '        [filePaths]: successPaths\r\n'
            '      })\r\n'
            '    }\r\n'
            '  })\r\n'
            '})\r\n'
            '复制代码2.3 图片预览实现\r\n'
            '<view wx:for="{{formData.filePaths}}" wx:key="filePath">\r\n'
            '\t<image src="{{filePath}}"></image>\r\n'
            '</view>\r\n'
            '复制代码',
 'date': '2020-6-2 00:53',
 'title': '小程序实战(二)-上传多图功能 '}
****************************************
{'author': 'Rolan',
 'content': '对于小程序开发者和测试同学来说，很多临时性的调试功能需要单独开发去支持，比如查看小程序信息，手机信息以及用户信息，扫码打开页面等。这些功能对于每个小程序都是相似的，而且遇到类似的需求时都需要进行单独开发。DoKit在移动端发展，获得了众多开发者的好评，其中不乏很多一线大厂(阿里，字节，腾讯，百度...)的身影，同时给我们带来了很多宝贵的经验。在广大开发者的要求下，我们重新启动了小程序端sdk的升级.此次版本升级主要提供了数据模拟功能，优化接入流程，降低用户接入成本，更好配合使用原生小程序以及第三方框架开发，提升开发同学的幸福感。简单总结DoKit小程序端调试工具，内置很多常用的工具，避免重复实现，一次接入，你将会拥有强大的工具集合。新增功能演示哆啦A梦小程序端apimock功能演示在我们的\xa0'
            '平台端\xa0'
            '注册，即可使用该功能，在sdk接入部分会有详细介绍。点击工具中的数据模拟即可进入详情页，其中详情页分为mock数据和上传模板两块功能。mock数据:你可以通过打开指定接口的开关并选择相应的场景,此时你无需改变你的网络请求代码即可对你的指定接口进行拦截并返回你在平台创建的接口数据。上传模板:上传模板功能的适用场景是当你已经有了一个真实的接口，需要针对不同的用户场景进行测试但是同时接口返回的数据量比较庞大，所以我们为你提供了上传模板的功能。当你打开上传模板中指定接口的开关时，我们会拦截并保存你真实接口返回的数据并提供json预览功能。点击上传即可上传你的模板数据到Dokit平台端。原理流程图如下:使用Object.defineProperty()劫持小程序的wx.request(),然后重写次方法，添加上匹配拦截逻辑和上传模板逻辑。在平台端更新接口时，会和小程序本地数据合并，即还原原先在本地操作的记录其他功能app信息用于快速查看手机系统信息，小程序基本信息，用户信息，授权信息等基础信息，避免反复打开手机设置或者调用小程序原生api进行查看。位置模拟用于小程序端位置模拟，包括位置授权，位置查看，位置模拟，恢复位置设置等几大功能，可以通过简单的点击操作实现任意位置模拟和位置还原，该功能的实现原理是通过对wx.getLocation进行方法重写，进而进行位置模拟，位置模拟后，在小程序内所有调用位置查询的方法内都将返回你设定的位置，还原后将恢复原生方法缓存管理一个强大的缓存管理面板，集成了对缓存的所有操作功能，包括设置缓存，清除缓存，更新缓存值等，可以在小程序非常便利的进行缓存管理H5任意门可以通过扫码和粘贴链接的方式在小程序中打开h5页面，操作简单方便更新版本当你的小程序进行代码更新时，为了获取最新的线上包需要重启小程序，该功能可以在你的小程序上通过点击更新操作，直接获取到最新的远程代码资源快速上手如何接入如果您是使用原生小程序的开发方式，请安如下方式接入1. '
            '通过npm安装 npm install dokit-miniapp, '
            '然后从node_modules中将dokit-miniapp文件夹拷贝到自己的项目中，然后按如下方式进行使用\r\n'
            '复制代码2. 在需要引用工具的页面 page.json 中引入组件(注意引用的路径)\r\n'
            '复制代码"usingComponents": {\r\n'
            '  "dokit": "../../components/dokit-miniapp/dist/index/index"\r\n'
            '}\r\n'
            '复制代码3. 在需要引用工具的页面 page.wxml 中引入使用组件\r\n'
            '<dokit projectId="your projectId"></dokit>\r\n'
            '复制代码如果您是使用小程序第三方框架的开发方式，可以做如下优化，在所需引入页面的js中，添加变量声明，例如\r\n'
            'const isProd = process.env.NODE_ENV === \'"production"\'\r\n'
            '复制代码在<template></template>或者是render函数中，可以使用\r\n'
            '\r\n'
            'isProd ? \'\' : <dokit projectId="your projectId"></dokit>\r\n'
            '复制代码如果框架暴露了webpack的相关打包配置，可以按照这样的配置，优化资源打包\r\n'
            'compile: {\r\n'
            '      exclude: [\r\n'
            "        path.resolve(__dirname, '..', "
            "'src/components/dokit-miniapp')\r\n"
            '      ]\r\n'
            '    }\r\n'
            '复制代码Tip: 1.由于微信小程序暂不支持开发环境和生产环境判断，请在生产环境手动删掉引用Tip: '
            '2.第三方框架开始，要注意框架是否将process.env.NODE_ENV注入到的全局变量中，此外有的框架的兼容性并不友好，有些打包配置并没有支持，开发者要视情况而定。',
 'date': '2020-6-10 00:11',
 'title': 'DoKit微信小程序研发助手SDK升级 '}
****************************************
{'author': 'Rolan',
 'content': '提醒：canvas画布绘画图片的时候，图片不能是互联网图片，必须是本地图片才可以正常绘制。\r\n'
            '第一步：获取用户授权，下载微信头像图片到本地。pleaseSign: function(event) {    '
            'wx.getSetting({\r\n'
            '      success(res) {\r\n'
            "        if (res.authSetting['scope.userInfo']) {\r\n"
            '          // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n'
            '          wx.getUserInfo({\r\n'
            '            success: function(res) {\r\n'
            '              let userInfo = res.userInfo;\r\n'
            '              let userImage = userInfo.avatarUrl;\r\n'
            '              wx.downloadFile({\r\n'
            '                url: userImage,\r\n'
            '                success(wr) {\r\n'
            '                  let userName = userInfo.nickName;\r\n'
            '                  app.gData.userName = userName;\r\n'
            '                  app.gData.userImage = wr.tempFilePath;\r\n'
            '                  wx.navigateTo({\r\n'
            "                    url: '../sign/sign'\r\n"
            '                  });\r\n'
            '                }\r\n'
            '              });\r\n'
            '            }\r\n'
            '          });\r\n'
            '        }\r\n'
            '      }\r\n'
            '    });\r\n'
            '  }\r\n'
            '\r\n'
            '获取用户头像信息之后，跳转到绘制页面，在绘制页面完成绘画操作。\r\n'
            '第二步：绘制用户头像。finish: function() {    const ctx = '
            "wx.createCanvasContext('shareCanvas');\r\n"
            '    let that = this;\r\n'
            '    ctx.drawImage(app.gData.BG, 0, 0, 600, 1066);\r\n'
            '    ctx.stroke();\r\n'
            '\r\n'
            '    ctx.save();\r\n'
            '    // 绘制第一个圆 \r\n'
            '    ctx.beginPath();\r\n'
            '    //圆心x、y的坐标，半径，起始角，结束角，顺时针画\r\n'
            '    ctx.arc(30 + that.data.xp - 70, 30 + that.data.yp - 30, 30, '
            '0, Math.PI * 2, false);\r\n'
            '    //将圆形剪切\r\n'
            '    ctx.clip();\r\n'
            '    //再画一个不存在的圆，避免画出来的微信头像有个黑圆圈\r\n'
            '    ctx.beginPath();\r\n'
            '    ctx.arc(0, 0, 0, 0, Math.PI * 2, false);\r\n'
            '    ctx.drawImage(app.gData.userImage, that.data.xp - 70, '
            'that.data.yp - 30, 60, 60);\r\n'
            '    ctx.stroke();\r\n'
            '    ctx.restore();\r\n'
            '\r\n'
            "    ctx.setTextAlign('left');\r\n"
            "    ctx.font = 'bold 25px 楷体';\r\n"
            '    ctx.setFillStyle(app.gData.fontColor);\r\n'
            '    ctx.fillText(app.gData.userName, that.data.xp, that.data.yp + '
            '10);\r\n'
            '    ctx.stroke();\r\n'
            '    ctx.draw(false, function () {\r\n'
            '      wx.canvasToTempFilePath({\r\n'
            '        x: 0,\r\n'
            '        y: 0,\r\n'
            '        width: 600,\r\n'
            '        height: 1066,\r\n'
            '        destWidth: 600,\r\n'
            '        destHeight: 1066,\r\n'
            "        canvasId: 'shareCanvas',\r\n"
            '        success: function (res) {\r\n'
            '          // 获得图片临时路径\r\n'
            '          app.gData.temp = res.tempFilePath;\r\n'
            '          app.gData.change = true;\r\n'
            '          wx.navigateBack();\r\n'
            '        }\r\n'
            '      });\r\n'
            '    });\r\n'
            '    \r\n'
            '  }\r\n'
            '\r\n'
            '注意：在绘制用户头像之前一定要调用save方法，绘制以后调用restore方法，否则你的绘制除了头像会成功画出来，其它绘画图片或者文字会出不来。',
 'date': '2020-6-16 00:52',
 'title': '小程序canvas绘制圆形微信头像 '}
****************************************
{'author': 'Rolan',
 'content': '前一段时间写了一个微信小程序的项目，其中就有引导页面这一功能模块，接下来给大家说一下这一块的怎么实现的以及一个思路吧！一、引导页下给大家康康效果图是啥样舍的呢！！其实就是和轮播图差不多，就是当用户滑动到最后一页的时候显示跳转页面就完事了。二、代码分析第一步：先找到小程序目录下面的app.json然后在“pages”配置好页面{\r\n'
            '\t"pages": [\r\n'
            '\t\t"pages/guidance/guidance", // 配置引导页面\r\n'
            '\t\t"pages/index/index",  // 这是跳转以后的Home页面\r\n'
            '\t],\r\n'
            '}这是在小程序的pages的目录里面就得到了第二步：接下来在guidance.json里面进行小程序页面header的配置{\r\n'
            ' "usingComponents": {},\r\n'
            ' "navigationStyle": "custom"\r\n'
            '}注释一下：Navigation是小程序的顶部导航组件，当页面配置navigationStyle设置为custom的时候可以使用此组件替代原生导航栏。第三步： '
            '在guidance.wxml里面写代码 在这里我就把轮播也给大家分享一下<swiper class="banner_box" '
            'bindchange="fike" indicator-dots="{{true}}" '
            "indicator-active-color='#fff'>\r\n"
            '\r\n'
            ' <swiper-item class="img_b" wx:for="{{ banners }}" '
            'wx:key="id">\r\n'
            '\r\n'
            '  <image class="img_log" src="{{item.picUrl}}"></image>\r\n'
            '\r\n'
            ' </swiper-item>\r\n'
            '\r\n'
            '</swiper>\r\n'
            '<!-- button按钮 -->\r\n'
            '<view class="skip" bindtap="skip">\r\n'
            '\t<!-- 可以更据guidance.js 下标判断到最后一页显示button按钮点击跳转 -->\r\n'
            '\t<button bindtap="getIndex" wx:if="{{ swiperCurrent+1 == '
            'swiperMaxNumber }}">跳过</button>\r\n'
            '\r\n'
            '</view>注释：swiper：1、在小程序中只能当作滑块视图容器。2、其中只可放置swiper-item组件，否则会导致未定义的行为。bindchange：current '
            '改变时会触发 change 事件，event.detail = {current, '
            "source}indicator-dots：是否显示面板指示点indicator-active-color='#fff'：当前选中的指示点颜色swiper-item：仅可放置在swiper组件中，宽高自动设置为100%。属性类型默认值必填说明item-idstring否该 "
            'swiper-item 的标识符微信官方文档链接：\xa0'
            'https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html第四步:是不是改写样式了.banner_box '
            '{\r\n'
            '\twidth: 100%;\r\n'
            '\theight: 100vh;\r\n'
            '\tposition: relative;\r\n'
            '}\r\n'
            '.img_b,.img_log {\r\n'
            '\twidth: 100%;\r\n'
            '\theight: 100%;\r\n'
            '}\r\n'
            '.skip{\r\n'
            '\tposition: absolute;\r\n'
            '\tleft: 0;\r\n'
            '\tright: 0;\r\n'
            '\tbottom: 86rpx;\r\n'
            '}\r\n'
            'button {\r\n'
            '\twidth: 185rpx;\r\n'
            '\theight: 67rpx;\r\n'
            '\tfont-size: 28rpx;\r\n'
            '\tline-height: 67rpx;\r\n'
            '\tbackground-color: #32CD32;\r\n'
            '\tcolor: #fff;\r\n'
            '}第五步： js逻辑操作// 这里是我当时引入的封装好的接口\r\n'
            "const wxapi = require('../../api/urls.js');\r\n"
            '\r\n'
            '// pages/guidance/guidance.js\r\n'
            'Page({\r\n'
            '\t/**\r\n'
            '\t * 页面的初始数据\r\n'
            '\t */\r\n'
            '\tdata: {\r\n'
            '\t\tbanners:[], // 轮播\r\n'
            '\t\tswiperCurrent: 0, // 引导页的下标 0\r\n'
            '\t\tswiperMaxNumber: 3 // 引导页的下标 3\r\n'
            '\t},\r\n'
            '\tfike(e) {\r\n'
            '\t\tthis.setData({\r\n'
            '\t\t\tswiperCurrent: e.detail.current\r\n'
            '\t\t});\r\n'
            '\t},\r\n'
            '\t/**\r\n'
            '\t * 生命周期函数--监听页面加载\r\n'
            '\t */\r\n'
            '\tonLoad: function (options) {\r\n'
            '\t\tvar arr = [];\r\n'
            '// 在这里进行数据请求\r\n'
            '\t\twxapi.banners().then( res => {\r\n'
            '\t\t\tres = res.data;\r\n'
            '\t\t\tres.forEach(item =>{\r\n'
            "\t\t\t\tif (item.type == 'app') {\r\n"
            '\t\t\t\t\tarr.push(item)\r\n'
            '\t\t\t\t}\r\n'
            '\t\t\t});\r\n'
            '\t\t\t// 把数据更新到页面上\r\n'
            '\t\t\tthis.setData({\r\n'
            '\t\t\t\tbanners:arr\r\n'
            '\r\n'
            '\t\t\t})\r\n'
            '\t\t})\r\n'
            '\t},\r\n'
            '\tgetIndex() {\r\n'
            '\t// wx.switchTab():跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面，\r\n'
            '\t//这里的tabBar是底下的导航栏指定的页面，\r\n'
            '\t\twx.switchTab({\r\n'
            '\t\t\turl:"/pages/index/index"\r\n'
            '\t\t})\r\n'
            '\t},\r\n'
            '})accomplish到此这篇关于微信小程序的引导页实现代码的文章就介绍到这了,更多相关微信小程序的引导页内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！',
 'date': '2020-6-25 00:19',
 'title': '微信小程序的引导页实现代码 '}
****************************************
{'author': 'Rolan',
 'content': '一、使用API wx.chooseImage(OBJECT)var util = '
            "require('../../utils/util.js')\r\n"
            'Page({\r\n'
            '  data:{\r\n'
            '    src:"../image/pic4.jpg"\r\n'
            '  },\r\n'
            '  gotoShow: function(){var _this = this\r\n'
            '    wx.chooseImage({\r\n'
            '     count: 9, // 最多可以选择的图片张数，默认9\r\n'
            "     sizeType: ['original', 'compressed'], // original "
            '原图，compressed 压缩图，默认二者都有\r\n'
            "     sourceType: ['album', 'camera'], // album 从相册选图，camera "
            '使用相机，默认二者都有\r\n'
            '     success: function(res){\r\n'
            '      // success\r\n'
            '      console.log(res)\r\n'
            '      _this.setData({\r\n'
            '        src:res.tempFilePaths\r\n'
            '      })\r\n'
            '     },\r\n'
            '     fail: function() {\r\n'
            '      // fail\r\n'
            '     },\r\n'
            '     complete: function() {\r\n'
            '      // complete\r\n'
            '     }\r\n'
            '    })\r\n'
            '  }\r\n'
            '二、图片路径进行数据绑定<view class="container">\r\n'
            ' <view>\r\n'
            '  <button type="default" bindtap="gotoShow" >点击上传照片</button>\r\n'
            ' </view>\r\n'
            ' <view>\r\n'
            '  <image class= "show-image" mode="aspectFitf" '
            'src="{{src}}"></image>\r\n'
            ' </view>\r\n'
            '</view>\r\n'
            '号外：\u3000\u30001、wx.chooseImage 调用相机或相册\u3000\u30002、<image '
            'class= "show-image" mode="aspectFitf" src="{{src}}"></image> '
            '数据绑定\u3000\u30003、js中动态修改文件路径 var _this = this\r\n'
            '    wx.chooseImage({\r\n'
            '     count: 9, // 最多可以选择的图片张数，默认9\r\n'
            "     sizeType: ['original', 'compressed'], // original "
            '原图，compressed 压缩图，默认二者都有\r\n'
            "     sourceType: ['album', 'camera'], // album 从相册选图，camera "
            '使用相机，默认二者都有\r\n'
            '     success: function(res){\r\n'
            '      // success\r\n'
            '      console.log(res)\r\n'
            '      _this.setData({\r\n'
            '        src:res.tempFilePaths\r\n'
            '      })\r\n'
            '     },\r\n'
            '     fail: function() {\r\n'
            '      // fail\r\n'
            '     },\r\n'
            '     complete: function() {\r\n'
            '      // complete\r\n'
            '     }\r\n'
            '感谢阅读，希望能帮助到大家，谢谢大家对本站的支持！',
 'date': '2020-6-30 00:57',
 'title': '微信小程序 chooseImage选择图片或者拍照 '}