{"title": "微信小程序开发着工具获取和更新newticket ", "author": "Rolan", "date": "2020-8-11 15:03", "content": "newticket是微信开发者工具和微信后台交互的凭证。大多数工具的操作都是需要newticket。如何获取newticket?打开开发者工具，依次点击菜单设置->通用设置->代理，使用代理监听接口请求。（这里使用fiddler代理）点击头像，选择切换登录，使用开发者的微信扫码登录。 PS：获取到的凭证是有时效的，重新登录凭证会失效，建议不要使用自己的开发账号登录。代理工具查看https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/qrcode接口，选择查看响应的头部，得到newticket如何更新newticket?因为newticket是有时效性的，在过期后需要更新newticket后才能正常使用。而更新newticket需要开发者工具的signature和openid，这两个参数的值可以从上一步的请求中找到。 PS：这两个参数的值在重新登录前是固定不变的，需要存储起来更新备用通过接口更新newticket，需要注意的是返回的newticket是存放在header里面。const request = require(\"request\");\r\nexports.getNewTick = ({signature,openid})=>{\r\n    return new Promise((resolve, reject) => {\r\n        request({\r\n            url:\"https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/refreshticket?os=win&clientversion=1032006090\",\r\n            method:\"POST\",\r\n            body:JSON.stringify({signature,openid})\r\n        },(error, response, body) => {\r\n            const newTicket = response.headers['debugger-newticket'];\r\n            if (error) {\r\n              reject(error);\r\n              return;\r\n            }\r\n            if(response.statusCode != 200){\r\n                reject({statusCode:response.statusCode})\r\n                return;\r\n            }\r\n            try{\r\n              const result = JSON.parse(body)\r\n              result.newTicket = newTicket;\r\n              resolve(result);\r\n            }catch{\r\n              resolve({code:-1});\r\n            }\r\n          })\r\n    })\r\n}\r\n最后，获取这个newticket只是开始，后面我会更新如何使用newticket上传代码，获取预览的二维码。"}
{"title": "微信小程序：授权登录 + 基于token的身份验证详解 ", "author": "Rolan", "date": "2020-8-10 14:31", "content": "微信小程序开发很重要的一步就是微信授权登录与服务器用户信息保存，很多同学并不了解流程，下面我为大家讲解一下最简单的登录流程。微信小程序授权、服务器保存信息到数据库通过 wx.login() 获取到用户登录态之后，需要维护登录态。开发者要注意不应该直接把 session_key、openid 等字段作为用户的标识或者 session 的标识，而应该自己派发一个 session 登录状态 （请参考登录时序图）。对于开发者自己生成的 session，应该保证其安全性且不应该设置较长的过期时间。session 派发到小程序客户端之后，可将其存储在 storage ，用于后续通信使用。微信小程序授权登录与用户信息保存流程图里其实说的很清楚了，清理下流程：1.前端调用wx.login()获取code值2.前端通过调用wx.getUserInfo获取iv、rawData、signature、encryptedData等加密数据，传递给后端3.服务器通过code请求api换回session_key和openid4.服务器通过前端给的rawData 加获取的session_key使用sha1加密，计算出signature15.比对前端传的signature和自己算出来的signature1是否一致（防止数据不一致）6.用AES算法解密encryptedData里的敏感数据7.拿着敏感数据后做自己的逻辑8.通知前端登陆成功这里只是想拿到用户的openid，则直接1,3就可以做到了。1第一步：通过wx.login（微信前端--小程序）接口获取code，将code传到后台注意：code的来源：是用户打开小程序的时候，随机生成的，是腾讯生成的，每个code只能使用一次，因此，理论上这个code是安全的2第二步：后台通过code访问微信（腾讯）接口，微信（腾讯）接口返回当前登录的信息：session_key及openid。返回的openid是每个用户唯一的，通过这个 可以匹配 微信（腾讯）的用户 跟 我们的用户，就是我们后台通过openid来判断这个人是谁，UserController.java    微信小程序登录其中：就是下面的第三步//调用service.weChatLogin(model)WeChatLoginResult<UserAccount> loginResult = service.weChatLogin(model);3第三步：后台检查openid是否存在，去UserService.java去数据库中检查openid是否存在：UserAccountMapper.java如果不存在：就是该用户的第一次登录，后台数据库新添加一个用户信息 如果存在：就不是该用户的第一次登录，以前登陆过，就更新后台数据库中该用户的第一次登录时间返回用户信息4第四步：下发token其中生成token的步骤：BaseController.java 利用JWT框架生成token至此，再理一下上面的步骤：微信小程序通过访问wx.login获得一个code，返回给后台后台拿着这个code，调用腾讯的接口，获取到openid、seesion-key等信息，openid是用户唯一的后台拿着openid去数据库中检查，该用户是否是第一次登陆。如果是第一次登陆，那么就新建一个用户--UserAcount；如果不是第一次登陆，就修改该用户的最后登录时间不管是不是第一次登录，都有了一个用户然后根据用户的信息利用JWT生成token，下发给微信小程序5第五步微信小程序收到token后，存起来6第六步微信小程序请求后台微信小程序把token放在请求头中7第七步先介绍一个注解：Authorize说明：如果有这个注解，就需要验证token用拦截器，验证token流程：1、从http请求头中取出tokenString token = httpServletRequest.getHeader(\"authorization\");2、如果没有token，抛出异常，请用户登录。如果有token，利用JWT从token中取出userid，添加到request参数3、根据userid去后台数据库中查询用户是否存在，如果不存在，抛出异常：用户不存在，请重新登录User user = userService.getUserById(userId);这个方法：4、如果用户存在，再利用JWT从token中取出seesion-key，添加到request参数Stringsession_key=JWT.decode(token).getClaim(\"session_key\").as(String.class);拦截器介绍一下：preHandle：在业务处理器处理请求之前被调用。预处理，可以进行编码、安全控制、权限校验等处理；postHandle：在业务处理器处理请求执行完成后，生成视图之前执行。后处理（调用了Service并返回ModelAndView，但未进行页面渲染），有机会修改ModelAndView；afterCompletion：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；8第八步：request里面有userid，后台就可以识别是对哪个用户做处理总结微信小程序授权登录和信息保存，看起来是有点麻烦 ，但是这个流程是很清晰的 ，大家只要理解了逻辑控制流程 ，就能很好的完成开发。"}
{"title": "2020了，各家小程序发展的怎么样？ ", "author": "Rolan", "date": "2020-8-11 10:32", "content": "本文首发于DCloud公众号2017年，微信发布小程序，掀起小程序大战。2018年，阿里、百度、字节跳动、手机厂商等各大巨头纷纷发布自己的小程序。2019年，QQ也加入战局，各家全面开花。时至2020年，各家小程序发展的到底怎么样？我们根据数据和访谈，形成了这份报告，希望能给开发者带来指引帮助。作为开发者，我们关心的问题，说白了就2个：各家有多大量？各家流量质量怎么样？一、各家小程序流量到底有多大小程序还有流量红利吗？微信的红利是不是已经过去了？不少人存有这种疑问。如果以2018年微信小程序的火爆对比，那么2019年的微信确实没有那么大的红利了。随着用户对群里的小程序由新鲜转向反感，以及微信的严格封杀策略，很多开发者开始抱怨在微信平台裂变不起来了。当然微信小程序平台自身的流量仍在增长，只是增长主要来自于品牌主，比如自带流量的政府、商户，而不是独立开发商了。压下葫芦起了瓢，其他小程序平台给开发者提供了更大的爆发机会。我们来看看各家的流量天花板，也就是小程序宿主应用的月活，微信月活10亿、字节跳动（抖音+今日头条+西瓜+火山）月活10亿、QQ和支付宝月活都是6亿、百度App月活也有4亿。但各家的小程序月活并不是这个顺序，因为： 小程序的月活 = 宿主月使用时长 * 小程序使用频次各家小程序的宿主和小程序流量数据平台宿主月活小程序月活微信10亿日活3亿，未公布月活支付宝6亿+5亿百度4亿+3亿字节跳动10亿+3亿QQ6亿+未公布平台宿主月活里，百度最低，只有4亿。这让人一度担心百度小程序能不能起来。从最终结果来看，百度小程序的月活并不低。因为它的“小程序使用频次”高。用户使用百度App的主需求，就是为了查信息。而百度的百科、贴吧、知道等业务已经全部转为了小程序。其他平台，都有自己的核心功能，小程序属于外延生态。宿主月活虽高，但其中使用小程序的人未必很多。当然支付宝有个例外，很多人打开支付宝，就是为了用蚂蚁森林小程序，而不是为了用支付宝支付，出现了神奇的反客为主效应。。。在近期，有3个平台的小程序表现尤为抢眼，分别是字节跳动、微信、支付宝。字节跳动的App群，从春节开始，流量暴增，然后一直维持在高位。这是一个令人佩服的成绩，在这段时间，字节跳动给小游戏分发了大量流量，宅家的人们一边消费着可观的短视频流量，一边玩小游戏消遣时间。在春节后，各地防疫战打响，每个城市都开始上线抗疫相关的项目，健康登记、出入管理、口罩预约、实名乘车......引发了一大波新应用热潮。这些小程序仅承载在微信和支付宝的平台上。其他小程序平台没有抓到这拨红利。倒不是因为微信或支付宝的给量能力强，流量来自于政府和商户。而他们之所以选择微信和支付宝平台，完全是因为民众对于扫码的使用习惯依赖。人们看到一个码，不是用微信扫，就是用支付宝扫。其他小程序平台还没有给民众培养出扫码的使用习惯。支付宝小程序，从1月起原本是大幅下滑的状态，线下商户陆续放假，严重依赖线下渠道的支付宝小程序受到很大影响。直到现在，随着线下商户复工才有了起色。所幸健康码挽救了支付宝小程序的日活。不过老实讲，健康码对于微信和阿里的商业价值都不大，也只能当做培养用户使用习惯和拉近政府关系了。支付宝小程序不擅长线上分发应用流量，线下商户连接价值才是支付宝小程序的核心，赋能商户、提升交易，是它的真正使命。值得支付宝警惕的是，一些餐饮行业的开发者，使用uni-app多端框架开发应用后，明明可以发布为支付宝小程序，却仅仅发布了H5端，让顾客在线下使用支付宝扫码后打开H5页面。根据DCloud的访谈，这些开发者认为支付宝里扫码打开小程序，并不会比打开H5页强多少，而且小程序审核麻烦，导致很多支付宝小程序的流量跑到了支付宝内置浏览器里了。这需要支付宝改进策略，为小程序开发者提供更多的吸引力，同时减少开发者的麻烦。百度小程序，恰恰是支付宝小程序的对立面，它是纯纯的线上流量。对于很多中小开发者，从百度获取流量，比任何其他平台都容易。做好seo、甚至付费买点流量，总会让你有用户的。不少中小开发者反馈，提交到多个平台小程序，发现百度的流量是大于其他家的。尤其是内容类小程序。在春节和疫情期间，百度小程序的流量有所下滑，近期随着复工复产，又开始快速增长。各家巨头，除了利用自己的主App的体量，也在通过搞联盟来扩大流量池。百度和阿里，都计划通过联合多个头部App组成流量联盟，来帮助开发者获取更大流量。但从目前运行的情况看，这类计划的效果不太明显。阿里小程序和百度小程序的流量，基本都集中在支付宝和百度App上。不管是开发者还是用户，都还没有对流量联盟的其他小程序形成大范围认知和使用习惯。阿里系小程序里，值得期待的新兵是淘宝小程序。近期淘宝小程序已经开始崭露头角，相信随着产品和运营的完善，淘宝小程序会开辟一片新蓝海，因为赋能卖家，确实是一个大市场。QQ小程序发布较晚，它没有采取同为后来者的字节跳动小程序那般中心化疯狂配量模型，目前处于稳定增长中，但整体体量暂时和其他几家还不在一个量级。再分享一个数据：各个平台的应用数量。除了月活流量外，我们还应该关注一个指标，是应用数量。uni-app的开发者发布到各个平台的“应用数量”，看下图：虽然使用uni-app框架可以发布到所有小程序平台，但大多数开发者不会全平台提交应用。上面的饼图有2种解读：微信小程序的应用数量远远超过其他平台，是绝对数量级的差距。说明它已经成为一种生活方式而不只是一个流量平台。微信小程序非常拥挤，大量开发者聚集在微信平台，但得不到足够的流量百度和字节跳动，应用数量少，但小程序月活体量却非常大，有更多红利机会。如果你是一个自带流量的品牌主，比如政府单位，那微信小程序是很好的选择。如果你是一个独立开发者，现在在微信里获取流量其实已经很难了，不妨试试其他平台。与微信、支付宝的给量逻辑不同，百度和字节跳动是卖流量的。在微信里获客，一般是给用户利益，比如拼团砍价；在百度、字节跳动里获客，是给平台利益，花钱投放立即带来用户。从难度来讲，在微信里已经变得很难，而在百度和字节跳动则很简单。百度里小程序的权重高于H5，投资到百度小程序上比投放H5页面更有性价比。至于字节跳动，不得不佩服它家的流量实在太大了，大到什么地步呢？这么说吧，只要肯投钱，快速获取上千万用户很easy。当然，不花钱投放，一样可以得到流量，那对应的要求就是你的内容过硬。以DCloud的开发者社区App为例，每天在百度小程序上得到的流量是最大的。很多用户在百度上搜索技术问题，被导流到DCloud社区的百度小程序中，拉新效果远优于其他小程序、App和H5。在2020年，手机厂商的快应用也出现了更积极的变化。过去快应用的数量很少，不过几千款，与微信的百万级应用数差距很大。最近快应用在原生渲染引擎之外，推出了兼容小程序架构的新应用引擎。对快应用平台而言，新策略有助于增加快应用的开发者数量。对开发者而言，这或许是拿到一个巨大流量的新机会。uni-app在第一时间也跟踪了快应用的新引擎适配，欢迎开发者关注。二、各家小程序平台的流量质量怎么样？有量，还不够。开发者还关心流量质量。流量质量怎么看？我们来看这两个指标：1、单用户页面访问数量；2、次日留存大家都知道，小程序的流量质量，比App要差。但具体差多少呢？我们把App的数据请出来，一起比一下。不同平台用户访问应用的页面数量可以看到，App的一个日活用户，平均访问49个页面，远超小程序。虽然小程序的拉新能力甩开App几条街，但深度用户，还是更喜欢用App。在各家小程序里，微信小程序的表现最接近App，领先其他小程序不少。从这个数据可以明显看出，用户对在支付宝、百度、字节跳动的App中重度使用小程序的习惯没有养成。基于这个现状，开发者若在百度、字节跳动平台推广小程序，需要注意缩短流程，在尽可能短的页面完成自己的业务。比如获取注册表单、获取商机线索、直购低价商品等。而另一方面，也需要微信以外的其他小程序运营平台，努力学习微信，改进运营策略。尤其是百度、字节跳动和QQ小程序，还比较重视应用内广告的收益，如果页面访问次数上不去，广告位的曝光量就上不去，导致美梦落空。我们再来看第二个指标：次日留存。各平台次日留存表首先，所有小程序的留存，都比App差不少。然后看各家小程序。微信小程序，在众多小程序里，留存遥遥领先，平均次日留存超过了10%。其他小程序的平均次日留存，都在5%以下。为什么会有这么大差距。从留存入口来看，微信的下拉二楼、发现选项卡的小程序栏目，已经成功的培养起了用户的使用习惯。用户第一次不管从哪里得到一个小程序，第二次还可以比较顺畅的找到它，从而形成留存。但其他平台在这方面做得不好。百度App的二楼，经常和信息流刷新冲突。支付宝的二次使用入口，打开很慢，远不及微信的体验。字节跳动、QQ的二次使用入口则非常深。当然，这里还有另一个关键问题，对于非微信的其他小程序平台，它们还有一个尴尬，二次使用的入口，到底做的多方便为好？字节跳动和百度，都是卖流量为生的公司。开发商投放了搜索关键字或信息流广告，如果后续用户可以方便的在二次使用入口获取这个应用，那对于字节跳动和百度来说，第一次卖流量的钱就会越来越少。这和微信不同，微信不卖初次获取的流量，它的变现是后向的，来自于持续使用的微信支付、应用内广告。后向支付和广告收益如何平衡？初次流量销售收益和小程序留存如何平衡？这是2个需要它们妥善取舍的问题。三、结语本文给开发者提供了数据参考，也给小程序平台提出了一些问题。衷心希望各家小程序平台能解决好问题，取得更大的发展；更祝愿开发者把握住新红利，在大潮中实现自己的梦想。文章转载自：https://zhuanlan.zhihu.com/p/130332829作者：崔红保。转载标注出处"}
{"title": "uni-app 支持开发PC版的 360 小程序 ", "author": "Rolan", "date": "2020-8-11 14:54", "content": "uni-app 是一个遵循 Vue.js 语法的跨端框架，开发者编写一套代码，可发布到App、H5、小程序（微信/阿里/百度/字节跳动）及快应用。近期，uni-app新增支持发行到360小程序平台，目前hello uni-app 已上线360小程序，可以在360浏览器中点击链接打开体验如下是简易体验教程，Enjoy~通过 HBuilderX 可视化界面下载HBuilderX 创建uni-app项目在HBuilderX开发者工具中，点击文件 -> 新建 -> 项目：选择uni-app类型，输入工程名，选择模板，点击创建，即可成功创建。3. 进入已创建的项目，点击工具栏的运行 -> 运行到小程序模拟器 -> 360开发者工具，等待编译完成时自动调起 360浏览器4. 在360浏览器中导入编译后的目录，见 HBuilderX 控制台输出5. 在HBuilderX中修改代码，uni-app编译器会热更新到 360浏览器注意: 运行时为未压缩代码，正式上线时需要点击发行菜单通过vue-cli命令行习惯cli脚手架的同学，可以通过vue-cli创建uni-app项目。全局安装vue-clinpm install -g @vue/cli2. 创建uni-app项目，选择项目模板vue create -p dcloudio/uni-preset-vue my-project此时，会提示选择项目模板，初次体验建议选择 hello uni-app 项目模板，如下所示：3. 使用如下命令进行360小程序的编译预览及发行打包# npm script\r\n# dev 模式，编译预览\r\n$ npm run dev:mp-360\r\n# build 模式，发行打包\r\n$ npm run build:mp-360发行到360小程序，需要你下载并打开360浏览器，然后选择项目编译目录（dev模式、build 模式编译目录不同，见下方说明）进行预览或发行。dev模式 和 build 模式的区别：dev 模式编译目录为项目根目录下的 /dist/dev/ 目录build 模式编译目录为项目根目录下的 /dist/build/ 目录dev 模式有 SourceMap 可以方便的进行断点调试build 模式会将代码将会进行压缩，体积更小更适合发布为正式版应用开发规范uni-app 内置的组件及API已兼容360小程序，详见uni-app官网对于 360 小程序特殊的组件及API，可以通过条件编译调用360原生能力。"}
{"title": "使用原生开发高仿瑞幸小程序（四）：编写云函数并连接云数据库 ... ", "author": "Rolan", "date": "2020-8-12 11:12", "content": "编写第一个云函数通过云函数，我们将拥有编写服务端代码的能力。我们可以在服务端执行一些逻辑，可以上传图片，可以调用其他网络服务的api，可以对数据库进行操作。重要的是，云函数的编写相当简洁，便利。 在这一节，我们将通过云函数获取“为你推荐”的产品数据，实现数据动态化。实现这一功能，我们需要学习以下三块内容：❝1 创建第一个云函数 2 调用云函数 3 学会绑定点击事件❞一 创建第一个云函数如何创建云函数呢？我们这里通过“微信开发者工具”来完成云函数的创建和代码编写。 首先，我们右键单击“cloudfunctions”，选择“新建Node.js云函数” 写上我们的函数名“client_home_get_best”，这时候，工具会为我们创建一个同名文件夹，文件夹下面有一些文件，如下图： 接下来我们要做的是安装wx-server-sdk依赖，怎么做呢？右键点击新建的云函数文件夹，选择“在终端打开”。在打开的终端中输入“npm install --save wx-server-sdk@latest” 敲下回车并等待依赖下载完成。如下图：当安装完依赖后，我们的云函数文件夹也起了变化。多了node_modules文件夹和package-lock.json文件。对于目前的我们来讲，只有index.js文件是最重要的，之后我们会在这个js文件中编写我们的代码。先来看看工具默认都生成了什么代码：// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init()// 云函数入口函数exports.main = async (event, context) => {  const wxContext = cloud.getWXContext()    return {    event,    openid: wxContext.OPENID,    appid: wxContext.APPID,    unionid: wxContext.UNIONID,  }}从上往下解读代码，先是引入了wx-server-sdk，接着进行了初始化了。 诚如注释所述，我们的主要工作就是在“云函数入口函数”内编写代码。我们要写什么代码呢？我们要在这里返回“为你推荐”模块的数据，在这一节，我们只返回4个产品。在下一节，我们会结合数据库，从产品数据库中随机抽取4个返回。Ok，在具体编码之前，我想先对返回的数据做一个约定。 我需要status字段来告诉客户端，获取数据是成功了（success）还是失败了（fail）。 我需要一个msg字段来返回一些信息，虽然，这次用不着，但是我还是想先做好约定。 我还需要一个data字段来返回推荐产品的数据。所以返回数据的格式应该像下面这个样子。return {    status: status,    msg: msg,    data: data,}我们还需要做的是，把推荐的产品数据赋值给data。 那么，云函数入口函数的完整代码就该是这样：// 云函数入口函数exports.main = async (event, context) => {  const wxContext = cloud.getWXContext()  const status = \"success\"  const msg = \"\"  const data = [{      name: \"拿铁\",      oPrice: 24,      nPrice: 12,      thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/88F34543128D-1.jpeg\"    },    {      name: \"提拉米苏爱摩卡\",      oPrice: 19,      nPrice: 28,      thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/7B69340506EC-1.jpeg\"    },    {      name: \"陨石拿铁\",      oPrice: 28,      nPrice: 16.8,      thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/82B1B9FDDB21-1.jpeg\"    },    {      name: \"榛果拿铁\",      oPrice: 28,      nPrice: 16.8,      thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/FBD8B7AADBD9-1.jpeg\"    }  ]  return {    status: status,    msg: msg,    data: data,  }}当我们写完云函数之后，我们需要把云函数上传到云开发的服务器上。怎么做呢？其实也很简单，我们只需要右键单击云函数的文件夹，选择“上传并部署：云端安装依赖（不上传node_modules）”至此我们就完成了云函数的编写，接下来我们需要对云函数进行调用。二 调用云函数在小程序中，调用云函数是一件非常简单的事。我们只需要用过wx.cloud.callFunction即可。同时，小程序对云函数的调用是支持Promise风格的。什么是Promise？这对于js来说是个神器啊。我们有没有必要讲一下Promise，是有必要呢？还是有必要呢？ 我们还是简单说一下Promise吧。简单的说，就是用来处理异步回调的神器。像获取网络数据就是一个典型的异步操作。对于我们来讲，只需要熟练使用.then()和.catch()就好。 现在，让我们回到云函数的回调上来。我们回想一下，什么时候会去调用云函数？1是界面初始化的时候，还有就是“换一批”和“刷新”图标被点击的时候。所以我们需要把调用云函数的代码写成一个函数：onGetBest这个函数我们写在methods块内。/*** 组件的方法列表*/methods: {onGetBest:function(){  wx.cloud.callFunction({    name:\"client_home_get_best\"  }).then(res=>{    if (res.result.status == \"success\" &&res.result.data){      this.setData({        products:res.result.data      })    }  }).catch(err=>{    console.log(err)  })}},我们需要注意，在什么地方传入name的属性，也就是我们云函数的函数名“client_home_get_best”。 我们在then中接收云函数返回的数据。我们在云函数中返回的数据，都保存在res.result中。想想我们都返回了什么？status，msg和data。在这里，我们将以status是否为“success”和data是否存在为依据，来判断是否要更新“为你推荐”的数据。 调用云函数的函数就写完了，如果我有什么没讲清楚的，可以留言给我。 因为我们在界面初始化的时候，会调用一次云函数。所以我们要把onGetBest函数在attached中调用一次。接下来，我们要绑定点击事件。三 绑定点击事件在小程序的组件中，我们可以通过bindtap来绑定点击事件bindtap=“onGetBest\"在这个界面中，我们要在两个组件上绑定点击事件，1是“换一批”文字，2是刷新图标，代码如下：<view class=\"change\" bindtap=\"onGetBest\">换一批</view><van-icon color=\"gray\" size=\"28rpx\" name=\"replay\" bindtap=“onGetBest\"/>是不是很简单？ 我们再来做一个简单的处理是用户体验更好一些。是什么处理呢？就是当我们接受到数据后，我们再来显示“为你推荐”模块。怎么做到呢？我们可以通过wx:if来实现。怎么实现呢？通过判断绑定的数据products数组来判断，只有当products数组元素大于0时，才显示“为你推荐”模块。代码如下：<view class=\"mid_menu\" wx:if=“{{products.length>0}}\">云数据库初体验在上一节，我们创建了第一个云函数，在这一节，我们来一起学习一下云数据库的使用。当我们学会了小程序界面的绘制，逻辑的编码，云函数的编写，云数据库的使用，我们会变成什么？变成一个什么都会做的全栈工程师，由于我们什么都会做。所以我们什么都要做，于是时间就不够啦，就要开始996，然后007，这是福报，马爸爸说的。 开个玩笑啦，我们先成为全栈工程师，然后目标是成为一个10x程序猿。随着能力的提高，升职加薪是必然的。小程序的流行势不可挡，它还没有停止进化，当我们一个人就可以快速的完成一个小程序的开发时，我们就可以依靠个人力量去做一些产品，万一这个产品火爆了呢？没准就实现财务自由了。这是一个很美好的梦想对不对？马爸爸也说过，人总是要有梦想的，万一实现了呢？如果马爸爸没说过，那就算作我说的。 好了，废话不多说，今天我们一起来学习以下三块内容：❝1 创建集合 2 添加记录 3 云函数读取云数据库❞一 创建集合集合的概念，顾名思义，就是同类数据的集合。例如我们有个产品的集合里面放的都是产品的数据。我们的“为你推荐”模块就是从产品集合里面随机读取4条数据。 我们先来看看在开发者工具中如何创建集合。首先，点击“云开发” 然后点击“数据库”，并通过点击“+”号，创建集合。 在弹出的窗口中输入集合的名称，这里我们输入products： 点击“确定”，我们就能在左侧看到我们创建的集合了。二 添加记录接下里我们来添加记录，先点击我们的集合“products”，再点击“添加记录按钮”。在弹出窗口，我们可以通过加号按钮添加该条记录的属性及值。 我们以添加产品名为例。字段名输入“name”，类型选择string，值输入“陨石拿铁”。对于我们来讲，一条产品的记录光有name是不够的。一共有以下这几个字段：name：产品名nPrice：折后价格oPrice：原始价格thum：产品缩略图image：产品大图categoryId：产品分类id其中image和categoryId暂时用不着，但我们预留着。 除了手动一条一条的添加记录之外，我们还可以批量导入数据。在我们点击集合名称“products”之后，我们选择“导入”按钮 在打开的窗口中点击“选择文件”， 找到我们的json文件（该文件我会在源代码中提供）： 完成导入后我们就能看到我们导入的数据了： 我们来简单分析一下导入的数据。也就是我们的products.json文件。它虽然是以json结尾，但是又和我们平时接触的json不太一样。那我们就来做一个对比。普通的json文件如下[  {name:”拿铁”},  {name:”陨石拿铁”}]我们可以看到中括号清晰的表示这是一个数组，数组内的每条记录之间还有逗号“,”相隔。 而云数据库中的集合用的是jsonline格式如下：{name:”拿铁”}{name:”陨石拿铁”}数据外面没有中括号，记录之间也没有逗号“,”相隔。接下来，我们就要进入编码环节了。三 云函数读取云数据库接下来，我们要改造之前的云函数，将里面写死的数据，改成随机从数据库中读取。 我们打开“cloudfunctions/client_home_get_best/index.js”文件。在第四行添加两行代码：const db = cloud.database()const products = db.collection(\"products\")这两行代码什么意思呢？第一行，是用一个常量db表示我们对数据库的引用。接着再声明一个常量product表示我们对创建的集合“products”的引用。这样，我们就能通过products对产品数据进行操作了。 接下来，我们要实现的是，随机读取4条记录。const data = await products    .aggregate()    .sample({      size: 4    })    .end()我们一行一行的解释，第一行，我们要注意到一个关键字“await”，这表示我们的数据读取是同步的，为什么要这么做呢？因为数据库的操作默认是异步的。如果我们不改成同步的，那么我们在获取数据之前，云函数就直接返回结果了，那我们就什么数据都拿不到了。所以，关键字await是必须的。 第二行 aggregate()，这表示我们要对集合进行聚合操作。 聚合操作能对记录进行一些复杂的处理，例如随机挑选数据。它通常end()做结束。 而第三行sample就是我们这次的关键了，它接收的参数size就表示是随机取出记录的数量。data是我们拿到的数据，但是data里面的list才是我们所要的，所以返回的时候要这么写：return {    ……    data: data.list,  }最后来看看完整的代码：// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init()const db = cloud.database()const products = db.collection(\"products\")// 云函数入口函数exports.main = async (event, context) => {const wxContext = cloud.getWXContext()const status = \"success\"const msg = \"\"const data = await products    .aggregate()    .sample({size: 4    })    .end()console.log(data)return {status: status,msg: msg,data: data.list,  }}当我们写完index.js的代码，记得要将云函数的代码上传到云服务器上。怎么做呢？如下：完整代码我放在了github上，地址是：https://github.com/gogoswift/luckin[1]本文作者 ：「曾伟@喵先森」 ，文章转载自公众号【图雀社区】"}
{"title": "使用原生开发高仿瑞幸小程序（三）：完成 Layout 布局和为你推荐模块 ... ", "author": "Rolan", "date": "2020-8-12 11:22", "content": "完成 Layout 布局十年前，张小龙说过：“一个产品，要加多少功能，才能成为一个垃圾产品。”仅此一句话，道尽他做产品的理念。小程序就是其产品理念的最佳实践，少即是多，小即是大。今天，我们来绘制如下的界面要实现以上布局，我们需要学习以下三块内容❝1 通过图片的宽度计算出图片的高度 2 学会使用row组件 3 学会使用col组件❞一 分析布局看看我们要实现的布局，横平竖直，方方正正，比例匀称。其实这是非常容易实现的。我们将要用到vant组件库的layout布局系统。我们可以通过其中的row来实现横向布局。使用col实现竖向布局。row和col搭配起来，就能完成我们今天的布局了。首先我们来分析一下布局，我们可以把整个布局分为上下两个row，如下：ok，接下来，我们再用col填充row，如下图： 最后一步是什么呢？我们在每个col之中放入image组件即可。至此，我们就完成了布局的分析。为什么要用row和col？因为它们有个非常厉害的属性span。利用这个属性，我们能实现按比例布局。怎么个按比例法呢？在vant的layout系统中，横向被分为24分。如果要在row中放两个一样大小的col，只需要将将col的span设为24 / 2 = 12。以此类推，如果要放三个一样宽的col，只需要将每个col的span设为24 / 3 = 8。这就实现了我们第二个row的布局。现在我们来分析一下第一个row怎么布局。我们通过观察可知，第一个Row中有两个col，他们的比例是2:1，所以第一个col的span为 （24 / 3）* 2 = 16，第二个col的span为 24 / 3 = 8 。这样就实现了2:1的布局。二 通过图片的宽度计算出图片的高度我们需要六张图片，把它们放在云存储中。图片资源我放在了github中，github的地址会在文章末尾放出。 让我们来想想，要完成布局我们需要知道什么？我们知道屏幕宽度，知道图片左右边距，知道图片之间的距离，知道图片之间的比例，那么我们就知道了图片的宽度。所以我们需要通过计算获得图片在屏幕上的高度。为了让图片不变形，图片在屏幕上的高宽比要等于图片真实的高宽比，这就是我们计算的基础。图片在屏幕的高/图片在屏幕上的宽=图片真实的高/图片真实的宽 图片在屏幕上的高 =  图片在屏幕上的宽 * 图片真实的高/图片真实的宽 拿第一个row中的第一张图片来说，它真实高是666，宽是330。那么怎么得到它在屏幕上的宽呢？可通过以下的简单公式进行计算：屏幕宽度-左右外边距(margin)-左右内边距(padding)-与右边图片的距离 即是750 - 40 - 40 - 6 = 664所以它在屏幕上的高度就是 664 * 330 / 666 通过以上的方法，我们能算出每一张图片在屏幕上的高度三 row与col组件我们该怎么理解row与col呢？其实就是表格中的“行”与“列”。它们除了有能设置占位比例的span属性，row还有能设置元素间间距的gutter属性。还有一些其他属性，例如布局方式type，对齐方式justify，align，偏移量offset。点击时触发的click事件。这里就不做详细介绍了，有兴趣的同学可以去官方查看，地址如下https://youzan.github.io/vant/#/zh-CN/col[1]让我们来看看，我们在这一节中是如何实际运用的。首先，我们需要打开app.json，在“usingComponents”属性中引入我们今天要用到的三个组件，row，col和image\"usingComponents\": {  \"van-image\": \"@vant/weapp/image/index\",  \"van-row\": \"@vant/weapp/row/index\",  \"van-col\": \"@vant/weapp/col/index\"}接下来，我们来创建一个view用来存放我们的row<view class=\"mid_menu\"></view>给它一个样式.mid_menu{  margin-top: 50rpx;  margin-left: 20rpx;  margin-right: 20rpx;  background-color: white;  border-radius: 30rpx;  padding: 20rpx;}margin-top设置了顶边距 margin-left 和 margin-right分别设置了左边距与右边距。background-color:设置了背景色为白色 padding设置了内边距 border-radius:设置了圆角半径 对于第一个row来讲，我们需要放量个col进来，还记得它们的比例吗？是2:1，也就是16:8<van-row gutter=\"6\"> <van-col span=“16\"> 放一张图片 </van-col> <van-col span=“8\"> 放两张图片 </van-col></van-row>别忘了我们要设置这两个col之间的间距为6，也就是设置row的gutter的值。接下来，我们只要在col中放入image组件就好，这里我们使用了vant组件库中的vant-image，这是一个非常方便的同时封装了很多强大功能的组件。例如我们可以直接设置它的高宽属性。由于我们已经使用span属性分配了它们的宽度比例，所以每一个image的宽只需要设置100%就好，而它的高，我们会绑定在一个计算好的属性中。例如rowHeight，height=“{{rowHeight}}rpx\" 别忘了单位是rpx。而这个属性放在哪里呢？如果大家有印象的话，我们存放在js文件的data对象中。data: {……rowHeight:0,……}而rowHeight的计算，我们会放在attached函数中。而attached又是什么呢？我们来复习一下，这是当组件完成初始化，进入页面节点树后会被触发的函数。如此就完成了第一个row的绘制。第二个row来说就更加简单了，它分为三个等比例的col<van-row gutter=\"6\">  <van-col span=\"8\">  </van-col>  <van-col span=\"8\">  </van-col>  <van-col span=\"8\">  </van-col></van-row>同样，col中的image的宽度设为100%，而高度需要计算。让我们来看看完整代码<view class=\"mid_menu\"> <van-row gutter=\"6\">  <van-col span=\"16\">   <van-image width=\"100%\" height=\"{{rowHeight}}rpx\" src=\"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/01.png\" />  </van-col>  <van-col span=\"8\">   <van-image width=\"100%\" height=\"{{(rowHeight - 6)/2}}rpx\" src=\"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/02.png\" />   <van-image width=\"100%\" height=\"{{(rowHeight - 6)/2}}rpx\" src=\"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/03.png\" />  </van-col> </van-row> <van-row gutter=\"6\">  <van-col span=\"8\">   <van-image width=\"100%\" height=\"{{ rowHeight2 }}rpx\" src=\"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/04.png\" />  </van-col>  <van-col span=\"8\">   <van-image width=\"100%\" height=\"{{ rowHeight2 }}rpx\" src=\"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/05.png\" />  </van-col>  <van-col span=\"8\">   <van-image width=\"100%\" height=\"{{ rowHeight2 }}rpx\" src=\"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/06.png\" />  </van-col> </van-row></view>//在rpx的单位下，屏幕的宽度都为750const winWidth = 750const rowWidth = (winWidth - 80-6)*2/3const rowHeight = rowWidth * 330/666 const rowWidth2 = (winWidth - 80 -12)/3const rowHeight2 = rowWidth2 * 315/324为你推荐“为你推荐”模块我们将分成三个部分❝1 静态数据的界面 2 通过云函数获取数据 3 通过云数据库获取数据❞今天，我们讲的是第一部分如何绘制静态数据的“为你推荐”。也将分为三块内容❝1 布局分析 2 编写静态数据 3 绑定数据，循环渲染❞一 我们来分析一下布局我们可以看出，这个模块由上下两个row组成 我们来分析一下，上面的row由三个col组成。第二个col利用offset属性，与第一个col拉开了距离。如下图： 略微复杂的是下面的row，等分城了4个col。 现在我们来分析单个col。我们知道，在col中，元素是从上而下布局的。所以从上到下，依次为image，view。下面的价格由于我们要用到横向布局，所以是一个row，如下图： 让我们来重点分析一下最下面的row的布局。我用了三个col，第一个col用来放价格，第二个是加号按钮，第三个col实现的是右编剧。他们的比例分别是18:4:2 我们知道col是垂直布局，所以放置价格的col中我们会放入两个view。我比较喜欢在view中放文字。至此，我们就完成了布局的分析。二 静态数据“为你推荐”模块的数据是从云数据库中读取的，只不过在这一节中，我们将先采用静态数据模拟一下。我们该怎么写静态数据呢？首先，我们要认识到，为你推荐这个模块推荐的是4个产品。所以这个数据应该是一个数组。而每个产品的参数是一致的，应该有缩略图：thum，产品名：name，原价：oPrice，折扣价：nPrice。所以我们在“pages/home/cmponents/home/home.js”文件中的静态数据编写如下：data: {    ......    products: [{        name: \"拿铁\",        oPrice: 24,        nPrice: 12,        thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/88F34543128D-1.jpeg\"      },      {        name: \"提拉米苏爱摩卡\",        oPrice: 19,        nPrice: 28,        thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/7B69340506EC-1.jpeg\"      },      {        name: \"陨石拿铁\",        oPrice: 28,        nPrice: 16.8,        thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/82B1B9FDDB21-1.jpeg\"      },      {        name: \"榛果拿铁\",        oPrice: 28,        nPrice: 16.8,        thum: \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/menu/thum/FBD8B7AADBD9-1.jpeg\"      }    ]  },  ......}这里所涉及的图片我会放在github上。大家可以存到自己的云存储上。「三 绑定静态数据」最后，让我们来看看界面上的代码该怎么写，打开“pages/home/cmponents/home/home.wxml”，新增一个view<view class=\"mid_menu\"> <van-row gutter=\"6\">  <van-col span=\"8\">   <view class=\"menu_title\">为你推荐</view>  </van-col>  <van-col span=\"6\" offset=\"8\">   <view class=\"change\">换一批</view>  </van-col>  <van-col span=\"2\">   <van-icon color=\"gray\" size=\"28rpx\" name=\"replay\" />  </van-col> </van-row> <van-row gutter=\"10\">  <block wx:for=\"{{products}}\" wx:key=\"*this\">   <van-col span=\"6\">    <van-image radius=\"16rpx\" width=\"{{productWidth}}rpx\" height=\"{{productWidth}}rpx\" src=\"{{item.thum}}\" />    <view class=\"pTitle\">{{item.name}}</view>    <van-row>     <van-col span=\"18\">      <view class=\"nPrice\">¥{{item.nPrice}}</view>      <view class=\"oPrice\">¥{{item.oPrice}}</view>     </van-col>     <van-col span=\"4\">      <image style=\"width:30rpx;height:30rpx;margin-top:10rpx;\" src=\"./images/btnAdd.png\" />     </van-col>     <van-col span=\"2\">     </van-col>    </van-row>   </van-col>  </block> </van-row></view>这里面的知识点，其实我们之前都讲过。无非就是以下几点：❝1 row和col的使用，它们是如何按比例布局的，今天的新知识点是偏移量属性offset，用来实现间隔布局。2 推荐的产品，我们用block和wx:for实现了数据的绑定和产品的循环渲染。wx:key和item的意义也是学过的内容。❞所以，如果大家是从头一路看过来的，这节将是非常轻松的。如果对样式有什么疑问，可以参看home.wxss里面的内容。下一节，将会有新的内容，云函数，这是一个非常强大的功能。学会使用后，我们就离10x程序员又近了一步。❝本文转载自公众号【图雀社区】，作者 ：「曾伟@喵先森」"}
{"title": "使用原生开发高仿瑞幸小程序（二）：使用云存储并实现轮播图 ... ", "author": "Rolan", "date": "2020-8-12 11:42", "content": "创建轮播图轮播图是我们常见的一种表现形式，通常，图片之间要做到无缝衔接循环需要花一些功夫，而小程序提供的组件就已经可以实现。可以说省去了开发者不少的时间。所以，今天我们要一起来学习以下几件事：❝1 学会使用云存储 2 学会使用image组件 3 简单自定义navigation 4 学会使用swiper组件来创建轮播图❞一 云存储的使用让我们一步一步的来，首先我们需要给小程序的首页创建一个背景。如下图 在这里，背景图片我放到了云存储上。要知道，当我们创建小程序后，我们有5G存储空间和5G的流量可以免费使用。这足够我们开发使用了。那么，怎么把背景图图片放到云存储上呢？我们在微信开发者工具的顶部找到“云开发”按钮。这时候，我们会打开“云开发控制台”。我们再点击“存储”按钮，就来到了云存储的管理界面。如下图我们可以通过“新建文件夹”来进行分类管理。想我，我就创建了“images”文件夹，同时在images文件夹下面根据Tabbar又创建了。“home”，“menu”，“cart”，“order”和“my”五个文件夹。因为我们现在在创建首页嘛，所以我会把首页下的相关图片都放在home文件夹下。云存储不仅能存图片，还能存放其他文件，这里就不细讲了。我们可以点击“上传文件”按钮，将今天所需的图片素材，传到云存储上。我将背景图和今天轮播图所需的图片都传到了“images/home”文件夹下。我们的image组件能直接使用File ID，省却了地址转换的麻烦。File ID的地址如下图所示。 上图红框所标示的地址就是我们背景图片的地址，让我们复制一下，接下来马上就会用到。二 利用image组件创建背景接下来，我们需要使用的是image组件，我们将通过改变它的z坐标将它放置在其他组件的“下面”，这样就变成了home页面的背景了。为什么不用css中的background-image呢？因为这个属性必须使用网络图片或者base64图片。而我们的云存储的File ID地址必须要转换一下才能获得真实地址，所以太麻烦，不如直接用image来的快。好，接下来看看怎么使用image组件。首先，我们用view给整个试图创建一个根容器，仿造html，我们给class起名为body<view class=\"body\"></view>接着，我们在其中放入image组件，背景图片<view class=\"body\"><image class=\"bg\" src=\"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/homebg.png\"></image></view>我们给image 的class属性赋值为bg。接下我们到home.wxss中做一些工作。首先，我们让body横向撑满整个屏幕.body{  width: 100%;}接下来，我们要将改变image组件的z坐标了。.bg{  /*fixed 固定位置 absolute 跟随屏幕滚动 */  position: absolute;   top: 0;  z-index: -100;}z-index就是我们所说的z坐标了。什么是z坐标呢，我们知道横轴是x坐标，竖轴是y坐标。xy组成了一个平面，也就是我们的手机屏幕。那么垂直与手机屏幕的就是z坐标。z坐标的值越小，就在越后面，也就会被挡住。那么当我们把z-index设为-100的时候，image就位于其他组件的下方了。很好，如果一切正确，将会看到如下画面。这和我们所期望的效果有些不一样？我们期待的效果是没有顶部的navigation的对不对？不要着急，接下来我们就来解决这个问题。三 简单自定义navigation其实要让顶部的navigation消失非常简单，我们只需要打开“pages/home/home.json”，添加\"navigationStyle\": “custom\",即可，这行代码的意思就是，我们将使用自定义的navigation。我们只要什么都不做，就让将默认的navigarion消失了。如下图所示四 创建轮播图如何创建轮播图呢？答案是，使用小程序提供的swiper组件。使用swiper组件，一切都将变得非常的简单。❝1 我们将在home.wxml中创建swiper 2 我们将在home.js中定义轮播图的数据 3 我们将在home.js中定义swiper所需要的定位数据❞首先，让我们创建swiper<view class=\"swiper\"><swiper circular = \"{{true}}\" indicator-active-color=\"#ffffff\" bindanimationfinish=\"onFinish\" indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\"><block wx:for=\"{{swiperData}}\" wx:key=\"*this\"><swiper-item>  <image src=\"{{item}}\" mode=\"widthFix\"></image></swiper-item></block></swiper></view>我在创建swiper之前，会在其外面套一层view，用来做定位以及样式相关控制。那么就来看看我都对view做了什么样的样式控制。.swiper{  margin-left: 20rpx;  margin-right: 20rpx;  border-radius: 30rpx;  /* 使内容同样获得圆角 */  overflow: hidden;  /* transform: translateY(0); */}在这里，我们通过margin-left设置了左边距离屏幕20rpx，margin-right右边距也是20rpx，border-radius设置了圆角矩形的半径为30rpx，最后，为了让view所包含的swiper也能有圆角效果，我们还需要将overflow设置为hidder。知识点，我们知道px是像素的意思，那么rpx是什么样的尺寸呢？以往我们在开发手机app的时候，为了在不同尺寸的屏幕上显示一样的设计效果，我们需要根据尺寸的不同进行一定的换算。如果使用rpx则可以进行自适应了，省却了换算的麻烦。至此，我们就完成了外层样式的设定，接下来，让我们回到home.wxml中，看看swiper的代码都是什么意思。在swiper标签中，我们能看到属性circular 设为了truecircular = “{{true}}\"这表示，我们开启了循环轮播，大家可以把这个属性去掉，看看有什么不同的效果。bindanimationfinish=“onFinish”标示，我们在每个图片切换动画完成后，会执行onFinish函数。indicator-dots=“{{true}}\" 表示轮播图将会显示指示小圆点 indicator-active-color=“#ffffff\" 表示选中的小圆点的颜色，这里我设置为了白色。interval=“{{2000}}” 表示图片的切换相隔2000毫秒也就是2秒 duration=“{{500}}\" 表示切换动画持续时间为0.5秒 以上就是关于swiper的基本设置。接下来，我们将会用block来设置swiper的数据源以及通过swiper-item来设置轮播的图片。在代码中，我们可以看到block标签。这是wxml的语法标签。在这个标签下，我们能够有限的使用一些流程控制语法。例如在这一节中，我们使用的 wx:for，它可以绑定一个数组，将多个字节点渲染出来。wx:for 我们绑定的是组件home.js中的一个数组swiperData，和页面的js一样，放在data对象中。data: {    swiperData: [      \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/DC240B320F4-1.jpeg\",      \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/6C04DA13FC28-1.jpeg\",      \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/DA98AD7CF153-1.jpeg\",      \"cloud://myluckin-unux5.6d79-myluckin-unux5-1302022060/images/home/87542BE16ED7-1.jpeg\"    ],}而wx:key这是用来给for中的每一个子项一个唯一标识的，这样可以在数据源有改动时，原有的子对象能保留状态，例如文本框里输入的内容。wx:key 的值以两种形式提供❝1 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。2 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。❞我们的轮播图，用的是*this。swiper-item 标签仅可放在swiper标签中，宽高自动设置为100%。我们在swiper-item中再放一个image组件。我们只需要把image的属性src赋值即可。那么我们怎么获得swiperData数组中的元素呢？很简单，在wx:for遍历数组的时候，item就代表着数组中的元素。即：<image src=\"{{item}}\" mode=\"widthFix\"></image>我们发现，轮播图的位置距离顶部太近了，我们至少要把状态栏和标题栏空出来。状态栏和标题栏的高度，我们可以通过系统动态获取。所以我们组件home.js中，预留两个属性statusBarHeight: 0,titleBarHeight: 0,这两个属性的值，我们会在组件进入页面时进行赋值。这样，在组件被渲染时就能拿来用了。我们要做什么来着？为了让轮播组件下来一点。所以我们可以在承载swiper的view中这么写。style=\"margin-top:{{(titleBarHeight + statusBarHeight)}}rpx;height {{((wx.getSystemInfo().windowWidth - 40)*540/1065)}}rpx;”这是一种编写样式的方式，为什么写在在wxml中，这是为了能够动态的使用statusBarHeight和titleBarHeight。我们注意到，除了使用margin-top，这个用来设定定边距的属性之外，我们还设置了height的值，也就是轮播组件的高度。这里有一个小公式。用来根据屏幕宽度动态计算轮播组件的高度。按比例拉升的公式是这样的：根据 轮播组件高/轮播组件的宽 = 图片高/图片宽 可以推导出 轮播组件的高 = 轮播组件的宽 * 图片高/图片宽 图片的高宽，我们是可以知道的，分别为540和1065，自己搞得图片嘛，当然知道saize。那轮播组件的宽呢？等于屏幕的宽wx.getSystemInfo().windowWidth 减去 左右边距即40 所以轮播组件的高 = wx.getSystemInfo().windowWidth - 40)*540/1065 如果看到这里还没有头昏脑胀的话，我们继续往下看，如何获得statusBarHeight和titleBarHeight的值？我们可以通过微信提供的api：getSystemInfo获得。代码如下代码如下attached() {    var statusBarHeight = 0    var titleBarHeight = 0    wx.getSystemInfo({      success: (res) => {        statusBarHeight = res.statusBarHeight        titleBarHeight = wx.getMenuButtonBoundingClientRect().bottom + wx.getMenuButtonBoundingClientRect().top - (res.statusBarHeight * 2)      },      failure() {        statusBarHeight = 0        titleBarHeight = 0      }    })    this.setData({      statusBarHeight: statusBarHeight,      titleBarHeight: titleBarHeight    })},大家注意到，我们在计算titleBarHeight的时候，调用了wx.getMenuButtonBoundingClientRect这个api，这是什么呢？这个api能获取微信右上角胶囊按钮的布局信息。好有一个新的知识点需要学习一下，就是在组件中，attached函数是干嘛的？这是组件生命周期的一个函数，当在组件实例进入页面节点树时就会执行，在我们的实例中，我们正是利用这个函数给我们的组件的顶边距赋值的。小程序的全局数据这一节我们只讲一件事，就是如何在小程序里面使用全局数据。涉及三个方面❝1 为什么要使用全局数据 2 怎么存储全局数据 3 怎么读取全局数据❞那么，为什么要使用全局数据？我们试想一下，如果有些数据所有界面都要用呢，该怎么办？一个页面一个页面的传会不会太麻烦了？我们就在首页中尝试着使用一下全局数据。我们在小程序的项目文件中能看到app.js这个文件。 这个文件用来干什呢？是用来注册小程序用的，同时小程序的一系列事件都会在这个文件里得到响应。例如小程序初始化了，小程序前后台切换，还有就是可以用来存储一些全局数据。重要的是，整个小程序只会有一个app.js的实例。这也是为什么它适合用来存储全局数据。怎么存放呢？我们注意到app.js中有这么一行代码this.globalData = {}这行代码的意思是，app的实例中，有个对象叫globalData，我们通常会把全局数据存放在globalData这个对象中。那么，当我们把全局数据存放到app.js中的话，我们又该如何读取出来呢？首先，我们能够通过全剧函数getApp()获得app.js的唯一实例。接着就能通过点语法取出数据了，完整代码差不多就是这个样子。getApp().globalData.数据所以整个过程就这么简单，分两步，放进去，取出来。好，还记得上一节我们讲过的如何计算轮播图的顶边距吗？我们需要得到statusBarHeight和titleBarHeight。那我们现在就把这两个值放入全局数据中。所以我们把home.js中attached函数中的代码移到app.js中，并将statusBarHeight和titleBarHeight的值赋给globalData。代码如下this.globalData = {}wx.getSystemInfo({  success: (res) => {    this.globalData.statusBarHeight = res.statusBarHeight    this.globalData.titleBarHeight = wx.getMenuButtonBoundingClientRect().bottom + wx.getMenuButtonBoundingClientRect().top - (res.statusBarHeight * 2)  },  failure() {    this.globalData.statusBarHeight = 0    this.globalData.titleBarHeight = 0  }})这完成了第一步，把数据放进去。现在我们把数据取出来。回到home.js的attached函数中，以下是取出数据的代码attached() {this.setData({  statusBarHeight: app.globalData.statusBarHeight,  titleBarHeight: app.globalData.titleBarHeight})},我们注意到更新数据用的是this.setData函数。使用这个函数更新数据，绑定数据的界面才会更新。更正轮播组件的高度计算❝首先是一个知识点，当我们在小程序中使用rpx单位的时候，屏幕的宽度都为750rpx。我们通过wx.getSystemInfoSync().windowWidth获得的是px为单位的屏幕宽度。如果涉及到需要使用屏幕宽度来计算尺寸，请使用750，因为我们在小程序中，使用的单位是rpx。❞现在，我们来重新计算轮播图的高度。之前，我们把高度的计算直接写在了wxml中，现在我们把它剥离出来，同时用变量swiperHeight做为高度的绑定。`如下：style=\"margin-top:{{(titleBarHeight + statusBarHeight)}}rpx;height:{{swiperHeight}}rpx;\"于是，我们的精力将集中在swiperHeight的计算上。首先，我们需要在data中声明swiperHeightdata: {    swiperHeight:0,......接着，我们来计算swiperHeight，而我们之前推导过高度的计算，还记得吗？如下：轮播组件的高度 = (wx.getSystemInfo().windowWidth - 40)*540/1065现在我们知道了，不该使用wx.getSystemInfo().windowWidth，而该直接使用750.所以我们的计算公式就该改为如下：const winWidth = 750const swiperHeight = (winWidth - 40 ) * 540/1065计算完后，别忘了使用setData更新swiperHeight的值。这下，轮播图的显示终于完美。 本文转载自公众号【图雀社区】，作者 ：「曾伟@喵先森」"}
{"title": "开发微信小程序，我为什么使用 upData ", "author": "Rolan", "date": "2020-8-3 15:12", "content": "鉴于在下使用微信小程序开发时使用 setData 的蹩脚体验，开发了个库函数 wx-updata ，项目上线之后，我把这个自用的库函数整理放到 Github 上开源出来 wx-updata ，这个库函数在开发的时候对我很有帮助，希望也可以帮到大家 :clap:如果大家在使用中遇到了问题，可以给我提 pr，提 issue，一起来改善小程序开发体验加油～1. setData 不方便的地方你在使用 setData 的时候，是不是有时候觉得很难受，举个简单的例子：// 你的 data\r\ndata: {\r\n    name: '蜡笔小新',\r\n    info: { height: 140, color: '黄色' }\r\n}\r\n复制代码如果要修改 info.height 为 155，使用 setData 要怎么做呢：// 这样会把 info 里其他属性整不见了\r\nthis.setData({ info: { height: 155 } })\r\n\r\n// 你需要取出 info 对象，修改后整个 setData\r\nconst { info } = this.data\r\ninfo.height = 155\r\nthis.setData({ info })\r\n复制代码似乎并不太复杂，但如果 data 是个很大的对象，要把比较深且不同的对象、数组项挨个改变：data: {\r\n    name: '蜡笔小新',\r\n    info: {\r\n        height: 140, color: '黄色',\r\n        desc: [{ age: 8 }, '最喜欢大象之歌', '靓仔', { dog: '小白', color: '白色' }]\r\n    }\r\n}\r\n复制代码比如某个需求，需要把 info.height 改为 155，同时改变 info.desc 数组的第 0 项的 age 为 12，第 3 项的 color 为灰色呢？// 先取出要改变的对象，改变数字后 setData 回去\r\nconst { info } = this.data\r\ninfo.height = 155\r\ninfo.desc[0].age = 12\r\ninfo.desc[3].color = '灰色'\r\nthis.setData({ info })\r\n\r\n// 或者像某些文章里介绍的，这样可读性差，也不太实用\r\nthis.setData({\r\n    'info.height': 155,\r\n    'info.desc[0].age': 12,\r\n    'info.desc[3].color': '灰色'\r\n})\r\n复制代码上面这两种方法，是我们平常小程序里经常用的，和其他 Web 端的框架相比，就很蹩脚，一种浓浓的半成品感扑面而来，有没有这样一个方法：this.upData({\r\n    info: {\r\n        height: 155,\r\n        desc: [{ age: 12 }, , , { color: '灰色' }]\r\n    }\r\n})\r\n复制代码这个方法会帮我们深度改变嵌套对象里对应的属性值，跳过数组项里不想改变的，只设置我们提供了的属性值、数组项，岂不是省略了一大堆蹩脚的代码，而且可读性也极佳呢。这就是为什么我在上线的项目中使用 wx-updata ，而不是 setData2. wx-updata 的优点支持 setData 对象自动合并，不用写蹩脚的对象路径了支持对象中嵌套数组，数组中嵌套对象；如果数组的某个值你不希望覆盖，请使用数组空位来跳过这个数组项，比如 [1,,3] 这个数组中间就是数组空位；如果数组空位你的 Eslint 报错，可以使用 wx-updata 提供的 Empty 来代替： [1, Empty, 3]3. wx-updata 安装你也可以直接把 dist 目录下的 wx-updata.js 拷贝到项目里使用使用 npm 、 yarn 安装方式：$ npm i -S wx-updata\r\n# or\r\n$ yarn add wx-updata\r\n复制代码然后：详情 - 本地设置 - 使用npm模块\r\n工具 - 构建npm\r\n构建后成功生成 miniprogram_npm 文件夹就可以正常使用了4. wx-updata 使用方法使用方式一可以使用直接挂载到 Page 上的方式，这样就可以在 Page 实例中像使用 setData 一样使用 upData 了// app.js\r\nimport { updataInit } from './miniprogram_npm/wx-updata/index'  // 你的库文件路径\r\n\r\nApp({\r\n    onLaunch() {\r\n        Page = updataInit(Page, { debug: true })\r\n    }\r\n})\r\n复制代码// 页面代码中\r\n\r\nthis.upData({\r\n    info: { height: 155 },\r\n    desc: [{ age: 13 }, '帅哥'],\r\n    family: [, , [, , , { color: '灰色' }]]\r\n})\r\n复制代码使用方式二有的框架可能在 Page 对象上进行了进一步修改，直接替换 Page 的方式可能就不太好了， wx-updata 同样暴露了工具方法，用户可以在页面代码中直接使用工具方法进行处理：// 页面代码中\r\n\r\nimport { objToPath } from './miniprogram_npm/wx-updata/index'  // 你的库文件路径\r\n\r\nPage({\r\n    data: { a: { b: 2}, c: [3,4,5]},\r\n\r\n    // 自己封装一下\r\n    upData(data) {\r\n        return this.setData(objToPath(data))\r\n    },\r\n\r\n    // 你的方法中或生命周期函数\r\n    yourMethod() {\r\n        this.upData({ a: { b: 7}, c: [8,,9]})\r\n    }\r\n})\r\n复制代码使用 Empty 代替数组空位可以使用 wx-updata 提供的 Empty 来代替数组空位，由于 Empty 本质上是一个 Symbol，所以只能使用 wx-updata 导出的，而不能自己新建。// 页面代码中\r\nimport { Empty } from './miniprogram_npm/wx-updata/index'\r\n\r\nthis.upData({\r\n    info: { height: 155 },\r\n    desc: [{ age: 13 }, '帅哥'],\r\n    family: [Empty, Empty, [Empty, Empty, Empty, { color: '灰色' }]]\r\n})\r\n复制代码5. wx-updata 相关 APIPage.prototype.upData(Object data, Function callback)data ： 你希望设置的 datacallback ： 跟 setData 第二个参数一样，引起界面更新渲染完毕后的回调函数updataInit(Page, config)Page ： 页面对象，需要在 app.js 中调用；config ： 若提供配置参数 { debug: true } ，会将路径化后的 data 打印出来，帮助用户进行调试；objToPath(Object data)data ： 你希望设置的 data 对象网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~"}
{"title": "mpvue开发小程序——项目初始化及实现授权登录 ", "author": "Rolan", "date": "2020-8-4 10:51", "content": "mpvuempvue是一个使用vue.js开发小程序的框架。其官网的介绍是，mpvue框架基于Vue.js核心，mpvue修改了Vue.js的runtime和compiler实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套Vue.js开发体验。使用mpvue框架开发小程序，能够直接使用vue语法进行开发。Vant WeappVant Weapp是一套小程序UI组件库，可以使用这个UI库封装好的一些组件来实现某些功能，类似element组件的引入使用。flyiogithub： https://github.com/wendux/flyFlyio帮助文档： https://wendux.github.io/dist...如官网所说，Fly.js是一个支持所有JavaScript运行环境的基于Promise、支持请求转发的http请求库，它可最大限度地在多个端上实现代码复用。其拥有的特点：1、提供统一的PromiseAPI2、浏览器环境下非常轻量3、支持多种JavaScript运行环境4、支持请求/响应拦截器5、自动转换JSON数据6、支持切换底层 HTTP Engine，可轻松适配各种运行环境7、浏览器端支持全局Ajax拦截8、H5页面内嵌到原生APP时，支持将HTTP请求转发到Native，支持直接请求图片本次搭建的小程序环境，将使用flyio这个http请求库来实现数据的请求，目前用到的方法为get、post。两者的使用示例在官网帮助文档有示例：项目初始化1、搭建mpvue脚手架基于mpvue-quickstart模版创建新项目vue init mpvue/mpvue-quickstart one_hour_app2、打开并跑起项目新建的项目打开，dist文件夹尚未存在跑起项目cd one_hour_appnpm run dev这样跑起来后项目中便多了一个dist文件夹，里面有个wx文件夹这个wx文件夹就是要导入到微信开发者工具中的文件。安装微信开发者工具，打开微信官网文档页面可下载： https://developers.weixin.qq....安装好微信开发者工具后点击导入项目弹窗内输入导入的目录目录就是刚才说的那个在one_hour_app项目中npm run dev之后生成的dist下的wx。AppID的获取，需要先在微信公众平台注册，然后打开开发-开发设置找到。导入成功后显示这样这样，就可以在编辑器写我们的代码，然后在微信开发者工具里面可以像浏览器一样查看页面效果。查看项目vue文件可以发现，我们基本上可以像写vue一样写里面的vue文件。之后对项目结构进行删减，把原本提供的那些没用到的文件先删除。保留一个架构。开发主要关注的是src这个目录。statics里面的images、tabs删掉src/main.js保持不变src/App.vue里的代码删掉，剩下src/app.json对应到页面路由pages配置、头部windows的样式和文字设置、脚部tabBar菜单配置，现在只保留如下：src/utils文件先保持不变src/components/card.vue删掉src/pages只留下index那块的内容。接着是删掉index.vue的东西。修整完后，只剩下首页至此，基于mpvue的小程序项目架构已经搭建好了。接着是css扩展语言scss、Vant Weapp UI组件库、flyio、mpvue路由插件mpvue-router-patch。1、安装scss，sass-loader的版本是7.3.1，如果使用最新的版本会报错，这里安装这个低版本的。npm i -D sass-loader node-sass测试下：2、安装Vant Weappnpm i vant-weapp -S --production打开Vant Weapp的官网找一个button的例子测试下，但是使用之前需要在app.json文件中配置引入组件。由于把这个组件安装到了node_modules/vant-weapp/dist，所以引入组件的路径跟官网给的不一样，需要手动修改一下路径：同时由于我们需要在微信开发者工具查看，而那里导入了的是dist/wx，跟编辑器里的目录是不一样的，所以为了能在微信开发者工具正常显示组件，还需要做一个配置，将整个node_modules/vant-weapp/dist目录拷贝到dist/wx/vant-weapp/dist目录，在wepack.base.conf.js添加如下配置：if (/^wx$/.test(PLATFORM)) {\r\n  baseWebpackConfig = merge(baseWebpackConfig, {\r\n    plugins: [\r\n      new CopyWebpackPlugin([{\r\n        from: resolve('node_modules/vant-weapp/dist'),\r\n        to: resolve('dist/wx/vant-weapp/dist'),\r\n        ignore: ['.*']\r\n      }])\r\n    ]\r\n  })\r\n}使用一个button组件测试下：<van-button type=\"primary\">主要按钮</van-button>这样组件就成功引入了，而且也可以看到刚才那个拷贝目录的配置也生效了，可以看到vant-weapp目录已在wx里生成。3、安装flyio、mpvue-router-pushnpm i -S flyio\r\nnpm i -S mpvue-router-patch现在用不到这个路由插件，先安装着放着。接着是使用flyio来实现小程序授权登录的请求。首先在utils里创建request.js用来封装flyio的请求。// 初始化flyio请求\r\nfunction createFly () {\r\n  if (mpvuePlatform === 'wx') {\r\n    const Fly = require('flyio/dist/npm/wx')\r\n    return new Fly()\r\n  } else {\r\n    return null\r\n  }\r\n}// 处理get请求、post请求，\r\n//如果是post，就把get改成post就行，这里为了节省篇幅，省去了post的那段代码\r\nexport function get (url, params = {}, showErr = true) {\r\n  const fly = new createFly()\r\n  if (fly) {\r\n    return new Promise((resolve, reject) => {\r\n      fly.get(url, params).then(response => {\r\n        const data = (response && response.data) || {}\r\n        if (data.error_code === 0) {\r\n          resolve(response)\r\n          console.log(response)\r\n        } else {\r\n          if (showErr) {\r\n            mpvue.showToast({\r\n              title: data.msg || '请求失败',\r\n              icon: 'none',\r\n              duration: 1500\r\n            });\r\n          }\r\n          reject(response)\r\n        }\r\n      }).catch(err => {\r\n        console.log(err)\r\n      })\r\n    })\r\n  }\r\n}如果遇到了 TypeError: __webpack_require__(...) is not a function这样的问题，就关闭微信开发者工具，删除dist包，再重新npm run dev跑一下，重新打开微信开发者工具应该就没问题了。接下来是用户授权的内容。授权登录首页的展示，需要调用mpvue.getSetting获取用户的当前设置。已授权就展示正常页面，未授权就展示auth.vue授权登录页面。未授权的状态，当用户同意授权使用的时候，这时首页就会变成正常的页面，同时，需要获取用户的信息userInfo。在成功获取了用户信息之后，需要使用存储器mpvue.setStorageSync把它存储起来供之后需要的时候使用getStorageSync来获取。这时会存在两种情况，一种是已存在openId的情况，另一种是还没获取openId的情况。当未取到openId时，需要调用接口获取openId，而调用这个接口需要获得code，这个code可以通过mpvue.login API获取到。当取得code之后就调用获取openId的接口，返回openId并存储起来。取得openId后，就可以把这个openId作为参数，传给获取首页数据的接口。当已经取得openId时，就直接调用首页接口数据并传openId作为接口的参数。在此之后，需要调用register注册接口，调用这个接口能够把用户的行为数据存储在后台，辨别不同的用户。流程示意图：auth.vue组件主要的按钮事件：<button class=\"auth-btn\" \r\n              open-type=\"getUserInfo\"\r\n              @getuserinfo=\"getUserInfo\">授权登录</button>getUserInfo () {\r\n      this.$emit('getUserInfo')\r\n    }src/api/index.js用来存放接口import { get, post } from \"@/utils/request.js\"\r\nconst API_BASE = '后台接口前缀'\r\n\r\nexport function getOpenId (params) {\r\n  return get(`${API_BASE}/openId/get`, params)\r\n}\r\n\r\nexport function getHomeData (params) {\r\n  return get(`${API_BASE}/book/home/v2`, params)\r\n}\r\n\r\nexport function register (params) {\r\n  return post(`${API_BASE}/user/register`, params)\r\n}src/api/wechat.js用来存放微信平台相关的APIimport { getOpenId } from '@/api'\r\nconst APP_ID = '填写微信公众平台的App_ID'\r\nconst SECRET = '填写微信公众平台的secret'\r\n\r\n// 请求getSetting获取用户当前的授权\r\nexport function getSetting (auth, onSuccess, onFail) {\r\n  mpvue.getSetting({\r\n    success (res) {\r\n      if (res.authSetting[`scope.${auth}`]) {\r\n        onSuccess(res)\r\n      } else {\r\n        onFail(res)\r\n      }\r\n    },\r\n    fail (res) {\r\n      console.log(res)\r\n    }\r\n  })\r\n}// 获取用户信息\r\nexport function getUserInfo (onSuccess, onFail) {\r\n  mpvue.getUserInfo({\r\n    success (res) {\r\n      onSuccess(res)\r\n      console.log(res)\r\n    },\r\n    fail (res) {\r\n      onFail(res)\r\n    }\r\n  })\r\n}// 获取openId\r\nexport function getUserOpenId (callback) {\r\n  mpvue.login({   // 调用login API 获得code\r\n    success (res) {\r\n      console.log(res)\r\n      const { code } =  res // 这个code是获取openId的前提\r\n      getOpenId({ code, appId: APP_ID, secret: SECRET }).then(response => {\r\n        const { openid } = response.data.data\r\n        mpvue.setStorageSync('openId', openid)\r\n        callback && callback(openid)\r\n      }).catch(err => {\r\n        console.log(err)\r\n      })\r\n    },\r\n    fail (res) {\r\n      console.log(res)\r\n    }\r\n  })\r\n}index.vue页面：<template>\r\n  <div>\r\n    <div v-if=\"isAuth\">\r\n      <div class=\"index\">首页</div>\r\n      <van-button type=\"primary\">主要按钮</van-button>\r\n      <div>\r\n        获取userInfo示例：\r\n        <div>\r\n          {{ userInfo.nickName }}\r\n        </div>\r\n        获取homeData数据示例：\r\n        <div>{{ homeData.hotSearch && homeData.hotSearch.num }}</div>\r\n      </div>\r\n    </div>\r\n    <auth v-if=\"!isAuth\" @getUserInfo=\"init\" />\r\n  </div>\r\n</template>import { get, post } from '@/utils/request'\r\nimport Auth from '@/components/base/auth.vue'\r\nimport { getHomeData, register } from '@/api'\r\nimport { getSetting, getUserInfo, getUserOpenId } from '@/api/wechat'data () {\r\n    return {\r\n      isAuth: false,\r\n      userInfo: {},\r\n      homeData: {}\r\n    }\r\n  },\r\n  mounted () {\r\n    this.init()\r\n  },// 获取首页数据\r\ngetIndexData (openId, userInfo) {\r\n    getHomeData({ openId }).then(response => {\r\n        console.log('getHomeData-----', response)\r\n        this.homeData = response.data.data\r\n    })\r\n},// 在获得授权信息后调用以获得用户信息\r\ngetUserInfoData () {\r\n    const onCompleteGetOpenId = (openId, userInfo) => {\r\n        this.getIndexData(openId, userInfo)  // 获取首页数据\r\n        register({ openId, platform: mpvuePlatform, ...userInfo })  // 注册\r\n    } \r\n    getUserInfo( // 获取用户信息\r\n        (res) => {\r\n            const { userInfo } = res\r\n            this.userInfo = userInfo\r\n            mpvue.getStorageSync('userInfo', userInfo)\r\n            const openId = mpvue.getStorageSync('openId')\r\n            if (!openId || openId.length === 0) { // 未存在openId\r\n                getUserOpenId((openId) => { // 需要请求接口获得\r\n                    onCompleteGetOpenId(openId, userInfo)\r\n                })\r\n            } else {\r\n                onCompleteGetOpenId(openId, userInfo) // 已存在openId\r\n            }\r\n        },\r\n        (res) => {\r\n            console.log(res)\r\n        }\r\n    )\r\n}// 一开始就需要获取授权信息，mounted里调用\r\ninit () {\r\n    getSetting(\r\n        'userInfo',\r\n        (res) => {\r\n            this.isAuth = true\r\n            console.log(res)\r\n            this.getUserInfoData()\r\n        },\r\n        (res) => {\r\n            this.isAuth = false\r\n            console.log(res)\r\n        }\r\n    )\r\n}最后放上授权的过程示意图："}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "date": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序bindtap与catchtap的区别 ", "author": "Rolan", "date": "2020-5-26 00:22", "content": "1、bindtap和catchtap的区别(1) 相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分。\r\n(2) 不同点：他们的不同点主要是bindtap是冒泡的，catchtap是非冒泡的。2、例子1、假如有三个view点击事件都是用的bindtap，三个view是层级包含关系?123456789<view id=\"outer\" bindtap=\"out\">    outer view    <view id=\"middle\" bindtap=\"middle\">        middle view        <view id=\"inner\" bindtap=\"inner\">            inner view        </view>    </view></view>　　 2、我么在js里代码是在相对应的事件打印出log，代码如下?out:function(e){\r\n    console.log(\"--out bindtap click\")\r\n}, middle: function (e) {\r\n    console.log(\"--middle bindtap click\")\r\n}, inner: function (e) {\r\n    console.log(\"--inner bindtap click\")\r\n} 3、bindtap执行结果点击out view打印出一条log --> out bindtap click\r\n\r\n点击middle view打印出两条log --> middle bindtap click--out bindtap click\r\n\r\n点击innew view打印出三条log --> inner bindtap click--middle bindtap click--out bindtap click\r\n\r\n可以看出bindtap不阻止向上冒泡，所以点击inner一直冒泡到了最外层。 4、如果我们只修改middle view的bindtap为catchtap点击out view打印出一条log --> out bindtap click（因为没有上层元素故而无法向上冒泡）\r\n\r\n点击middle view打印出一条log --> middle bindtap click（catchtap阻止向上冒泡）\r\n\r\n点击innew view打印出两条log --> inner bindtap click（catchtap阻止向上冒泡）本博客主要记录自己的学习点滴~，文章来源于总结，还有在工作中实际碰到的问题以记录。"}
{"title": "小程序实战(二)-上传多图功能 ", "author": "Rolan", "date": "2020-6-2 00:53", "content": "一、需求说明\r\n\r\n可选取相册照片，可拍照\r\n可选择压缩大小，可选择原图大小\r\n每次最多可选择 5 张图片\r\n\r\n二、需求实现\r\n2.1 选取照片实现\r\n通过调用小程序 api - chooseImage 来实现选取照片功能\r\n// 定义一个变量，用来存储用户选取的图片路径\r\nlet imagePaths\r\nwx.chooseImage({\r\n  count: 5,    // 限制每次最多选择 5 张\r\n  sizeType: ['original', 'compressed'],  // 可选择压缩大小，可选择原图大小\r\n  sourceType: ['album', 'camera'],   // 可选取相册照片，可拍照\r\n  success: res => {   // 选取图片成功的回调函数\r\n    imagePaths = res.tempFilePaths   // 存储选取的图片路径，是个数组\r\n  }\r\n})\r\n复制代码2.2 上传照片实现\r\n// 定义一个变量，用来存储上传成功的图片路径\r\nlet successPaths = []\r\n// wx.uploadFile 接口只能一次上传 1 张图片，所以需要先遍历\r\nimagePaths.forEach((path) => {\r\n  wx.uploadFile({\r\n    url: api.apiRootUrl + '/distribution/addPicture',   // 接口地址\r\n    filePath: path,\t// 当前图片路径\r\n    name: 'file',\r\n    header: { \"Content-Type\": \"multipart/form-data\" }, \r\n    success: res => {\t\t\t\t\t// 上传成功的回调函数\r\n      if (res.code == 200) {\r\n        successPaths.push(res.filePath)\r\n      } else {\r\n        this.showToast({\r\n\t\t\ttitle: res.msg\r\n\t\t  })\r\n      }\r\n      let filePaths = `formData.filePaths`\r\n\t\t// 存储上传成功的图片路径\r\n      this.setData({\r\n        [filePaths]: successPaths\r\n      })\r\n    }\r\n  })\r\n})\r\n复制代码2.3 图片预览实现\r\n<view wx:for=\"{{formData.filePaths}}\" wx:key=\"filePath\">\r\n\t<image src=\"{{filePath}}\"></image>\r\n</view>\r\n复制代码"}
{"title": "DoKit微信小程序研发助手SDK升级 ", "author": "Rolan", "date": "2020-6-10 00:11", "content": "对于小程序开发者和测试同学来说，很多临时性的调试功能需要单独开发去支持，比如查看小程序信息，手机信息以及用户信息，扫码打开页面等。这些功能对于每个小程序都是相似的，而且遇到类似的需求时都需要进行单独开发。DoKit在移动端发展，获得了众多开发者的好评，其中不乏很多一线大厂(阿里，字节，腾讯，百度...)的身影，同时给我们带来了很多宝贵的经验。在广大开发者的要求下，我们重新启动了小程序端sdk的升级.此次版本升级主要提供了数据模拟功能，优化接入流程，降低用户接入成本，更好配合使用原生小程序以及第三方框架开发，提升开发同学的幸福感。简单总结DoKit小程序端调试工具，内置很多常用的工具，避免重复实现，一次接入，你将会拥有强大的工具集合。新增功能演示哆啦A梦小程序端apimock功能演示在我们的 平台端 注册，即可使用该功能，在sdk接入部分会有详细介绍。点击工具中的数据模拟即可进入详情页，其中详情页分为mock数据和上传模板两块功能。mock数据:你可以通过打开指定接口的开关并选择相应的场景,此时你无需改变你的网络请求代码即可对你的指定接口进行拦截并返回你在平台创建的接口数据。上传模板:上传模板功能的适用场景是当你已经有了一个真实的接口，需要针对不同的用户场景进行测试但是同时接口返回的数据量比较庞大，所以我们为你提供了上传模板的功能。当你打开上传模板中指定接口的开关时，我们会拦截并保存你真实接口返回的数据并提供json预览功能。点击上传即可上传你的模板数据到Dokit平台端。原理流程图如下:使用Object.defineProperty()劫持小程序的wx.request(),然后重写次方法，添加上匹配拦截逻辑和上传模板逻辑。在平台端更新接口时，会和小程序本地数据合并，即还原原先在本地操作的记录其他功能app信息用于快速查看手机系统信息，小程序基本信息，用户信息，授权信息等基础信息，避免反复打开手机设置或者调用小程序原生api进行查看。位置模拟用于小程序端位置模拟，包括位置授权，位置查看，位置模拟，恢复位置设置等几大功能，可以通过简单的点击操作实现任意位置模拟和位置还原，该功能的实现原理是通过对wx.getLocation进行方法重写，进而进行位置模拟，位置模拟后，在小程序内所有调用位置查询的方法内都将返回你设定的位置，还原后将恢复原生方法缓存管理一个强大的缓存管理面板，集成了对缓存的所有操作功能，包括设置缓存，清除缓存，更新缓存值等，可以在小程序非常便利的进行缓存管理H5任意门可以通过扫码和粘贴链接的方式在小程序中打开h5页面，操作简单方便更新版本当你的小程序进行代码更新时，为了获取最新的线上包需要重启小程序，该功能可以在你的小程序上通过点击更新操作，直接获取到最新的远程代码资源快速上手如何接入如果您是使用原生小程序的开发方式，请安如下方式接入1. 通过npm安装 npm install dokit-miniapp, 然后从node_modules中将dokit-miniapp文件夹拷贝到自己的项目中，然后按如下方式进行使用\r\n复制代码2. 在需要引用工具的页面 page.json 中引入组件(注意引用的路径)\r\n复制代码\"usingComponents\": {\r\n  \"dokit\": \"../../components/dokit-miniapp/dist/index/index\"\r\n}\r\n复制代码3. 在需要引用工具的页面 page.wxml 中引入使用组件\r\n<dokit projectId=\"your projectId\"></dokit>\r\n复制代码如果您是使用小程序第三方框架的开发方式，可以做如下优化，在所需引入页面的js中，添加变量声明，例如\r\nconst isProd = process.env.NODE_ENV === '\"production\"'\r\n复制代码在<template></template>或者是render函数中，可以使用\r\n\r\nisProd ? '' : <dokit projectId=\"your projectId\"></dokit>\r\n复制代码如果框架暴露了webpack的相关打包配置，可以按照这样的配置，优化资源打包\r\ncompile: {\r\n      exclude: [\r\n        path.resolve(__dirname, '..', 'src/components/dokit-miniapp')\r\n      ]\r\n    }\r\n复制代码Tip: 1.由于微信小程序暂不支持开发环境和生产环境判断，请在生产环境手动删掉引用Tip: 2.第三方框架开始，要注意框架是否将process.env.NODE_ENV注入到的全局变量中，此外有的框架的兼容性并不友好，有些打包配置并没有支持，开发者要视情况而定。"}
{"title": "小程序canvas绘制圆形微信头像 ", "author": "Rolan", "date": "2020-6-16 00:52", "content": "提醒：canvas画布绘画图片的时候，图片不能是互联网图片，必须是本地图片才可以正常绘制。\r\n第一步：获取用户授权，下载微信头像图片到本地。pleaseSign: function(event) {    wx.getSetting({\r\n      success(res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n          wx.getUserInfo({\r\n            success: function(res) {\r\n              let userInfo = res.userInfo;\r\n              let userImage = userInfo.avatarUrl;\r\n              wx.downloadFile({\r\n                url: userImage,\r\n                success(wr) {\r\n                  let userName = userInfo.nickName;\r\n                  app.gData.userName = userName;\r\n                  app.gData.userImage = wr.tempFilePath;\r\n                  wx.navigateTo({\r\n                    url: '../sign/sign'\r\n                  });\r\n                }\r\n              });\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n获取用户头像信息之后，跳转到绘制页面，在绘制页面完成绘画操作。\r\n第二步：绘制用户头像。finish: function() {    const ctx = wx.createCanvasContext('shareCanvas');\r\n    let that = this;\r\n    ctx.drawImage(app.gData.BG, 0, 0, 600, 1066);\r\n    ctx.stroke();\r\n\r\n    ctx.save();\r\n    // 绘制第一个圆 \r\n    ctx.beginPath();\r\n    //圆心x、y的坐标，半径，起始角，结束角，顺时针画\r\n    ctx.arc(30 + that.data.xp - 70, 30 + that.data.yp - 30, 30, 0, Math.PI * 2, false);\r\n    //将圆形剪切\r\n    ctx.clip();\r\n    //再画一个不存在的圆，避免画出来的微信头像有个黑圆圈\r\n    ctx.beginPath();\r\n    ctx.arc(0, 0, 0, 0, Math.PI * 2, false);\r\n    ctx.drawImage(app.gData.userImage, that.data.xp - 70, that.data.yp - 30, 60, 60);\r\n    ctx.stroke();\r\n    ctx.restore();\r\n\r\n    ctx.setTextAlign('left');\r\n    ctx.font = 'bold 25px 楷体';\r\n    ctx.setFillStyle(app.gData.fontColor);\r\n    ctx.fillText(app.gData.userName, that.data.xp, that.data.yp + 10);\r\n    ctx.stroke();\r\n    ctx.draw(false, function () {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: 600,\r\n        height: 1066,\r\n        destWidth: 600,\r\n        destHeight: 1066,\r\n        canvasId: 'shareCanvas',\r\n        success: function (res) {\r\n          // 获得图片临时路径\r\n          app.gData.temp = res.tempFilePath;\r\n          app.gData.change = true;\r\n          wx.navigateBack();\r\n        }\r\n      });\r\n    });\r\n    \r\n  }\r\n\r\n注意：在绘制用户头像之前一定要调用save方法，绘制以后调用restore方法，否则你的绘制除了头像会成功画出来，其它绘画图片或者文字会出不来。"}
{"title": "微信小程序的引导页实现代码 ", "author": "Rolan", "date": "2020-6-25 00:19", "content": "前一段时间写了一个微信小程序的项目，其中就有引导页面这一功能模块，接下来给大家说一下这一块的怎么实现的以及一个思路吧！一、引导页下给大家康康效果图是啥样舍的呢！！其实就是和轮播图差不多，就是当用户滑动到最后一页的时候显示跳转页面就完事了。二、代码分析第一步：先找到小程序目录下面的app.json然后在“pages”配置好页面{\r\n\t\"pages\": [\r\n\t\t\"pages/guidance/guidance\", // 配置引导页面\r\n\t\t\"pages/index/index\",  // 这是跳转以后的Home页面\r\n\t],\r\n}这是在小程序的pages的目录里面就得到了第二步：接下来在guidance.json里面进行小程序页面header的配置{\r\n \"usingComponents\": {},\r\n \"navigationStyle\": \"custom\"\r\n}注释一下：Navigation是小程序的顶部导航组件，当页面配置navigationStyle设置为custom的时候可以使用此组件替代原生导航栏。第三步： 在guidance.wxml里面写代码 在这里我就把轮播也给大家分享一下<swiper class=\"banner_box\" bindchange=\"fike\" indicator-dots=\"{{true}}\" indicator-active-color='#fff'>\r\n\r\n <swiper-item class=\"img_b\" wx:for=\"{{ banners }}\" wx:key=\"id\">\r\n\r\n  <image class=\"img_log\" src=\"{{item.picUrl}}\"></image>\r\n\r\n </swiper-item>\r\n\r\n</swiper>\r\n<!-- button按钮 -->\r\n<view class=\"skip\" bindtap=\"skip\">\r\n\t<!-- 可以更据guidance.js 下标判断到最后一页显示button按钮点击跳转 -->\r\n\t<button bindtap=\"getIndex\" wx:if=\"{{ swiperCurrent+1 == swiperMaxNumber }}\">跳过</button>\r\n\r\n</view>注释：swiper：1、在小程序中只能当作滑块视图容器。2、其中只可放置swiper-item组件，否则会导致未定义的行为。bindchange：current 改变时会触发 change 事件，event.detail = {current, source}indicator-dots：是否显示面板指示点indicator-active-color='#fff'：当前选中的指示点颜色swiper-item：仅可放置在swiper组件中，宽高自动设置为100%。属性类型默认值必填说明item-idstring否该 swiper-item 的标识符微信官方文档链接： https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html第四步:是不是改写样式了.banner_box {\r\n\twidth: 100%;\r\n\theight: 100vh;\r\n\tposition: relative;\r\n}\r\n.img_b,.img_log {\r\n\twidth: 100%;\r\n\theight: 100%;\r\n}\r\n.skip{\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tright: 0;\r\n\tbottom: 86rpx;\r\n}\r\nbutton {\r\n\twidth: 185rpx;\r\n\theight: 67rpx;\r\n\tfont-size: 28rpx;\r\n\tline-height: 67rpx;\r\n\tbackground-color: #32CD32;\r\n\tcolor: #fff;\r\n}第五步： js逻辑操作// 这里是我当时引入的封装好的接口\r\nconst wxapi = require('../../api/urls.js');\r\n\r\n// pages/guidance/guidance.js\r\nPage({\r\n\t/**\r\n\t * 页面的初始数据\r\n\t */\r\n\tdata: {\r\n\t\tbanners:[], // 轮播\r\n\t\tswiperCurrent: 0, // 引导页的下标 0\r\n\t\tswiperMaxNumber: 3 // 引导页的下标 3\r\n\t},\r\n\tfike(e) {\r\n\t\tthis.setData({\r\n\t\t\tswiperCurrent: e.detail.current\r\n\t\t});\r\n\t},\r\n\t/**\r\n\t * 生命周期函数--监听页面加载\r\n\t */\r\n\tonLoad: function (options) {\r\n\t\tvar arr = [];\r\n// 在这里进行数据请求\r\n\t\twxapi.banners().then( res => {\r\n\t\t\tres = res.data;\r\n\t\t\tres.forEach(item =>{\r\n\t\t\t\tif (item.type == 'app') {\r\n\t\t\t\t\tarr.push(item)\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t// 把数据更新到页面上\r\n\t\t\tthis.setData({\r\n\t\t\t\tbanners:arr\r\n\r\n\t\t\t})\r\n\t\t})\r\n\t},\r\n\tgetIndex() {\r\n\t// wx.switchTab():跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面，\r\n\t//这里的tabBar是底下的导航栏指定的页面，\r\n\t\twx.switchTab({\r\n\t\t\turl:\"/pages/index/index\"\r\n\t\t})\r\n\t},\r\n})accomplish到此这篇关于微信小程序的引导页实现代码的文章就介绍到这了,更多相关微信小程序的引导页内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！"}
{"title": "微信小程序 chooseImage选择图片或者拍照 ", "author": "Rolan", "date": "2020-6-30 00:57", "content": "一、使用API wx.chooseImage(OBJECT)var util = require('../../utils/util.js')\r\nPage({\r\n  data:{\r\n    src:\"../image/pic4.jpg\"\r\n  },\r\n  gotoShow: function(){var _this = this\r\n    wx.chooseImage({\r\n     count: 9, // 最多可以选择的图片张数，默认9\r\n     sizeType: ['original', 'compressed'], // original 原图，compressed 压缩图，默认二者都有\r\n     sourceType: ['album', 'camera'], // album 从相册选图，camera 使用相机，默认二者都有\r\n     success: function(res){\r\n      // success\r\n      console.log(res)\r\n      _this.setData({\r\n        src:res.tempFilePaths\r\n      })\r\n     },\r\n     fail: function() {\r\n      // fail\r\n     },\r\n     complete: function() {\r\n      // complete\r\n     }\r\n    })\r\n  }\r\n二、图片路径进行数据绑定<view class=\"container\">\r\n <view>\r\n  <button type=\"default\" bindtap=\"gotoShow\" >点击上传照片</button>\r\n </view>\r\n <view>\r\n  <image class= \"show-image\" mode=\"aspectFitf\" src=\"{{src}}\"></image>\r\n </view>\r\n</view>\r\n号外：　　1、wx.chooseImage 调用相机或相册　　2、<image class= \"show-image\" mode=\"aspectFitf\" src=\"{{src}}\"></image> 数据绑定　　3、js中动态修改文件路径 var _this = this\r\n    wx.chooseImage({\r\n     count: 9, // 最多可以选择的图片张数，默认9\r\n     sizeType: ['original', 'compressed'], // original 原图，compressed 压缩图，默认二者都有\r\n     sourceType: ['album', 'camera'], // album 从相册选图，camera 使用相机，默认二者都有\r\n     success: function(res){\r\n      // success\r\n      console.log(res)\r\n      _this.setData({\r\n        src:res.tempFilePaths\r\n      })\r\n     },\r\n     fail: function() {\r\n      // fail\r\n     },\r\n     complete: function() {\r\n      // complete\r\n     }\r\n感谢阅读，希望能帮助到大家，谢谢大家对本站的支持！"}
{"title": "微信小程序在ios中下拉出现“橡皮筋”效果 ", "author": "Rolan", "date": "2020-7-15 00:22", "content": "今天和大家聊一聊微信小程序在ios中下拉出现“橡皮筋”效果问题现象话不多说，先看代码（使用taro编写）。代码很简单，一个flex的容器+一个允许进行下拉刷新的ScrollView，就组成了一个最简democonst TicketRecordsPage = () => {\r\n  const revenueData = new Array(10).fill(0).map((_, i) => i)\r\n  return (\r\n    <View className={styles['root']}>\r\n      <View >title</View>\r\n      <View className={styles['container']}>\r\n        <ScrollView className={styles['viewer']} scrollY enableFlex\r\n          refresher-enabled={true} lower-threshold={100} >\r\n          {\r\n            revenueData.map((x) => {\r\n              return <View>{x}</View>\r\n            })\r\n          }\r\n        </ScrollView>\r\n      </View>\r\n    </View >\r\n  );\r\n}.root {\r\n  width: 100vw;\r\n  height: 100vh;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n\r\n  .container {\r\n    flex: 1;\r\n    min-height: 0;\r\n    max-height: 100%;\r\n    position: relative;\r\n    width: 100%;\r\n\r\n    .viewer {\r\n      position: absolute;\r\n      top: 0;\r\n      left: 0;\r\n      height: 100%;\r\n    }\r\n\r\n  }\r\n}\r\n\r\nView {\r\n  width: 100%;\r\n  height: 100px;\r\n  border: 1px solid black;\r\n  text-align: center;\r\n  line-height: 100px;\r\n}下面两个视频，一个是在安卓上运行的效果，一个是在ios上运行的效果 可以看到，在安卓上下拉是符合预期的，但是在iso上，拖动特定区域就会出现title框也跟着偏移的“橡皮筋”效果。原因及解决方案为什么ios会有这样的现象呢？查看资料发现，这个回弹效果是ios的UIWebView组件的特性。而小程序利用了移动端的原生组件，所以继承了这种特性在ios 5.x+可以使用下面的方式进行处理WebView.scrollView.bounces = NO;\r\n而对于小程序，官网提供了页面配置项disableScroll=false进行禁止。当然，目前大部分同学可能使用的是taro进行小程序开发（例如我文中的例子）。在taro中，可以对页面组件设置一个config属性，从而实现页面配置。 TicketRecordsPage.config = {\r\n   disableScroll: true\r\n }\r\n这样，ios上就可以获得和安卓上等同的下拉效果了"}
{"title": "小程序子组件修改properties问题 ", "author": "Rolan", "date": "2020-7-22 00:32", "content": "如何修改,子组件中来自父页面,传递进来properties数据问题?\r\n\r\n在日常开发中,相信经常会有很多人遇到要自己手动封装一个弹窗的时候,这个弹窗需要由父组件来控制显示,也就是从父组件传递一个变量 isHidden 进子组件,子组件在 properties 中接受,\r\n注意: 子组件的properties 一般都是单项数据流,子组件不能,修改来来自父组件的数据,\r\n这样就有个问题了,有时候,当你想在子组件中 控制自身弹窗 的 显示 和 隐藏 就没办法做到了,只能靠子组件向父组件通讯,利用时间triggerEvent来通知父组件修改 isHidden ,这样就很麻烦了, 冗余了很多函数;\r\n\r\n没办法做到自身关闭自身\r\n\r\n那么如何不用子父通讯来达到效果呢?\r\n请看代码:\r\n//  父组件\r\npage({\r\n data:{\r\n       iShidden:false  //传递给 子组件\r\n  }\r\n}})\r\n------------------------------------------------------\r\n// 子组件\r\nComponent({\r\n  properties: {\r\n    iShidden: {\r\n      type: Boolean,\r\n      value: true, //true 就隐藏 false 就显示\r\n    }\r\n  },\r\n  methods:{\r\n      //当点击关闭时\r\n      onTap:function(){\r\n       // 获取页面总栈\r\n        let pages = getCurrentPages();\r\n         //currPage 就是当前的页面,这样就获取到了当前页面的实例   \r\n        let currPage  = pages[pages.length - 1];  //    [  page.length-1 ]是当前页,  [pages.length - 2]上一页, 以此类推\r\n       // 接下来就是骚操作的时候了\r\n          currPage.setData({ iShidden:true});\r\n         // 拿到页面实例,就意味着,你可以在当前页面操作其他页面的数据, 调用函数等....\r\n      }\r\n  }\r\n})\r\n\r\n是不是觉得很骚呢?\r\n有了这个方法,你甚至可以颠覆 以往 vue,小程序 中的 子父组件通讯的规则;\r\n可以通过  currPage 页面实例,将子组件中的值, 给设置到任意其他页面去, 再也不用通过 triggerEvent去传了\r\n的确是很骚的一个操作,  不过像这种邪门歪道偶尔用用就好啦, 为啥?\r\n从一开始, 各类框架,各类状态库,就强调了,  单向数据源的理念, vuex的统一数据源,有mutation , ,都是有一个单向数据流理念在,  如果没有单向数据,任何地方的修改,都会让你的数据不稳定,你不知道何时会被修改,导致各种 问题 bug,\r\n所以尽量减少使用这样的方法setData"}
{"title": "原生小程序架构及同构方案 ", "author": "Rolan", "date": "2020-7-23 00:14", "content": "前言最近实习中参与了H5项目向小程序迁移的工作，在微信官方文档和一些帖子上学习了小程序运行机制和底层原理，以及与Web页面的区别，在此基础上又看了一些关于小程序同构方案的内容。以下是我个人的一些学习总结。本文内容参考微信开放文档如何理解小程序的运行机制小程序多平台同构方案小程序是什么？在小程序诞生前，微信团队开发的JS-SDK使web开发者可以通过暴露的API使用微信原生能力去完成一些事，如调用接口打开微信支付等。针对移动端设备网络状态不稳定导致的白屏问题，微信又推出增强版JS-SDK，也就是“微信 Web 资源离线存储”，但在复杂的页面上依然会出现白屏的问题，原因表现在页面切换的生硬和点击的迟滞感。这个时候需要一个JS-SDK处理不了的，使用户体验更好的一个系统，即小程序。小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。其本质是运行在webview上的H5应用，但与H5又有着本质上的不同。H5可以理解为运行在移动端的web页面，本质还是由HTML+CSS+JS构成的web应用。小程序和H5的区别也就是小程序和网页的区别。小程序与普通网页开发的区别小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。网页开发的渲染和脚本执行是在同一个线程上执行的，这也是网页脚本长时间运行有可能会导致页面失去响应的原因；而小程序的视图层和逻辑层是完全分离在两个不同的线程上执行开发网页时我们可以在JS代码中通过Dom API对节点进行各种操作，通过window对象实现原生事件响应、页面跳转；由于小程序的JS代码运行在JSCore,与渲染层分离，所以在逻辑层中无法获得Dom和Bom，从而无法使用各种Dom API网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具小程序架构渲染机制处于性能和实现的考虑，小程序采用 Hybrid渲染机制 ，这样做有几点好处：扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力体验更好，同时也减轻 WebView 的渲染工作绕过 setData、数据通信和重渲染流程，使渲染性能更好用客户端原生渲染内置一些复杂组件，可以提供更好的性能架构如下图所示，原生小程序框架采用双线程模型：视图层和逻辑层完全分离为两个不同的线程。每个页面的渲染在一个webview线程上执行，视图层包含多个webview线程，而逻辑层则统一在JSCore上执行。这样做的目的是防止逻辑层对Dom和window的操作（如跳转到外部页面），使整个应用变得安全可控。逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程JSBridge 起到架起上层开发与Native（微信系统）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验视图层和逻辑层的通信双线程模型下，逻辑层代码无法直接操作Dom，逻辑层和视图层的数据传输（setData）是通过两边的evaluateJavaScript实现的。用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。小程序多端同构方案很多企业都有自己的小程序平台，如微信、支付宝、头条等，如今市面上很多产品都是基于React、Vue等框架开发的web应用，但web端代码是不可能运行在小程序平台上的（详见上述小程序和web应用的不同），而开发几套代码的时间和维护成本又太高，为了节省学习和开发成本，各大公司都推出了自己的多端小程序方案，使开发者可以用React、Vue框架来开发小程序。类似框架有微信的Kbone、阿里的Remax、京东的Taro等。Taro是在编译时将代码适配到小程序平台，而Kbone和Remax则是在运行时完成这个工作。以下重点解释 Kbone 和 Remax 。Kbone参照微信官方文档，Kbone在适配层里模拟出了浏览器环境，让 Web 端的代码可以不做什么改动便可运行在小程序里。kbone实现原理是在worker线程适配了一套JS Dom API，上层不管是哪种前端框架(react、vue)或原生JS最终都需要调用JS Dom API操作 dom，适配的 JS Dom API则接管了所有的Dom操作，并在内存中维护了一棵Dom tree，所有上层最终调用的Dom操作都会更新到这棵Dom tree中，每次操作(有节流)后会把Dom tree同步到webview线程中，通过wxml自定义组件进行 render。Remax与Kbone上层支持多种框架（React、Vue、Angular）不同，Remax专门实现React应用向小程序的适配。Remax实现原理是在worker线程维护一棵虚拟Dom tree,这棵虚拟Dom tree会通过小程序原生的setData方法映射到render线程，render层再把虚拟Dom tree进行遍历然后渲染。Remax和kbone类似，都是在 worker 线程维护一棵Dom tree，再把这棵 Dom tree传到render线程进行渲染，唯一的区别是remax dom tree发生变化时，会计算差异，而不需要把整棵树都传到render线程，此功能是react提供的，就是在 diff 完后找出差异，则把差异传到render线程总结Kbone和Remax实现原理基本相同，都在worker线程维护虚拟Dom tree,再把虚拟Dom tree传到render线程渲染二者主要有两点不同：Kbone上层支持多种框架，而Remax仅支持React；Remax的Dom tree发生变化时会计算diff，把diff映射到render线程，而Kbone是将整个Dom tree传过去"}
{"title": "开发微信小程序，我为什么放弃 setData，使用 upData ", "author": "Rolan", "date": "2020-7-23 00:22", "content": "鉴于在下使用微信小程序开发时使用 setData 的蹩脚体验，开发了个库函数 wx-updata，项目上线之后，我把这个自用的库函数整理放到 Github 上开源出来 wx-updata，这个库函数在开发的时候对我很有帮助，希望也可以帮到大家 \r\n如果大家在使用中遇到了问题，可以给我提 pr，提 issue，一起来改善小程序开发体验加油～\r\n\r\nwx-updata 版本 0.0.10\r\nGithub 地址： github.com/SHERlocked9…\r\n小程序代码片段预览地址： developers.weixin.qq.com/s/CcXdO1mc7…\r\n小程序代码片段代码地址： github.com/SHERlocked9…\r\n\r\n1. setData 不方便的地方\r\n你在使用 setData 的时候，是不是有时候觉得很难受，举个简单的例子：\r\n// 你的 data\r\ndata: {\r\n    name: '蜡笔小新',\r\n    info: { height: 140, color: '黄色' }\r\n}\r\n复制代码如果要修改 info.height 为 155，使用 setData 要怎么做呢：\r\n// 这样会把 info 里其他属性整不见了\r\nthis.setData({ info: { height: 155 } })\r\n\r\n// 你需要取出 info 对象，修改后整个 setData\r\nconst { info } = this.data\r\ninfo.height = 155\r\nthis.setData({ info })\r\n复制代码似乎并不太复杂，但如果 data 是个很大的对象，要把比较深且不同的对象、数组项挨个改变：\r\ndata: {\r\n    name: '蜡笔小新',\r\n    info: {\r\n        height: 140, color: '黄色',\r\n        desc: [{ age: 8 }, '最喜欢大象之歌', '靓仔', { dog: '小白', color: '白色' }]\r\n    }\r\n}\r\n复制代码比如某个需求，需要把 info.height 改为 155，同时改变 info.desc 数组的第 0 项的 age 为 12，第 3 项的 color 为灰色呢？\r\n// 先取出要改变的对象，改变数字后 setData 回去\r\nconst { info } = this.data\r\ninfo.height = 155\r\ninfo.desc[0].age = 12\r\ninfo.desc[3].color = '灰色'\r\nthis.setData({ info })\r\n\r\n// 或者像某些文章里介绍的，这样可读性差，也不太实用\r\nthis.setData({\r\n    'info.height': 155,\r\n    'info.desc[0].age': 12,\r\n    'info.desc[3].color': '灰色'\r\n})\r\n复制代码上面这两种方法，是我们平常小程序里经常用的，和其他 Web 端的框架相比，就很蹩脚，一种浓浓的半成品感扑面而来，有没有这样一个方法：\r\nthis.upData({\r\n    info: {\r\n        height: 155,\r\n        desc: [{ age: 12 }, , , { color: '灰色' }]\r\n    }\r\n})\r\n复制代码这个方法会帮我们深度改变嵌套对象里对应的属性值，跳过数组项里不想改变的，只设置我们提供了的属性值、数组项，岂不是省略了一大堆蹩脚的代码，而且可读性也极佳呢。\r\n这就是为什么我在上线的项目中使用 wx-updata，而不是 setData\r\n2. wx-updata 的优点\r\n\r\n支持 setData 对象自动合并，不用写蹩脚的对象路径了 \r\n支持对象中嵌套数组，数组中嵌套对象；\r\n如果数组的某个值你不希望覆盖，请使用数组空位来跳过这个数组项，比如 [1,,3] 这个数组中间就是数组空位；\r\n如果数组空位你的 Eslint 报错，可以使用 wx-updata 提供的 Empty 来代替： [1, Empty, 3]\r\n\r\n3. wx-updata 安装\r\n\r\n你也可以直接把 dist 目录下的 wx-updata.js 拷贝到项目里使用\r\n\r\n使用 npm、yarn 安装方式：\r\n$ npm i -S wx-updata\r\n# or\r\n$ yarn add wx-updata\r\n复制代码然后：\r\n\r\n把微信开发者工具面板右侧的 详情 - 本地设置 - 使用npm模块 按钮打开；\r\n点击微信开发者工具面板工具栏的 工具 - 构建npm；\r\n\r\n构建后成功生成 miniprogram_npm 文件夹就可以正常使用了\r\n4. wx-updata 使用方法\r\n使用方式一\r\n可以使用直接挂载到 Page 上的方式，这样就可以在 Page 实例中像使用 setData 一样使用 upData 了\r\n// app.js\r\nimport { updataInit } from './miniprogram_npm/wx-updata/index'  // 你的库文件路径\r\n\r\nApp({\r\n    onLaunch() {\r\n        Page = updataInit(Page, { debug: true })\r\n    }\r\n})\r\n复制代码// 页面代码中\r\n\r\nthis.upData({\r\n    info: { height: 155 },\r\n    desc: [{ age: 13 }, '帅哥'],\r\n    family: [, , [, , , { color: '灰色' }]]\r\n})\r\n复制代码使用方式二\r\n有的框架可能在 Page 对象上进行了进一步修改，直接替换 Page 的方式可能就不太好了，wx-updata 同样暴露了工具方法，用户可以在页面代码中直接使用工具方法进行处理：\r\n// 页面代码中\r\n\r\nimport { objToPath } from './miniprogram_npm/wx-updata/index'  // 你的库文件路径\r\n\r\nPage({\r\n    data: { a: { b: 2}, c: [3,4,5]},\r\n\r\n    // 自己封装一下\r\n    upData(data) {\r\n        return this.setData(objToPath(data))\r\n    },\r\n\r\n    // 你的方法中或生命周期函数\r\n    yourMethod() {\r\n        this.upData({ a: { b: 7}, c: [8,,9]})\r\n    }\r\n})\r\n复制代码使用 Empty 代替数组空位\r\n可以使用 wx-updata 提供的 Empty 来代替数组空位，由于 Empty 本质上是一个 Symbol，所以只能使用 wx-updata 导出的，而不能自己新建。\r\n// 页面代码中\r\nimport { Empty } from './miniprogram_npm/wx-updata/index'\r\n\r\nthis.upData({\r\n    info: { height: 155 },\r\n    desc: [{ age: 13 }, '帅哥'],\r\n    family: [Empty, Empty, [Empty, Empty, Empty, { color: '灰色' }]]\r\n})\r\n复制代码5. wx-updata 相关 API\r\nPage.prototype.upData(Object data, Function callback)\r\n\r\ndata： 你希望设置的 data\r\ncallback： 跟 setData 第二个参数一样，引起界面更新渲染完毕后的回调函数\r\n\r\nupdataInit(Page, config)\r\n\r\nPage： 页面对象，需要在 app.js 中调用；\r\nconfig： 若提供配置参数 { debug: true }，会将路径化后的 data 打印出来，帮助用户进行调试；\r\n\r\nobjToPath(Object data)\r\n\r\ndata： 你希望设置的 data 对象\r\n\r\n\r\n网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~\r\n\r\n参考文档：\r\n\r\n小程序开发实用技巧——扩展 Page 页面对象 - 掘金\r\n\r\n\r\nPS：本人博客地址 Github - SHERlocked93/blog，也欢迎大家关注我的公众号【前端下午茶】，一起加油吧~"}
{"title": "小程序实现简单语音聊天 ", "author": "Rolan", "date": "2020-7-24 00:21", "content": "框架相关Demo采用Mpvue框架，后端的WebSocket采用Node.js，文件服务器直接使用的微信小程序的云开发的存储。储备知识微信小程序录音控制器：recorderManager。微信小程序音频控制器：innerAudioContext。微信小程序WebSocket。Node.js端WebScoket实现// 基于WS插件\r\n\r\n// 引入ws插件\r\nvar WebSocketServer = require(\"ws\").Server;\r\n// 实例化WebSocket\r\nvar wss = new WebSocketServer({ port: 9090 });\r\n// 初始化客户端数组\r\nvar clients = [];\r\n\r\n// 建立链接监听\r\nwss.on('connection', function (ws) {\r\n  clients.push(ws);\r\n  ws.on(\"message\", function (message) {\r\n    clients.forEach(function (ws1) {\r\n      if (ws1 !== ws) {\r\n        ws1.send(message)\r\n      }\r\n    })\r\n  })\r\n})\r\n\r\n// 建立链接关闭监听\r\nws.on(\"close\", function (message) {\r\n  clients = clients.filter(function (ws1) {\r\n    return ws1 !== ws\r\n  })\r\n})小程序端实现html<div>\r\n  <button @click=\"palyAudio(value)\" v-for=\"(value,index) in chatContent\" :key=\"index\">)))))</button>\r\n  <button class=\"botom-button\" @touchstart=\"startRecord\" @touchend=\"stopRecord\">输入语音</button>\r\n</div>jsexport default {\r\n  data() {\r\n    return {\r\n      // 存储聊天记录\r\n      chatContent: [],\r\n      // 录音控制器\r\n      recorderManager: null,\r\n      // 音频控制器\r\n      innerAudioContext: null\r\n    };\r\n  },\r\n  methods: {\r\n    // 按下按钮开始录音\r\n    startRecord() {\r\n      this.recorderManager.start({\r\n        format: \"mp3\"\r\n      });\r\n    },\r\n    // 松开按钮停止录音\r\n    stopRecord() {\r\n      this.recorderManager.stop();\r\n    },\r\n    // 播放录音\r\n    palyAudio(value) {\r\n      this.innerAudioContext.src = value;\r\n      this.innerAudioContext.play();\r\n    }\r\n  },\r\n  created() {\r\n    this.recorderManager = wx.getRecorderManager();\r\n    this.innerAudioContext = wx.createInnerAudioContext();\r\n    // 监听录音开始\r\n    this.recorderManager.onStart(res => {\r\n      console.log(\"recordStart\");\r\n    });\r\n    // 监听录音结束\r\n    this.recorderManager.onStop(res => {\r\n      const audioName = new Date().getTime() + \".mp3\";\r\n      // 上传录音文件\r\n      wx.cloud.uploadFile({\r\n        cloudPath: audioName,\r\n        filePath: res.tempFilePath,\r\n        success: upload => {\r\n          this.chatContent.push(upload.fileID);\r\n          // 通过websocket传递录音连接\r\n          wx.sendSocketMessage({\r\n            data: upload.fileID\r\n          });\r\n        }\r\n      });\r\n    });\r\n    // 建立websocket链接\r\n    wx.connectSocket({\r\n      url: \"ws://yoursiteandeport\",\r\n      success: res => {\r\n        console.log(\"success\", res);\r\n      },\r\n      fail: err => {\r\n        console.log(\"error\", err);\r\n      }\r\n    });\r\n    // websocket消息监听 \r\n    wx.onSocketMessage(data => {\r\n      console.log(data);\r\n      this.chatContent.push(data.data);\r\n    });\r\n  }\r\n};结论主要通过WebSocket完成实时通讯通过微信小程序提供的API完成语音的录入和输出通过文件服务器上传语音文件"}
{"title": "小程序接入内容审查接口(图片.文字) ", "author": "Rolan", "date": "2020-7-24 00:33", "content": "今天不知咋回事使用easywechat的内容安全api,不知咋回事.之前还可以使用的这些天突然报这个错,也不知道是不是因为升级还是与其他的冲突,那怎么办呢,还是用下原生的接口,在这里我获取的token方法还是easywechat的方式$miniProgram = ZFac::miniProgram($this->config);\r\n$token = $miniProgram->access_token->getToken()['access_token'];具体的代码如下use EasyWeChat\\Factory as ZFac;\r\n\r\npublic function __construct ( Request $request = null ){\r\n        $this->config = [\r\n            'app_id' => 'wx412****d45a65',\r\n            'secret' => '082dec1*****985b93d286c093e01',\r\n            // 下面为可选项\r\n            // 指定 API 调用返回结果的类型：array(default)/collection/object/raw/自定义类名\r\n            'response_type' => 'array',\r\n            'log' => [\r\n                'level' => 'debug',\r\n                'file' => __DIR__.'/log/wechat.log',\r\n            ],\r\n        ];\r\n}\r\n \r\n  //文字验证\r\n  $miniProgram = ZFac::miniProgram($this->config);\r\n  $token = $miniProgram->access_token->getToken()['access_token'];\r\n  // $result = $miniProgram->content_security->checkText($data['content']);\r\n  $result = $this->z_msgSecCheck($token,$data['content']);\r\n  if($result['errcode']!='0'){\r\n  return jserror('内容含有非法关键词');die;\r\n  }\r\n  \r\n            \r\n//图片验证\r\n public function upload_pic(){\r\n        $file = request()->file('file');\r\n        $info = $file->validate(['ext'=>config()['web']['file_ext']])->move('./public/upload/admin/file');\r\n        $getSaveName = str_replace('\\\\', '/', $info->getSaveName());//win下反斜杠替换成斜杠\r\n        $msg = 'http://'.$_SERVER['SERVER_NAME'].'/public/upload/admin/file/'.$getSaveName;\r\n         if(is_file('./public/upload/admin/file/'.$getSaveName)){\r\n          //验证图片\r\n            $miniProgram = ZFac::miniProgram($this->config);\r\n            $token = $miniProgram->access_token->getToken()['access_token'];\r\n            $result = $this->z_imgSecCheck($token,'./public/upload/admin/file/'.$getSaveName);\r\n            // $miniProgram = ZFac::miniProgram($this->config);\r\n            // $result = $miniProgram->content_security->checkImage('./public/upload/admin/file/'.$getSaveName);\r\n            if($result['errcode']!='0'){\r\n              return '非法图片';\r\n            }else{\r\n              return $msg;\r\n            }\r\n        }else{\r\n            return '0';\r\n        }\r\n    }核心/*微信文字敏感内容检测*/\r\n    public function z_msgSecCheck($token,$msg)\r\n    {\r\n        $checkContent = $msg;\r\n        $url = 'https://api.weixin.qq.com/wxa/msg_sec_check?access_token='. $token;\r\n        $data = json_encode(array('content'=>$checkContent),JSON_UNESCAPED_UNICODE);\r\n        $ch = curl_init();\r\n        curl_setopt($ch, CURLOPT_HEADER, FALSE);\r\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n        curl_setopt($ch, CURLOPT_URL,$url); // url\r\n        curl_setopt($ch, CURLOPT_POST, TRUE);\r\n        curl_setopt($ch, CURLOPT_POSTFIELDS, $data); // json数据\r\n        $res = curl_exec($ch); // 返回值\r\n        curl_close($ch);\r\n        $result = json_decode($res,true);\r\n        return $result;\r\n    }\r\n  /*微信图片敏感内容检测*/\r\n    public function z_imgSecCheck($token,$path)\r\n    {\r\n        // $path = './public/upload/admin/file/'.$getSaveName;\r\n        $url = \"https://api.weixin.qq.com/wxa/img_sec_check?access_token=$token\";\r\n        $curl = curl_init();\r\n        curl_setopt($curl, CURLOPT_SAFE_UPLOAD, true);\r\n        $data = array('media' => new \\CURLFile(realpath($path)));\r\n        curl_setopt($curl, CURLOPT_URL, $url);\r\n        curl_setopt($curl, CURLOPT_POST, 1 );\r\n        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);\r\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($curl, CURLOPT_USERAGENT,\"TEST\");\r\n        $result = curl_exec($curl);\r\n        $error = curl_error($curl);\r\n        return json_decode($result,true);\r\n    }高颜值后台管理系统免费使用 ### 子枫后台管理系统 ###，可在宝塔面板直接安装欢迎关注我的公众号：子枫的奇妙世界，获得独家整理的学习资源和日常干货推送。如果您对我的其他专题内容感兴趣，直达我的个人博客：www.wangmingchang.com"}
{"title": "一文看懂：小程序分享到朋友圈[建议收藏] ", "author": "Rolan", "date": "2020-7-24 00:55", "content": "近日小程序支持分享到朋友圈的消息可以说是小程序开发圈的一个重磅炸弹，转转小程序团队也在收到微信邀请后第一时间进行了调研，并对转转小程序迅速进行了能力支持，本文将全面解读微信此项能力。概述此项能力其实分成两个模块：1、小程序分享到朋友圈能力2、朋友圈打开小程序的能力分享到朋友圈的样式朋友圈里面打开的样式开发我们也分两个模块来看：1、小程序分享到朋友圈能力在小程序界面显示分享到朋友圈按钮的能力，目前要求如下：1.安卓平台：要求微信版本7.0.16及以上，基础库2.11.13及以上，笔者在测试中发现，此项能力也跟机型有关，目前发现OPPO一款机型无分享到朋友圈按钮，小米机型均有此项能力。2.IOS平台：目前还不支持此项能力，但高版本微信支持朋友圈打开小程序能力（下文述）小程序页面默认不开启分享到朋友圈按钮，除非代码中主动设置：1.页面需设置允许“发送给朋友”，代码示例：onShareAppMessage() {\r\n    return {\r\n      title: '买卖二手，省钱又赚钱！转转，一个帮你赚钱的网站！',\r\n      path: '/pages/index/index',\r\n      imageUrl:'https://pic5.zhuanstatic.com/zhuanzh/n_v2be00a9c4aa4941bf8567f5fd999e2709.png',\r\n    }\r\n}\r\n复制代码2.页面需设置允许“分享到朋友圈”，代码示例：onShareTimeline() {\r\n  return {\r\n    title: '[小程序] 买卖二手，省钱又赚钱！转转，一个帮你赚钱的网站！',\r\n    query: 'zzfrom=pyq'\r\n  }\r\n}\r\n复制代码3.开启分享菜单中的“分享到朋友圈”按钮：wx.showShareMenu({\r\n      withShareTicket: true,\r\n      menus: ['shareAppMessage', 'shareTimeline']\r\n})\r\n复制代码这项要求微信在文档中并没有提到，但实测发现必须调用此方法才能出现分享到朋友圈按钮其中： 1.最新版微信开发者工具支持此项能力的模拟调试 2.存在 web-view 组件的页面不支持发起分享。 3.onShareTimeline是自基础库2.11.3开始新增的页面生命周期，行为与onShareAppMessage类似。 4.该生命周期需返回Object，用于自定义分享内容，其中：title：分享标题，默认去小程序名称query：分享出去的页面上携带的参数，用于标示渠道来源等imageUrl：分享图片，默认使用小程序logo5.特别强调： 分享到朋友圈不支持path参数 ，也就是说用户在哪个页面发起分享，分享出去的就是哪个页面。以上最后就要求开发者对分享页面进行一些适配，因为我们分享到朋友圈的页面，用户打开时会进入一个“单页模式”，在此模式下，很多sdk无法使用。2、朋友圈打开小程序的能力用户在朋友圈打开分享的小程序页面，并不会真正打开小程序，而是进入一个原本页面的“单页模式”的页面，上文提到，用户分享的原始页面和朋友圈打开的“单页模式”页面，其实对开发者来讲是同一个页面，为了区分，微信给出了两个新的场景值：1154：朋友圈打开小程序，也就是正处在“单页模式”，开发者可以根据这个场景值进行适配，理论上除此场景值外，都是正常模式。1155：从“单页模式”进入正常模式，由于此项行为是微信统一行为，开发者无法进行标记，如果想对此项行为进行统计，可以使用该场景值。“单页模式”需要适配什么呢？微信官方对“单页模式”有以下解释：1.“单页模式”下，页面顶部固定有导航栏，标题显示为分享时的标题。底部固定有操作栏，点击操作栏的“前往小程序”可打开小程序的当前页面。顶部导航栏与底部操作栏均不支持自定义样式。样式参考下图这两处的样式是无法自定义的。其中，用户只能通过下方“前往小程序”按钮进入正常模式。如果小程序使用了自定义导航头部，则需要进行一定的适配，比如我司小程序，顶部使用了自定义背景，适配前是这样：由于顶部title栏微信有固定样式，因此我们在头部加了一个灰色背景进行遮挡。2.“单页模式”默认运行的是小程序页面内容，但由于页面固定有顶部导航栏与底部操作栏，很可能会影响小程序页面的布局。因此，请开发者特别注意适配“单页模式”的页面交互，以实现流畅完整的交互体验。在app.json中新增了对单页模式的配置项：\"singlePage\" : {\r\n  \"navigationBarFit\" : \"\" //float或squeezed\r\n}\r\n复制代码该项配置可以设置顶部默认title栏的表现，其中：默认值：如果页面使用了自定义导航栏模式，则此项默认为:float，意为导航栏浮在页面上，不对原本页面布局产生影响（但可能遮挡原本页面部分元素）如果否则默认为：squeezed，表示页面被导航栏挤压，与页面不相交，也就是在页面顶部留出固定空间放微信的导航栏，原本页面将往下移动当然这两个值也可以根据页面需要而设置不同值。还有一点需要注意：单页模式下，wx.getSystemInfo 接口返回的 safeArea 为整个屏幕空间，例如：在iPhone6下，屏幕尺寸为375x667在单页模式下，safeArea的高度为：667在正常模式下，safeArea的高度为：647如果有依赖safeArea布局的页面需要进行适配。3.“单页模式”下，一些组件或接口存在一定限制这一点是单页模式适配最麻烦的一点，我们先看哪些组件和接口无法使用（可跳过直接看下面总结）分类功能点组件button open-type 、 camera 、 editor 、 form 、 functional-page-navigator 、 live-pusher 、 navigator 、 navigation-bar 、 official-account 、 open-data 、 web-view路由wx.redirectTo 、 wx.reLaunch 、 wx.navigateTo 、 wx.switchTab 、 wx.navigateBack界面导航栏 、 Tab Bar网络mDNS 、 UDP 通信界面导航栏 、 Tab Bar数据缓存周期性更新媒体VoIP 、 wx.chooseMedia 、 wx.chooseImage 、 wx.saveImageToPhotosAlbum 、 wx.chooseVideo 、 wx.saveVideoToPhotosAlbum 、 wx.getVideoInfo 、 wx.compressVideo位置wx.openLocation 、 wx.chooseLocation 、 wx.startLocationUpdateBackground 、 wx.startLocationUpdate转发wx.getShareInfo 、 wx.showShareMenu 、 wx.hideShareMenu 、 wx.updateShareMenu文件wx.openDocument开放接口登录 、 小程序跳转 、 用户信息 、 支付 、 授权 、 设置 、 收货地址 、 卡券 、 发票 、 生物认证 、 微信运动 、 微信红包设备蓝牙 、 iBeacon 、 Wi-Fi 、 NFC 、 联系人 、 剪贴板 、 电话 、 扫码广告ad 、 wx.createRewardedVideoAd 、 wx.createInterstitialAd在单页模式下禁用的能力非常多，我们可以理解为： 单页模式下仅允许内容展示，不允许任何互动或操作其中，给我们影响最大的有：登录在单页模式下调用wx.login将不会成功，也就是说我们的页面需要支持非登录态下的展示（即便是静默登录也不支持）对此，转转小程序在改造时比较简单：if(this.scene == 1154) {\r\n  this.$httpWithLogin = this.$http\r\n}\r\n复制代码即直接在单页模式下，将所有接口请求方法改写为无需登录态的请求方式。对于此项限制，不同的小程序页面需要进行针对性处理。跳转单页模式下，不支持任何页面跳转方法，也就是说，用户无法离开当前页，除非点击“前往小程序”按钮，回到正常模式。其他微信提供此项能力的初衷就是希望能在朋友圈展示更多内容，而不希望用户直接进入小程序，但单页模式下的限制太多了，无法一一进行改造，笔者的建议是，解决阻碍页面正常显示的问题和阻碍核心页面流程的问题即可，在使用不支持的能力时，微信会进行如下处理：如果用户有点击行为，则微信会统一toast：‘请前往小程序使用完整服务’如果没有点击行为，该方法会进入调用失败逻辑：注意：在单页模式下，依然支持不离开页面的各种交互，比如tab、幻灯片等在单页模式下，只有底部“前往小程序”按钮可以进入到正常小程序在单页模式下，支持再次被分享到朋友圈，也支持发送给朋友（通小程序卡片，打开会进入正常小程序）云开发资源需开启未登录访问方可在单页模式下使用：默认情况下云开发资源不允许未登录访问，需要在云控制台 - 设置 - 全局设置中手动为云环境开启允许未登录访问。并且在未登录模式下，C 端权限控制必须使用安全规则，即云函数、数据库和文件存储的访问都必须通过安全规则，因此控制台设置时除了开启允许未登录访问云环境外，还必须在云函数、数据库和文件存储分别的权限设置中选择安全规则并配置。未登录用户访问时，安全规则的 auth 字段为空，可以此判断请求来自未登录用户的访问。不允许横屏使用若页面包含 tabBar，tabBar 不会渲染，包括自定义 tabBar本地存储与小程序普通模式不共用，这一点决定了单页模式和正常模式，互通的唯一途径就是1155这个场景值低版本兼容分享到朋友圈按钮： 低版本微信目前无法出现该按钮朋友圈打开小程序： 微信文档中说会，低版本微信打开朋友圈会进入一个升级提示页，不过这是一个基础库逐渐覆盖的过程，据发稿时，实测发现iOS微信7.0.14版本即可正常显示单页模式。常见问题1、按照文档设置了，但并没有出现分享到朋友圈按钮可能的解决方案有：调用wx.showShareMenu方法开启菜单更换调试设备2、单页模式无法正常打开首先建议使用真机调试对单页模式进行调试其次检查是否有关键流程被限制的sdk能力阻断最后检查页面报错3、shareImageMessage错误该错误的是因为微信在单页模式下新增了一个内部方法：wx.shareImageMessage，并且微信禁止了该方法的读取/枚举权限，否则就会直接报错，社区里面很多开发者遇到了这个错误，转转小程序也遇到了，核心原因都是在于：页面代码或者第三方框架/插件中含有对wx拷贝的操作，类似：Object.assign({},wx)\r\n复制代码我们需要找到此类代码并进行兼容，示例如下：//先将报错方法设置为不可枚举\r\nfor (let key in wx) {\r\n    try {\r\n      if(wx[key]) {}\r\n    }catch(e) {\r\n      Object.defineProperty(wx,key,{\r\n        enumerable:false\r\n      });\r\n    }\r\n}\r\nObject.assign({},wx)\r\n复制代码以上就是关于小程序分享到朋友圈这项能力开发上的经验和解读，期望能够帮助到各位读者朋友。笔者看法最后，笔者也想谈谈对这项能力的看法。微信提供这项能力，可以解决目前小程序从朋友圈回流效果差的问题，之前小程序想分享到朋友圈，几乎唯一的方式是生成一个图片二维码并分享出去，不过以笔者经验，这种方式回流效果越来越差，这极大限制了小程序在朋友圈的传播能力，微信想解决这个问题，但又非常克制，微信不希望用户从朋友圈直接进入小程序，而是提供的单页模式，旨在期望给用户更多的内容展示，通过内容吸引用户进入小程序，虽然与我们的期待有一些落差，但这项能力确实对小程序在朋友圈的传播会有很大的促进作用，相信会有越来越多的小程序支持此项能力。"}
{"title": "微信小程序(Taro)手撕FormData ", "author": "Rolan", "date": "2020-7-27 00:34", "content": "小程序里没有FormData类，所以POST方法如果要传multipart/form-data就会报错。\r\n而npm上的formdata-polyfill，类似 https://github.com/form-data/... 或者https://github.com/jimmywarti... 都不好用\r\n好在有人探究出来 https://developers.weixin.qq.... 可以手动拼装出FormData格式的字符串，并且成功调用。\r\n以下附代码：\r\n\r\n        \r\n        \r\n        \r\n        \r\n        // 手动拼接FormData字符串\r\n// 函数边界处理没怎么做，各位可自行补充\r\n// 数组和obj的情况没有处理，可以用postman发个请求看看格式，很简单的\r\nfunction createFormData(params = {}, boundary = '') {\r\n  let result = '';\r\n  for (let i in params) {\r\n    result += `\\r\\n--${boundary}`;\r\n    result += `\\r\\nContent-Disposition: form-data; name=\"${i}\"`;\r\n    result += '\\r\\n';\r\n    result += `\\r\\n${params[i]}`\r\n  }\r\n  // 如果obj不为空，则最后一行加上boundary\r\n  if (result) {\r\n    result += `\\r\\n--${boundary}`\r\n  }\r\n  return result\r\n}\r\n\r\n// 通用post请求\r\nexport const post = function (url, params) {\r\n  return new Promise(function (resolve, reject) {\r\n    // 生成一个boundary字符串\r\n    const boundary = `----FooBar${new Date().getTime()}`;\r\n    const formData = createFormData(params, boundary);\r\n    console.log(formData);\r\n    Taro.request({ // 这里我用的taro，改成wx.request也一样\r\n      url,\r\n      method: 'POST',\r\n      credentials: 'include', //设置传递cookies\r\n      dataType: 'json',\r\n      header: {\r\n        'Accept': 'application/json',\r\n        'Content-Type': `multipart/form-data; boundary=${boundary}`,\r\n      },\r\n      data: formData,\r\n      timeout: 5000,\r\n      success: function (res) {\r\n        resolve(res.data);\r\n      },\r\n      fail: function (error) {\r\n        reject(error);\r\n      }\r\n    })\r\n  });\r\n}\r\nformdata格式\r\n用postman发个formdata请求，我们可以看到数据长这样：\r\n\r\n        \r\n        \r\n        \r\n        \r\n        Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\r\n\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"mobile\"\r\n\r\n13800138000\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"name\"\r\n\r\n张三\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"address\"\r\n\r\n地球\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"weappid\"\r\n\r\nabcdefghijklmn\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"id\"\r\n\r\n107\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW--\r\n仔细观察以下，就可以总结出上面的拼装规则了。其中，数据体中boundary，是Content-Type中的boundary前面加--。\r\n开头和结尾还有每个field之间要加上boundary"}
{"title": "微信小程序动态评分展示/五角星展示/半颗星展示/自定义长度展示 ... ", "author": "Rolan", "date": "2020-7-29 00:22", "content": "一、前言项目中遇到的评分相关的需求其实还挺多。之前也写过网页中关于评分功能实现的文档。这次，是基于微信小程序开发而提炼出一个简单方便使用的方法，网页开发中同样可用。这次使用的还是字体，主要是字体这个比较通用，颜色，大小都可以自己定义。当然了，来的最快的其实是用图片代替。二、微信小程序中评分功能实现1.css文件中引入字体文件。也可以点此下载字体文件  @font-face {  \r\n  font-family: 'FontAwesome';  \r\n  src: url('https://netdna.bootstrapcdn.com/font-awesome/3.2.1/font/fontawesome-webfont.woff?v=3.2.1') format('woff'); \r\n}2.根据自己项目的需求写出五角星的样式。参考下面.star{margin-right:10rpx;}/*五角星之间的间距*/\r\n/*五角星*/\r\n.star .icon:before {content: '\\f005'; font-family: FontAwesome; position: absolute;left: 0;top: 0;display: block;  overflow: hidden;}\r\n.star .icon {display: block; font-size: 21px; text-align: center; width: 38rpx;height: 56rpx;line-height: 56rpx;position: relative;white-space: pre;}\r\n/*灰色五角星*/\r\n.star .icon_gray{color:#aaa}\r\n/*黄色五角星*/\r\n.star .icon_yellow:before {color: #F63;}三、静态实现五角星评分1.如果是静态实现，可以直接设置宽度来实现评分效果，直接定义需要变色的五角形的比例。如果是颗星可以直接定义伪类元素宽度是50%；如果是1/3颗星可以定义宽度是33%；同样的，如果是2/3颗星星，直接定义宽度为66%。如下/*自定义长度的黄色五角星*/\r\n.half_star .icon_yellow:before {width: 50%;} 2.html的代码如下  <view >\r\n        <view style=\"font-size:12px;color:#aaa;text-align:center;margin-top:5px;\">静态评价星级</view>\r\n        <view style=\"font-size:32px;color:#f63;text-align:center;margin-top:5px;\">4.50</view>\r\n        <view style=\"width:105px;margin:0 auto\">\r\n            <view style=\"display:flex;\">        \r\n                <view class=\"star\"><view class=\"icon icon_yellow\"></view></view>\r\n                <view class=\"star\"><view class=\"icon icon_yellow\"></view></view>\r\n                <view class=\"star\"><view class=\"icon icon_yellow\"></view></view>\r\n                <view class=\"star\"><view class=\"icon icon_yellow\"></view></view>\r\n                <view class=\"star half_star\"><view class=\"icon icon_gray\"><view class=\"icon icon_yellow\"></view></view></view>\r\n            </view>        \r\n        </view>            \r\n    </view>  3.实现效果如下图四、动态实现评价打分效果1.样式同（二、微信小程序中评分功能实现）上。只是定义宽度的地方是动态赋值的。2.定义需要展示的初始属性值。分别是要展示的黄色五角星，灰色五角星，以及那颗需要打分的的黄色五角星Page({\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {    \r\n    yellow_star:0,//黄色五角星，默认一开始是黄色星星0分\r\n    gray_star:5,//灰色五角星 灰色星星是5颗 表示是5分\r\n    star_per:0,//自定义长度黄色五角星  一开始需要打的是0分\r\n  }\r\n})3.根据返回的结果改变初始化的数据 ，比如，后台返回的评分是3.62分var star=\"3.62\";//后台获取的评分\r\nvar yellow_star=parseInt(star);//需要展示的整个黄色5角星，3.62分的时候需要展示3颗整个的黄色五角星。\r\nvar star_per=parseFloat(star-yellow_star)*100;//3.62颗评价分-3颗整个黄色星，是0.62的占比，先将它*100。这样赋值的时候比较方便。也就是一颗灰色的星星中展示出62%的黄色部位。\r\nvar gray_star=parseInt(5-star);//需要展示的灰色星星，正常是5-3.62=1.38颗，0.38颗已经是在百分比中了。所以此时最后需要展示的是1整个灰色五角星\r\nthis.setData({    \r\n    star:star,  //评分数       \r\n    yellow_star:yellow_star,//整个黄色五角星的个数\r\n    star_per:star_per,//一颗灰色五角星中黄色五角星的占比\r\n    gray_star:gray_star,//整个灰色五角星的数量\r\n})4.最后一步就是页面中如何渲染的问题了。由于微信小程序中无法实现动态修改伪类元素的样式值【可能是我不会，会的同学可以指点一下】，所以，那颗占百分比的黄色五角星，我用的是底部一个灰色五角星+覆盖一个黄色五角星，都是用的绝对定位，最后黄色五角星用的是width+overflow:hidden 把多余的部位隐藏了。<view>\r\n        <view style=\"font-size:12px;color:#aaa;text-align:center;margin-top:5px;\">动态评价星级</view>\r\n        <view style=\"font-size:32px;color:#f63;text-align:center;margin-top:5px;\">{{star}}</view>\r\n        <view style=\"width:105px;margin:0 auto\">\r\n            <view style=\"display:flex;\">            \r\n                <view class=\"star\" wx:for=\"{{yellow_star}}\"><view class=\"icon icon_yellow\"></view></view>\r\n                <view wx:if=\"{{star_per>0}}\" class=\"star\" style=\"position:relative;\">　　　　　　　　　　　　<view class=\"icon icon_gray\"></view>　　　　　　　　　　　　<view class=\"icon icon_yellow \"style=\"width:{{star_per}}%;overflow:hidden;position:absolute;left:0;top:0;\"></view>　　　　　　　　　 </view>\r\n                <view class=\"star\" wx:for=\"{{gray_star}}\"><view class=\"icon icon_gray\"></view></view>\r\n            </view>     \r\n        </view>            \r\n</view> 5.实现效果图如下：五、总结这个效果的实现无非就三点。第一点引用字体。第二点比较重要，就是如何用css画出想要的五角星，至于动态实现那块其实一点也不难，思路清晰了，自然就水到渠成了。如果觉得有不妥的地方还望赐教。觉得有更好的方法也可以分享一下哦。"}
{"title": "微信小程序在wxml双大括号中执行复杂运算 ", "author": "Rolan", "date": "2020-7-29 00:41", "content": "微信小程序数据绑定支持双大括号中的表达式，但目前只支持这四种表达式：算数表达式、关系表达式、字符串连接表达式、三元表达式。vue则是全功能的JS表达式。使用起来明显差别在于是否支持函数/方法表达式 1. 遇到的问题1 <!-- 有效 -->\r\n2   <view>{{ 1+1 }}</view>\r\n3   <view>{{ 2>1 ? '是':'否'}}</view>\r\n4  \r\n5   <!-- 无效 -->\r\n6   <view>{{ Math.random() > 0.5 ? '大于':'小于' }}</view>\r\n7   <view wx:for=\"{{'1,2,3'.split(',')}}\">\r\n8       {{item}}\r\n9   </view> 2.解决办法 1     <view wx:for=\"{{fn.split(str)}}\">\r\n 2         {{item}}\r\n 3     </view>\r\n 4     <wxs module=\"fn\">\r\n 5       module.exports = {\r\n 6           split: function(str){\r\n 7             return str.split(',');\r\n 8           }\r\n 9       }\r\n10     </wxs> 其他示例：<wxs module=\"fn\">\r\n      module.exports = {\r\n          split: function(str){\r\n            return str.split(',');\r\n          },\r\n          random: function(){\r\n            return Math.random();\r\n          }\r\n      }\r\n  </wxs>\r\n  <view>{{fn.random() > 0.5 ? '大于':'小于'}}</view>\r\n  <view wx:for=\"{{fn.split('1,2,3')}}\">\r\n      {{item}}\r\n  </view>"}
{"title": "一段代码实现“小程序分享到朋友圈” ", "author": "Rolan", "date": "2020-7-29 00:49", "content": "最近微信开放了小程序分享到朋友圈的方法，很多公司的小程序都想快速占领朋友圈，那么分享到朋友圈对小程序版本最低要求是多少？代码如何写？解决这两个问题就能实现这个功能了。首先小程序分享到朋友圈对小程序版本最低要求是v2.11.1,安卓/ios版本要求：7.0.16 —— 手机版本具体看用户手机了，有的OPPO/小米配置达到了，依旧不能用！微信小程序版本要求比较高，差一个版本就不行！还有一点，要想分享到碰朋友圈页面必须有分享功能——\"发送给朋友\"：// 分享给朋友\r\n        onShareAppMessage: function (res) { \r\n            return {\r\n              title: '朋友圈看到的页面标题',\r\n              path: '页面链接',\r\n              imageUrl:'分享链接图片',\r\n              success: function (res) {\r\n                console.log(\"分享成功\")\r\n              },\r\n              fail: function (res) {\r\n                console.log(\"分享失败\")\r\n              }\r\n            }\r\n        },再者就是小程序分享到朋友圈的JS代码了： // 分享到朋友圈 \r\n        onShareTimeline: function() {\r\n            return {\r\n              title: '朋友圈看到的页面标题',\r\n              path: '页面链接',\r\n              imageUrl:'分享链接图片',\r\n              query: 'kjbfrom=pyq'\r\n            }\r\n        },"}
{"title": "微信小程序顶部搜索框(转载) ", "author": "Rolan", "date": "2020-7-29 00:57", "content": "原文地址：https://blog.csdn.net/weixin_44022446/article/details/86438015首先配置app.json文件配置相应路径：编译后生成相应文件夹、及文件夹内的4个文件，一个文件夹即一个页面。在入图片描述所有的js方法都是用bindtap（点击事件）调用的。例：搜索（点击搜索调用a方法）Input文本框的属性：hidden=\"{{对应js里data中的内容}}。例：hidden=\"{{!inputShowed}}（ input中的内容不显示） hidden=\"{{inputShowed}}（显示input中的内容）示例1：先做一个最简单的文本框：在搜索框内输入想要搜索的内容，点击搜索就可以直接获取你想要的内容。在这里插入图片描述  这是一个最简单的搜索框，点击搜索按钮调用接口完成搜索。基础代码如下：wxml<view>\r\n     <view>\r\n        <view class=\"weui-search-bar\">\r\n            <view class=\"weui-search-bar__form\">\r\n            <!-- 搜索框 -->\r\n                <view class=\"weui-search-bar__box\">\r\n                    <icon class=\"weui-icon-search_in-box\" type=\"search\" size=\"14\"></icon>\r\n                    <input type=\"text\" class=\"weui-search-bar__input\" placeholder=\"请输入搜索内容\"/>\r\n                </view>\r\n            </view>\r\n            <!-- 搜索按钮,调用搜索查询方法 -->\r\n            <view class=\"weui-search-bar__cancel-btn\" bindtap='方法名a'>搜索</view>\r\n        </view>\r\n    </view>\r\n</view>wxss.weui-search-bar {\r\n  position: relative;\r\n  padding: 8px 10px;\r\n  display: -webkit-box;\r\n  display: -webkit-flex;\r\n  display: flex;\r\n  box-sizing: border-box;\r\n  background-color: #EFEFF4;\r\n  border-top: 1rpx solid #D7D6DC;\r\n  border-bottom: 1rpx solid #D7D6DC;\r\n}\r\n.weui-icon-search_in-box {\r\n  position: absolute;\r\n  left: 10px;\r\n  top: 7px;\r\n}\r\n.weui-search-bar__form {\r\n  position: relative;\r\n  -webkit-box-flex: 1;\r\n  -webkit-flex: auto;\r\n          flex: auto;\r\n  border-radius: 5px;\r\n  background: #FFFFFF;\r\n  border: 1rpx solid #E6E6EA;\r\n}\r\n.weui-search-bar__box {\r\n  position: relative;\r\n  padding-left: 30px;\r\n  padding-right: 30px;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n  z-index: 1;\r\n}\r\n.weui-search-bar__input {\r\n  height: 28px;\r\n  line-height: 28px;\r\n  font-size: 14px;\r\n}\r\n.weui-search-bar__cancel-btn {\r\n  margin-left: 10px;\r\n  line-height: 28px;\r\n  color: #09BB07;\r\n  white-space: nowrap;\r\n}jsPage({\r\n  /**\r\n   * 页面的初始数据,可以为空\r\n   */\r\n  data: {\r\n\r\n  },\r\n  // 查询搜索的接口方法\r\n  a: function () {\r\n   \r\n  }\r\n})示例2:这是一个复杂点的搜索框样式：初始搜索框无法编辑和输入，点击搜索框使搜索框进入可编辑状态（在同一个页面完成），在搜索框内填入要搜索的内容    点击第一幅图中的搜索框，搜索框样式变成第二幅图中的样式，点击取消后变回第一幅图中的样式。基础代码如下：wxml<view>\r\n     <view>\r\n        <view class=\"weui-search-bar\">\r\n            <view class=\"weui-search-bar__form\">\r\n            <!-- 最初始时的搜索框 -->\r\n                <view class=\"weui-search-bar__box\">\r\n                    <icon class=\"weui-icon-search_in-box\" type=\"search\" size=\"14\"></icon>\r\n                    <input type=\"text\" class=\"weui-search-bar__input\" placeholder=\"搜索\"/>\r\n                </view>\r\n                <!-- 可编辑时的搜索框 -->\r\n                <label class=\"weui-search-bar__label\" hidden=\"{{inputShowed}}\" bindtap=\"showInput\">\r\n                    <icon class=\"weui-icon-search\" type=\"search\" size=\"14\"></icon>\r\n                    <view class=\"weui-search-bar__text\">搜索</view>\r\n                </label>\r\n            </view>\r\n            <!-- 取消搜索 -->\r\n            <view class=\"weui-search-bar__cancel-btn\" hidden=\"{{!inputShowed}}\" bindtap=\"hideInput\">取消</view>\r\n        </view>\r\n    </view>\r\n</view>wxss.weui-search-bar {\r\n  position: relative;\r\n  padding: 8px 10px;\r\n  display: -webkit-box;\r\n  display: -webkit-flex;\r\n  display: flex;\r\n  box-sizing: border-box;\r\n  background-color: #EFEFF4;\r\n  border-top: 1rpx solid #D7D6DC;\r\n  border-bottom: 1rpx solid #D7D6DC;\r\n}\r\n.weui-icon-search {\r\n  margin-right: 4px;\r\n  font-size: inherit;\r\n}\r\n.weui-icon-search_in-box {\r\n  position: absolute;\r\n  left: 10px;\r\n  top: 7px;\r\n}\r\n.weui-search-bar__text {\r\n  display: inline-block;\r\n  font-size: 16px;\r\n}\r\n.weui-search-bar__form {\r\n  position: relative;\r\n  -webkit-box-flex: 1;\r\n  -webkit-flex: auto;\r\n          flex: auto;\r\n  border-radius: 5px;\r\n  background: #FFFFFF;\r\n  border: 1rpx solid #E6E6EA;\r\n}\r\n.weui-search-bar__box {\r\n  position: relative;\r\n  padding-left: 30px;\r\n  padding-right: 30px;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n  z-index: 1;\r\n}\r\n.weui-search-bar__input {\r\n  height: 28px;\r\n  line-height: 28px;\r\n  font-size: 14px;\r\n}\r\n.weui-search-bar__label {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  z-index: 2;\r\n  border-radius: 3px;\r\n  text-align: center;\r\n  color: #9B9B9B;\r\n  background: #FFFFFF;\r\n  line-height: 28px;\r\n}\r\n.weui-search-bar__cancel-btn {\r\n  margin-left: 10px;\r\n  line-height: 28px;\r\n  color: #09BB07;\r\n  white-space: nowrap;\r\n}jsPage({\r\n  // 页面的初始数据\r\n  data: {\r\n    inputShowed: false,  //初始文本框不显示内容\r\n  },\r\n  // 使文本框进入可编辑状态\r\n  showInput: function () {\r\n    this.setData({\r\n      inputShowed: true   //设置文本框可以输入内容\r\n    });\r\n  },\r\n  // 取消搜索\r\n  hideInput: function () {\r\n    this.setData({\r\n      inputShowed: false\r\n    });\r\n  }\r\n});示例3:这是一个复杂的搜索框：初始搜索框无法编辑和输入（功能相当于按钮），点击搜索会跳转到一个新页面，在新页面完成搜索操作。   图一为主页面，图二为搜索页面（此页面只是为了完成搜索操作），点击主页面的搜索框进入搜索页面（搜索页面可以显示热门搜索和历史记录）。主页面的基础代码如下：wxml<view class='page_row' bindtap=\"suo\">\r\n    <view class=\"search\">\r\n      <view class=\"df search_arr\">\r\n        <icon class=\"searchcion\" size='16' type='search'></icon>\r\n        <input class=\"sousuo\" disabled placeholder=\"搜索\" bindtap='search'/>\r\n      </view>\r\n    </view>\r\n  </view>wxss.search{\r\n  width: 98%;\r\n}\r\n.search_arr {\r\n  border: 1px solid #d0d0d0;\r\n  border-radius: 10rpx;\r\n  margin-left: 20rpx;\r\n}\r\n.search_arr input{\r\n  margin-left: 60rpx;\r\n  height: 60rpx;\r\n  border-radius: 5px;\r\n}\r\n.sousuo {\r\n  padding-left: 38%;\r\n  width: 15%;\r\n  line-height: 150%;\r\n  text-align: center;\r\n}\r\n.page_row{\r\n  display: flex;\r\n  flex-direction: row\r\n}\r\n.searchcion {\r\n  margin: 10rpx 10rpx 10rpx 10rpx;\r\n  position: absolute;\r\n  margin-left:38%;\r\n  z-index: 2;\r\n  width: 15px;\r\n  height: 15px;\r\n  text-align: center;\r\n }jsPage({\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n\r\n  },\r\n  // 跳转到搜索页面\r\n  search: function () {\r\n    wx.navigateTo({\r\n      url: '../search/search'\r\n    })\r\n  }\r\n})搜索页面基础代码如下：wxml<view>\r\n     <view>\r\n        <view class=\"weui-search-bar\">\r\n            <view class=\"weui-search-bar__form\">\r\n            <!-- 搜索框 -->\r\n                <view class=\"weui-search-bar__box\">\r\n                    <icon class=\"weui-icon-search_in-box\" type=\"search\" size=\"14\"></icon>\r\n                    <input type=\"text\" class=\"weui-search-bar__input\" placeholder=\"请输入搜索内容\"/>\r\n                </view>\r\n            </view>\r\n            <!-- 取消搜索 -->\r\n            <view class=\"weui-search-bar__cancel-btn\" bindtap='hideInput'>取消</view>\r\n        </view>\r\n    </view>\r\n</view>wxss.weui-search-bar {\r\n  position: relative;\r\n  padding: 8px 10px;\r\n  display: -webkit-box;\r\n  display: -webkit-flex;\r\n  display: flex;\r\n  box-sizing: border-box;\r\n  background-color: #EFEFF4;\r\n  border-top: 1rpx solid #D7D6DC;\r\n  border-bottom: 1rpx solid #D7D6DC;\r\n}\r\n.weui-icon-search_in-box {\r\n  position: absolute;\r\n  left: 10px;\r\n  top: 7px;\r\n}\r\n.weui-search-bar__form {\r\n  position: relative;\r\n  -webkit-box-flex: 1;\r\n  -webkit-flex: auto;\r\n          flex: auto;\r\n  border-radius: 5px;\r\n  background: #FFFFFF;\r\n  border: 1rpx solid #E6E6EA;\r\n}\r\n.weui-search-bar__box {\r\n  position: relative;\r\n  padding-left: 30px;\r\n  padding-right: 30px;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n  z-index: 1;\r\n}\r\n.weui-search-bar__input {\r\n  height: 28px;\r\n  line-height: 28px;\r\n  font-size: 14px;\r\n}\r\n.weui-search-bar__cancel-btn {\r\n  margin-left: 10px;\r\n  line-height: 28px;\r\n  color: #09BB07;\r\n  white-space: nowrap;\r\n}jsPage({\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n  \r\n  },\r\n  // 取消搜索,返回主页面\r\n  hideInput: function () {\r\nwx.navigateTo({\r\n//跳转，返回主页面路径\r\n      url: '../log1/log1'   \r\n    })\r\n  }\r\n});"}
{"title": "实战丨如何制作一个完整的外卖小程序（已开源） ", "author": "Rolan", "date": "2020-7-30 00:17", "content": "最近微信小店开放了，赶着微信全面开放之前，把自己的小程序开源出来给大家使用～小程序效果开发心得如何在项目中集成云开发一开始项目并非基于 云开发 而开发的，目前考虑用云开发，因此，需要在项目中开启云开发的相关选项。首先，在小程序文件夹中建立 cloud 文件夹，并在package文件中配置，建立用户登录的云函数并上传到微信小程序云中。相关的操作可以参考 官方文档 。我在项目目录中添加了 cloud 和 miniprogram 两个目录，并在 project.config.json 文件夹进行配置{\r\n   \"miniprogramRoot\": \"./miniprogram\"\r\n   \"cloudfunctionRoot\": \"./cloud/\"\r\n}开通云开发配置完成后,可以点击控制台中的「云开发」来开通云开发。在云开发的界面中配置，并开通云开发。开通数据库集合云开发不会自动创建数据库集合，因此，你需要手动创建集合。分别创建 店铺表 Seller 、分类表 Category 、商品表 Food 、订单表 Order 、地址表 Address 、用户表 _User 。数据操作有了数据库的表后，就可以在代码中对数据进行操作了。下方是我进行目录操作的代码。const db = wx.cloud.database()\r\nconst { showModal } = require('../../utils/utils')\r\n\r\nPage({\r\n  onLoad: function(options) {\r\n    // 管理员认证\r\n    getApp().auth()\r\n    if (options.objectId) {\r\n      // 缓存数据\r\n      this.setData({\r\n        isEdit: true,\r\n        objectId: options.objectId\r\n      })\r\n      // 请求待编辑的分类对象\r\n      db.collection('Category')\r\n        .doc(options.objectId)\r\n        .get()\r\n        .then(res => { \r\n        // 获取分类信息\r\n          this.setData({\r\n            category: res.data\r\n          })\r\n        })\r\n    }\r\n  },\r\n  add: function(e) {\r\n    var form = e.detail.value\r\n    if (form.title == '') {\r\n      wx.showModal({\r\n        title: '请填写分类名称',\r\n        showCancel: false\r\n      })\r\n      return\r\n    }\r\n    form.priority = Number.parseInt(form.priority)\r\n\r\n    // 添加或者修改分类\r\n    // 修改模式\r\n    if (this.data.isEdit) {\r\n      const category = this.data.category\r\n      db.collection('Category')\r\n        .doc(category._id)\r\n        .update({\r\n          data: form\r\n        })\r\n        .then(res => {\r\n          console.log(res)\r\n          showModal()\r\n        })\r\n    } else {\r\n      db.collection('Category')\r\n        .add({\r\n          data: form\r\n        })\r\n        .then(res => {\r\n          console.log(res)\r\n          showModal()\r\n        })\r\n    }\r\n  },\r\n  showModal() {\r\n    // 操作成功提示并返回上一页\r\n    wx.showModal({\r\n      title: this.data.isEdit ? '修改成功' : '添加成功',\r\n      showCancel: false,\r\n      success: () => {\r\n        wx.navigateBack()\r\n      }\r\n    })\r\n  },\r\n  delete: function() {\r\n    // 确认删除对话框\r\n    wx.showModal({\r\n      title: '确认删除',\r\n      success: res => {\r\n        if (res.confirm) {\r\n          const category = this.data.category\r\n          db.collection('Category')\r\n            .doc(category._id)\r\n            .remove()\r\n            .then(res => {\r\n              console.log(res)\r\n              wx.showToast({\r\n                title: '删除成功'\r\n              })\r\n              wx.navigateBack()\r\n            })\r\n        }\r\n      }\r\n    })\r\n  }\r\n})联表查询在使用数据库时，难免要进行联表查询， 云开发支持在云函数侧进行联表查询 ，你可以参考我的代码，来实现联表查询的功能。const cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const result = await db.collection('Food')\r\n    .aggregate()\r\n    .lookup({\r\n      from: 'Category',\r\n      localField: 'category',\r\n      foreignField: '_id',\r\n      as: 'categories'\r\n    })\r\n    .end()\r\n    // .orderBy('priority', 'asc')\r\n    // .get()\r\n    console.log(result)\r\n    return result.list\r\n}文件上传在小程序的操作中，难免会遇到需要进行图片上传的场景。在进行图片上传时，云开发提供了方便的云存储供我们查询数据。在获取到文件的本地路径后，调用 wx.cloud.uploadFile 即可上传文件。chooseImage() {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: res => {\r\n        const tempFilePaths = res.tempFilePaths\r\n        const file = tempFilePaths[0]\r\n        const name = utils.random_filename(file) //上传的图片的别名，建议可以用日期命名\r\n        console.log(name)\r\n        wx.cloud.uploadFile({\r\n          cloudPath: name,\r\n          filePath: file, // 文件路径\r\n        }).then(res => {\r\n          console.log(res)\r\n          const fileId = res.fileID\r\n        // 将文件id保存到数据库表中\r\n          db.collection('Seller').doc(this.data.seller._id)\r\n          .update({\r\n            data: {\r\n              logo_url: fileId\r\n            }\r\n          }).then(() => {\r\n            wx.showToast({\r\n              title: '上传成功'\r\n            })\r\n            // 渲染本地头像\r\n            this.setData({\r\n              new_logo: fileId\r\n            })\r\n          }, err => {\r\n            console.log(err)\r\n            wx.showToast({\r\n              title: '上传失败'\r\n            })\r\n          })\r\n        })\r\n      }\r\n    })\r\n  }微信支付逻辑的实现作为一个商城，难免会有微信支付相关逻辑的实现。在这种情况下，可以借助云开发提供的微信支付云调用功能实现快速的 API 调用和接口的实现。绑定商户在使用云开发提供的微信支付时，需要先执行微信支付的绑定，在云开发控制台添加相应的商户号添加后微信会发来通知根据提示，开通账号即可。如果不绑定，将报“受理关系不存在”的错误函数代码调用配置完成后，只需要在云函数中调用微信支付的接口，就可以实现相关调用的能力const cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV\r\n})\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  console.log('请求中')\r\n  console.log(cloud.getWXContext().ENV)\r\n  let { orderId, amount, body } = event\r\n  const wxContext = cloud.getWXContext()\r\n  const res = await cloud.cloudPay.unifiedOrder({\r\n    body: body,\r\n    outTradeNo: orderId,\r\n    spbillCreateIp: '127.0.0.1',\r\n    subMchId: '1447716902',\r\n    totalFee: amount,\r\n    envId: 'dinner-cloud',\r\n    functionName: 'pay_cb'\r\n  })\r\n  return res.payment\r\n}这里 functionName: 'pay_cb' 指的就是支付成功后，微信支付那侧给我的回调信息，后面我们就用它来更新我们的订单状态小程序端代码调用调用云函数后，会获得微信支付所需要的各种参数，这个时候，就可以在小程序端调用微信支付接口，进行支付，相关代码可以参考const { result: payData } = res\r\n  wx.requestPayment({\r\n    timeStamp: payData.timeStamp,\r\n    nonceStr: payData.nonceStr,\r\n    package: payData.package,\r\n    signType: 'MD5',\r\n    paySign: payData.paySign,\r\n    success: res => {\r\n      console.log('支付成功', res)\r\n      wx.showModal({\r\n        title: '支付成功',\r\n        showCancel: false,\r\n        success: () => {\r\n          // 跳转订单详情页\r\n          wx.navigateTo({\r\n            url: '/order/detail/detail?objectId=' + order._id\r\n          })\r\n        }\r\n      })\r\n    },\r\n...微信支付回调处理微信统一下单里一个pay_cb回调函数，它是一个云函数，后续微信支付的支付信息将会发送在这个函数中，相应的，我们需要编写处理的方法// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  // API 调用都保持和云函数当前所在环境一致\r\n  env: cloud.DYNAMIC_CURRENT_ENV\r\n})\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  console.log('支付回调')\r\n  console.log(event)\r\n  console.log(cloud.getWXContext().ENV)\r\n  const orderId = event.outTradeNo\r\n  const resultCode = event.resultCode\r\n  if (resultCode === 'SUCCESS') {\r\n    const res = await db\r\n      .collection('Order')\r\n      .doc(orderId)\r\n      .update({\r\n        data: {\r\n          status: 1\r\n        }\r\n      })\r\n    console.log(res)\r\n    return { errcode: 0 }\r\n  }\r\n}总结云开发体验下来，优点自不必多说，微信登录与支付原生支持，调用与调试都很方便，特别是不用启本地服务开发，真的好用；这个小程序的源码我已经开源了，你可以 访问云开发社区官网 获取源码，自行使用～作者：黄秀杰，16年开始从事小程序开发与技术布道，同名个人公众号「黄秀杰」。云开发（Tencent CloudBase，TCB）是腾讯云提供的云原生一体化开发环境和工具平台，为开发者提供高可用、自动弹性扩缩的后端云服务，包含计算、存储、托管等serverless化能力，可用于云端一体化开发多种端应用（小程序，公众号，Web 应用，Flutter 客户端等），帮助开发者统一构建和管理后端服务和云资源，避免了应用开发过程中繁琐的服务器搭建及运维，开发者可以专注于业务逻辑的实现，开发门槛更低，效率更高。产品文档： https://cloud.tencent.com/product/tcb技术文档： https://cloudbase.net技术交流加Q群：601134960"}
{"title": "微信小程序登录 + 基于token的身份验证 ", "author": "Rolan", "date": "2020-8-3 14:58", "content": "图里其实说的很清楚了，清理下流程：1.前端调用wx.login()获取code值2.前端通过调用wx.getUserInfo获取iv、rawData、signature、encryptedData等加密数据，传递给后端3.服务器通过code请求api换回session_key和openid4.服务器通过前端给的rawData 加获取的session_key使用sha1加密，计算出signature15.比对前端传的signature和自己算出来的signature1是否一致（防止数据不一致）6.用AES算法解密encryptedData里的敏感数据7.拿着敏感数据后做自己的逻辑8.通知前端登陆成功这里只是想拿到用户的openid，则直接1,3就可以做到了。如下：第一步：通过wx.login（微信前端–小程序）接口获取code，将code传到后台注意：code的来源：是用户打开小程序的时候，随机生成的，是腾讯生成的，每个code只能使用一次，因此，理论上这个code是安全的package cn.wmyskxz.springboot.model.user;/**\r\n * @Author: Yangke\r\n * @Date: 2019/3/31 15:52\r\n **/\r\npublic class WeChatLoginModel {\r\n    String code;\r\n \r\n    public String getCode() {\r\n        return code;\r\n    }\r\n \r\n    public void setCode(String code) {\r\n        this.code = code;\r\n    }\r\n}\r\n第二步：后台通过code访问微信（腾讯）接口，微信（腾讯）接口返回当前登录的信息：session_key及openid返回的openid是每个用户唯一的，通过这个 可以匹配 微信（腾讯）的用户 跟 我们的用户，就是我们后台通过openid来判断这个人是谁，UserController.java 微信小程序登录/**\r\n     * 微信小程序登录\r\n     *\r\n     * 登录成功后，将用户身份信息及session_key存入token\r\n     * @param model\r\n     * @return\r\n     */\r\n    @ResponseBody\r\n    @PostMapping(\"/weChatLogin\")\r\n    public SingleResult<String> weChatLogin(@RequestBody WeChatLoginModel model){\r\n \r\n        /**\r\n         * 登录日志：\r\n         * id\\ userid\\ date\\ wx_code\\ createTime\r\n         * create table loginLog (\r\n                id varchar(50) primary key,\r\n                userId varchar(50),\r\n                logindate date,\r\n                wxcode varchar(100),\r\n                createtime datetime\r\n           );\r\n         */\r\n \r\n        SingleResult<String> result = new SingleResult<String>();\r\n        //第三步：调用service.weChatLogin(model):后台检查openid是否存在，返回openid对应的用户\r\n        WeChatLoginResult loginResult = service.weChatLogin(model);\r\n        \r\n        //第四步：\r\n        UserAccount user = loginResult.getUser();\r\n        if(user == null ){\r\n            result.setCode(0);\r\n            result.setMessage(\"登录失败\");\r\n        }\r\n        else {\r\n            User u = new User();\r\n            u.setId(user.getId());\r\n            u.setPassword(user.getPassword() == null ? user.getWxopenid() : user.getPassword());\r\n            u.setSessionKey(loginResult.getSession_key());\r\n            String token = getToken(u);\r\n            result.setToken(token);\r\n            result.setCode(1);\r\n            result.setMessage(\"登陆成功\");\r\n        }\r\n \r\n        return result;\r\n    }\r\n其中：就是下面的第三步//调用service.weChatLogin(model) WeChatLoginResultloginResult = service.weChatLogin(model);**第三步：后台检查openid是否存在，去UserService.java@Override\r\n    public WeChatLoginResult weChatLogin(WeChatLoginModel model){\r\n        WeChatLoginResult result = null;\r\n        try {\r\n \r\n            // code  -> openid\r\n            String urlFormat = \"https://api.weixin.qq.com/sns/jscode2session?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code\";\r\n            String url = String.format(urlFormat, WeChat.appId, WeChat.secret, model.getCode());\r\n            String json = WeChat.sendGet(url);\r\n \r\n            //将json字符串转化成对象\r\n            result = JSON.parseObject(json, WeChatLoginResult.class);\r\n \r\n            if(result.getErrcode() == null){\r\n                // 去数据库 检查 openId 是否存在 不存在就新建用户\r\n                UserAccount user = userAccount.wechatOpenIdIsExists(result.getOpenid());\r\n                if(user == null || user.getId() == null){\r\n                    // 不存在，就是第一次登录：新建用户信息\r\n                    user = new UserAccount();\r\n                    user.setId(UUID.randomUUID().toString());\r\n                    user.setWxopenid(result.getOpenid());\r\n                    user.setLasttime(new Date());\r\n                    userAccount.insert(user);\r\n                }\r\n                else {\r\n                    //如果存在，就不是第一次登录，更新最后登录时间\r\n                    user.setLasttime(new Date());\r\n                    userAccount.updateByPrimaryKeySelective(user);\r\n                }\r\n                result.setUser(user);\r\n \r\n                // 保存登录日志\r\n                LoginLog log = new LoginLog();\r\n                log.setId(UUID.randomUUID().toString());\r\n                log.setCreatetime(new Date());\r\n                log.setLogindate(new Date());\r\n                log.setUserid(user.getId());\r\n                log.setWxcode(model.getCode());\r\n                loginLog.insert(log);\r\n            }\r\n            else {\r\n                System.out.println(json);\r\n            }\r\n        }\r\n        catch (Exception e){\r\n            System.out.println(e.getMessage());\r\n        }\r\n \r\n        return result;\r\n    }\r\n去数据库中检查openid是否存在：UserAccountMapper.java\r\n@Select(\"select * from useraccount where wxOpenId = #{wxOpenId}\")\r\nUserAccount wechatOpenIdIsExists(String wxOpenId);\r\n（1）如果不存在：就是该用户的第一次登录，后台数据库新添加一个用户信息。如果存在：就不是该用户的第一次登录，以前登陆过，就更新后台数据库中该用户的第一次登录时间(2) 返回用户信息第四步：下发token//第四步：UserAccount user = loginResult.getUser();\r\nif(user == null ){\r\n    result.setCode(0);\r\n    result.setMessage(\"登录失败\");\r\n}\r\nelse {\r\n    User u = new User();\r\n    u.setId(user.getId());\r\n    //用户如果是第一次登录，那就是没有密码的，这里用openid当做密码\r\n    u.setPassword(user.getPassword() == null ? user.getWxopenid() : user.getPassword());\r\n    u.setSessionKey(loginResult.getSession_key());\r\n    //利用User.class中的信息生成token\r\n    String token = getToken(u);\r\n    //下发token\r\n    result.setToken(token);\r\n    result.setCode(1);\r\n    result.setMessage(\"登陆成功\");\r\n}\r\n\r\nreturn result;\r\n}其中生成token的步骤：BaseController.java利用JWT框架生成tokenpackage cn.wmyskxz.springboot.controllers;\r\n \r\nimport cn.wmyskxz.springboot.model.User;\r\nimport com.auth0.jwt.JWT;\r\nimport com.auth0.jwt.algorithms.Algorithm;\r\n \r\nimport java.util.Date;\r\n/**\r\n * @Author: Yangke\r\n * @Date: 2019/3/28 21:12\r\n **/\r\npublic abstract class BaseController {\r\n \r\n    protected String getToken(User user) {\r\n        String token=\"\";\r\n        token= JWT.create()\r\n                .withKeyId(user.getId())\r\n                .withIssuer(\"www.ikertimes.com\")\r\n                .withIssuedAt(new Date())\r\n                .withJWTId(\"jwt.ikertimes.com\")\r\n                .withClaim(\"session_key\", user.getSessionKey())\r\n                .withAudience(user.getId())\r\n                .sign(Algorithm.HMAC256(user.getPassword()));\r\n        return token;\r\n    }\r\n}\r\n至此，再理一下上面的步骤：（1）微信小程序通过访问wx.login获得一个code，返回给后台（2）后台拿着这个code，调用腾讯的接口，获取到openid、seesion-key等信息，openid是用户唯一的（3）后台拿着openid去数据库中检查，该用户是否是第一次登陆。如果是第一次登陆，那么就新建一个用户–UserAcount；如果不是第一次登陆，就修改该用户的最后登录时间。不管是不是第一次登录，都有了一个用户（4）然后根据用户的信息利用JWT生成token，下发给微信小程序第五步微信小程序收到token后，存起来第六步微信小程序请求后台微信小程序把token放在请求头中第七步先介绍一个注解：Authorize说明：如果有这个注解，就需要验证tokenpackage cn.wmyskxz.springboot.annotation;\r\n \r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\n \r\n/**\r\n * @Author: Yangke\r\n * @Date: 2019/3/28 19:57\r\n *authorize 是判断 是否需要 token\r\n **/\r\n@Target({ElementType.METHOD, ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface Authorize {\r\n    boolean required() default true;\r\n}\r\n用拦截器，验证token\r\n\r\npackage cn.wmyskxz.springboot.interceptors;\r\n \r\nimport cn.wmyskxz.springboot.annotation.AllowAnonymous;\r\nimport cn.wmyskxz.springboot.annotation.Authorize;\r\nimport cn.wmyskxz.springboot.model.User;\r\nimport cn.wmyskxz.springboot.service.UserService;\r\nimport com.auth0.jwt.JWT;\r\nimport com.auth0.jwt.JWTVerifier;\r\nimport com.auth0.jwt.algorithms.Algorithm;\r\nimport com.auth0.jwt.exceptions.JWTDecodeException;\r\nimport com.auth0.jwt.exceptions.JWTVerificationException;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.web.method.HandlerMethod;\r\nimport org.springframework.web.servlet.HandlerInterceptor;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n \r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.lang.reflect.Method;\r\n \r\n/**\r\n * @Author: Yangke\r\n * @Date: 2019/3/28 20:00\r\n *\r\n * 获取token并验证token\r\n **/\r\npublic class AuthorizationInterceptor implements HandlerInterceptor {\r\n    @Autowired\r\n    UserService userService;\r\n \r\n    //拦截器：请求之前preHandle\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object) throws Exception {\r\n        // 如果不是映射到方法直接通过\r\n        if (!(object instanceof HandlerMethod)) {\r\n            return true;\r\n        }\r\n        HandlerMethod handlerMethod = (HandlerMethod) object;\r\n        Method method = handlerMethod.getMethod();\r\n \r\n        //检查是否有passtoken注释，有则跳过认证，注意:其中这个注解多余了\r\n        if (method.isAnnotationPresent(AllowAnonymous.class)) {\r\n            AllowAnonymous passToken = method.getAnnotation(AllowAnonymous.class);\r\n            if (passToken.required()) {\r\n                return true;\r\n            }\r\n        }\r\n        //检查有没有需要用户权限的注解\r\n        //如果有注解Authorize，就需要验证token\r\n        if (method.isAnnotationPresent(Authorize.class)) {\r\n            Authorize userLoginToken = method.getAnnotation(Authorize.class);\r\n            if (userLoginToken.required()) {\r\n \r\n                String token = httpServletRequest.getHeader(\"authorization\");// 从 http 请求头中取出 token\r\n \r\n                // 执行认证\r\n                if (token == null) {\r\n                    throw new RuntimeException(\"无token，请重新登录\");\r\n                }\r\n                // 获取 token 中的 user id\r\n                String userId;\r\n                try {\r\n                    // 获取 userid\r\n                    userId = JWT.decode(token).getKeyId();\r\n                    // 添加request参数，用于传递userid\r\n                    httpServletRequest.setAttribute(\"currentUser\", userId);\r\n                    // 根据userId 查询用户信息\r\n                    User user = userService.getUserById(userId);\r\n                    if (user == null) {\r\n                        throw new RuntimeException(\"用户不存在，请重新登录\");\r\n                    }\r\n \r\n                    try {\r\n                        String session_key = JWT.decode(token).getClaim(\"session_key\").as(String.class);\r\n                        // 添加request参数，用于传递userid\r\n                        httpServletRequest.setAttribute(\"sessionKey\", session_key);\r\n                    }\r\n                    catch (Exception e){\r\n                    }\r\n \r\n                    // 验证 密码\r\n                    JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPassword())).build();\r\n                    try {\r\n                        jwtVerifier.verify(token);\r\n                    } catch (JWTVerificationException e) {\r\n                        throw new RuntimeException(\"401\");\r\n                    }\r\n                } catch (JWTDecodeException j) {\r\n                    throw new RuntimeException(\"401\");\r\n                }\r\n \r\n                return true;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n \r\n \r\n    @Override\r\n    public void postHandle(HttpServletRequest httpServletRequest,\r\n                           HttpServletResponse httpServletResponse,\r\n                           Object o, ModelAndView modelAndView) throws Exception {\r\n \r\n    }\r\n \r\n    //拦截器：请求之后：afterCompletion\r\n    @Override\r\n    public void afterCompletion(HttpServletRequest httpServletRequest,\r\n                                HttpServletResponse httpServletResponse,\r\n                                Object o, Exception e) throws Exception {\r\n    }\r\n}\r\n流程：1、从http请求头中取出tokenString token = httpServletRequest.getHeader(“authorization”);2、如果没有token，抛出异常，请用户登录如果有token，利用JWT从token中取出userid，添加到request参数3、根据userid去后台数据库中查询用户是否存在，如果不存在，抛出异常：用户不存在，请重新登录User user = userService.getUserById(userId);这个方法：@Override\r\npublic User getUserById(String id) {\r\n   UserAccount u = userAccount.selectByPrimaryKey(id);\r\n   User user = new User();\r\n   user.setId(u.getId());\r\n   user.setPassword(u.getPassword() == null ? u.getWxopenid() : u.getPassword());\r\n   user.setUsername(u.getUsername());\r\n   return  user;\r\n}\r\n4、如果用户存在，再利用JWT从token中取出seesion-key，添加到request参数String session_key = JWT.decode(token).getClaim(\"session_key\").as(String.class);\r\n5、验证密码：因为我生成token的时候，是存了密码的，这个就是检查一下密码对不对验证 token里面的密码 跟 你存的 是不是一样JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPassword())).build();\r\ntry {\r\n    jwtVerifier.verify(token);\r\n} catch (JWTVerificationException e) {\r\n     throw new RuntimeException(\"401\");\r\n}\r\n6、最终token验证成功，返回true，放行拦截器介绍一下：1、preHandle：在业务处理器处理请求之前被调用。预处理，可以进行编码、安全控制、权限校验等处理；2、postHandle：在业务处理器处理请求执行完成后，生成视图之前执行。后处理（调用了Service并返回ModelAndView，但未进行页面渲染），有机会修改ModelAndView；3、afterCompletion：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）；第八步：request里面有userid，后台就可以识别是对哪个用户做处理"}
{"title": "微信小程序：setData函数详解及注意事项 ", "author": "Rolan", "date": "2020-8-3 15:01", "content": "在微信小程序中经常会使用到setData函数把变量渲染到视图层，那么什么是setData呢？如何使用？注意事项有些什么？下面我们就来详细了解一下！正文setData是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。setData函数用于将数据从逻辑层渲染到视图层（异步），同时改变对应的this.data的值（同步）。实例1：简单实现点击修改变量值test：{{test}}</text>\r\n点击改变test值button>\r\nPage({\r\n    data: {\r\n        test: \"我是测试变量\"\r\n    },\r\n    bindTest: function () {\r\n        console.log(\"this.data.test：\" + this.data.test);\r\n        this.setData({\r\n            test: \"我是测试变量，我的值被改变了！\"\r\n\t})\r\n\tconsole.log(\"this.data.test：\" + this.data.test);\r\n    }\r\n})\r\n效果：实例解析：代码很容易理解，点击按钮test变量的值被改变了，通过setData函数渲染到了前端展示。另外我在this.setDta前后分别打印出了this.data.test的值，看看最终打印结果：这里就说明了setData函数渲染到视图层后，会同步修改this.data.test的值。实例2：动态修改数组指定下标的某个参数值（类似购物车）for=\"{{test}}\" wx:key=\"index\">\r\n    <view data-index=\"{{index}}\" bindtap=\"bindTest\">{{item.txt}}view>\r\n</block>\r\nPage({\r\n    data: {\r\n\ttest: [\r\n\t    { txt: \"我是1号\" },\r\n\t    { txt: \"我是2号\" },\r\n\t    { txt: \"我是3号\" }\r\n\t]\r\n    },\r\n    bindTest: function (e) {\r\n\t// 被点击的view\r\n\tlet index = e.currentTarget.dataset.index;\r\n\t// 根据index找到test对应索引中对应要修改的参数\r\n\tlet revise = \"test[\" + index + \"].txt\";\r\n\tthis.setData({\r\n\t    [revise]: \"呃，我被人给点了！！！\"\r\n\t})\r\n    }\r\n})\r\n效果实例解析：其实这个就是根据index找到test对应索引中对应要修改的参数，然后进行修改并渲染到页面上；该功能购物车选中状态、数量更改都可以使用到；此方法比使用循环寻找更改然后再渲染，更方便、性能更好！注意事项如果Page对象的data中没有定义该key，则setData自动创建；如有则修改data中原变量的值。直接修改this.data，而不调用this.setData()，是无法改变当前页面的状态的，会导致数据不一致。使用this.setData({})时，注意this指向问题。 仅支持可以JSON化的数据。单次设置的数据不能超过1024KB，尽量避免一次设置过多的数据。不要把data中的任何一项的value设为undefined，否则这一项将不能被设置，可能会有潜在的问题。常见的setData操作错误（官方文档）1.频繁的去setData在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；2.每次setData都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次evaluateJavascript脚本过程，当数据量过大时会增加脚本的编译执行时间，占用WebView JS线程。3.后台态页面进行setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。"}
{"title": "也许你并不需要第三方小程序框架 ", "author": "Rolan", "date": "2020-8-3 15:06", "content": "这里说的去除小程序框架其实并不严谨，因为小程序本身也算是一个框架，而且是一个功能更加完善的框架系统。在前端的概念中，我们一般说一个框架是指一个用来帮助开发者构建用户界面的框架，而小程序框架本身不仅仅包含了UI层的功能，还提供了API能力、服务端的能力，所以说小程序框架本身是一个比常规的前端框架更完善的东西，或者说是一个完善的构建应用系统。本文中所说的原生小程序与小程序框架的对比，均指与第三方小程序框架的对比。在小程序的世界里，原生小程序框架已经足够好，它就是那把给你雕刻小而美应用的雕刻刀，而不必要去寻找一把屠龙刀。1、框架的取舍最近Vue作者尤大关于框架设计平衡的分享中也提到了框架的取舍问题。当我们去构建一个复杂的前端应用的时候，如果没有工具，而是使用原生JavaScript去开发的话，那只会花费更多的时间。对小程序来说，原生小程序框架就是我们的工具，它足以用来构建一个复杂的小程序应用。然而web应用的开发环境是否也适用于小程序开发呢？小程序框架在小程序生态发展的初期的确起到了很大的促进作用，然而随着小程序原生框架的不断完善，这些小程序框架的作用已经不再具备优势。框架的确给前端带来了生产力的提高，也带动了前端界生态的发展。所以在小程序出现之后，一股框架之风也很快的出现，微信小程序刚推出之后，就出现了两个比较出名的小程序开发框架，wepy、mpvue。这两个框架都带着一个共同的出发点，那就是将前端框架的开发体验移植到小程序开发中，从语法层做了改动，使用用户可以采用类似 Vue.js 风格的语法去开发微信小程序。这些小程序框架初期主要做的是对小程序原生开发体验的增强，随着小程序生态的发展，又增加了跨端开发能力的支持。然而我们框架的引入真的增强了开发体验吗？我们是否真的需要跨端能力？是否需要通过引入框架的形式来实现跨端支持？答案是否定的，引入框架对于小程序开发来说只会带来更多的问题。2、原生小程序 VS Web 框架如下是原生小程序与 Web 框架功能的对比情况，可以看到 Web 框架具备的能力，原生小程序也具备。小程序出现的时候 Web 框架已经发展的比较成熟，所以可以简单猜测小程序的框架借鉴了许多 Web框架的特性，这也是为什么小程序开发方式与前端开发方式如此接近的原因。功能对比模块Vue.jsReact.js原生小程序数据监听支持支持支持组件式开发支持支持支持组件库开源组件库丰富开发组件库丰富原生小程序组件支持数据状态管理vuexreduxglobalData 可实现基本的数据管理路由vue-routerreact-router原生支持模块开发npmnpmnpm（有轻微的约束限制）在开发前端应用的时候，Vue 和 React 技术栈是比较流行的两种类型，而对于选择什么样的生态工具时，许多开发者并不确定选择什么样的技术栈，所以一般都会选择 Vue 全家桶和 React 全家桶。原生小程序框架从能力上就考虑了小程序场景所需的技术栈，这也是笔者推崇原生小程序开发方式的原因，如果你对你当前构建的应用场景需要什么样的技术栈特别清晰，那么就用原生的好了，因为原生小程序框架就是基于小程序场景开发的。选择什么样的技术栈，提供什么样的框架能力，这应该是小程序平台团队去思考的问题。3、原生小程序的优势从上面的功能层级对比我们可以发现，原生小程序与框架相比，功能是非常接近的，简单来说就是同一个物种，只不过是花猫、白猫的区别。那么除此之外，原生小程序还有哪些优势呢？稳定安全可靠原生小程序由专业的小程序团队维护更新，这是社区开源项目无法比拟的。即使是热门的开源项目也难保不会出现停滞更新维护的情况，也许有一天你就发现代码中的坑只得你自己的修复。原生小程序还处于快速发展的阶段，每过一段时间就会发布新功能，如果使用原生小程序开发的话就可以及时的享用，而如果依赖于三方框架的话，只得依赖于框架作者更新之后才能使用。作为一个开发人员，有时候选择一个什么样的框架是很难的，如果你想正确的选择框架，就得必须要了解框架所做的一些内部权衡，你必须知道这个框架朝着哪个方向发展，并且知道它与你构建的东西是否一致。而对于小程序来说，上述的问题其实不存在，小程序框架就是小程序平台团队为你量身打造的。想了解更多小程序框架可以查看如下三个框架：WePY让小程序支持组件化开发的框架WePY框架在开发过程中参考了Vue等现有框架的一些语法风格和功能特性，对原生小程序的开发模式进行了再次封装，更贴近于MVVM架构模式,并支持ES6/7的一些新特性。mpvue是一个使用Vue.js开发小程序的前端框架，目前支持 微信小程序、百度智能小程序，头条小程序和支付宝小程序。框架基于Vue.js，修改了的运行时框架runtime和代码编译器compiler实现，使其可运行在小程序环境中，从而为小程序开发引入了Vue.js开发体验。Taro是一套遵循React语法规范的多端开发解决方案。使用Taro，我们可以只书写一套代码，再通过Taro的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native等）运行的代码。4、小程序跨端需求继微信小程序推出后，阿里，百度，头条也推出了自己的小程序平台，这就给小程序开发者带来一个问题，是每个平台开发一套还是寻求代码复用的技术方案。其实跨端方案很多，现有的小程序框架大多都内置了跨端能力支持，对于跨端支持能力要求并不是特别高的团队，也可以搭建自己的跨端方案，因为这些小程序框架都很类似，所以说搭建一套针对特定场景的跨端方案也变得可行。"}
{"title": "图片加载（本地，网路）实例详解 ", "author": "Rolan", "date": "2020-7-15 00:37", "content": "在微信小程序中，要显示一张图片，有两种图片加载方式：加载本地图片加载网络图片加载本地图片<image class=\"widget__arrow\" src=\"/image/arrowright.png\" mode=\"aspectFill\">\r\n</image> src=\"/image/arrowright.png\" 这句就是加载本地图片资源的。想想iOS中的加载本地图片，imageName:,类似。加载网络图片微信在加载网络这方面封装的还是很好的，包括语音和视频的加载。直接给'src'这个属性附上地址，它会自动加载。<image class=\"image_frame\" src=\"{{imageUrl}}\" mode=\"aspectFill\">\r\n</image> 这个imageUrl是在js文件中数据data:{\r\n  imageUrl:\"http://img1.3lian.com/2015/w7/85/d/101.jpg\"\r\n},\r\n也可以直接写成<image class=\"image_frame\" src=\"http://img1.3lian.com/2015/w7/85/d/101.jpg\" mode=\"aspectFill\">\r\n</image> 下来就看看image的一些属性需要注意的是：image组件默认宽度300px、高度225pxsrc就是上面代码中用到的。mode有12种模式，其中3种是缩放模式，9种是裁剪模式。具体说明建议看官方文档，很详细。很简单就这些。遗留问题在实践中，想实现这样一个功能：点击一个按钮，让这个图片重新加载。不知道怎样可以在js文件中直接操作image。后续学习或许会知道。哪位仁兄知道方法请在留言中不吝赐教。补充遗留问题已经找到答案。在按键的响应方法中直接用setData给imageUrl设定新的地址即可downLoadImage:function(event){\r\n  console.log(event)\r\n  var that = this;\r\n  this.setData({\r\n    imageUrl:\"http://h.hiphotos.baidu.com/zhidao/pic/item/6d81800a19d8bc3ed69473cb848ba61ea8d34516.jpg\"\r\n  })\r\n }\r\n效果如下：感谢阅读，希望能帮助到大家，谢谢大家对本站的支持！"}
{"title": "京喜前端自动化测试之路(小程序篇) ", "author": "Rolan", "date": "2020-7-16 00:30", "content": "如果你已经阅读过 《京喜前端自动化测试之路（一）》，可跳过前言部分阅读。\r\n前言\r\n京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。\r\n容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景模拟异常导致演习效率较低，因此想通过开发自动化测试工具来提升演习效率，让容灾演习工作随时可以轻松开展。由于京喜 H5 和小程序场景差异比较大，自动化测试分 H5 和小程序两部分进行。前期已经分享过 H5 的自动化测试方案 —— 京喜前端自动化测试之路（一），本文则主要讲述小程序版的自动化测试方案。\r\n综上所述，我们希望京喜小程序自动化测试工具可以提供以下功能：\r\n\r\n访问目标页面，对页面进行截图；\r\n模拟用户点击、滑动页面操作；\r\n网络拦截、模拟异常情况（接口响应码 500、接口返回数据异常）；\r\n操作缓存数据（模拟有无缓存的场景等）。\r\n\r\n小程序自动化 SDK\r\n聊到小程序的自动化工具，微信官方为开发者提供了一套小程序自动化 SDK —— miniprogram-automator ， 我们不需要关注技术选型，可直接使用。\r\n\r\n小程序自动化 SDK 为开发者提供了一套通过外部脚本操控小程序的方案，从而实现小程序自动化测试的目的。\r\n\r\n\r\n如果你之前使用过 Selenium WebDriver 或者 Puppeteer，那你可以很容易快速上手。小程序自动化 SDK 与它们的工作原理是类似的，主要区别在于控制对象由浏览器换成了小程序。\r\n\r\n特性\r\n通过该 SDK，你可以做到以下事情：\r\n\r\n控制小程序跳转到指定页面\r\n获取小程序页面数据\r\n获取小程序页面元素状态\r\n触发小程序元素绑定事件\r\n往 AppService 注入代码片段\r\n调用 wx 对象上任意接口\r\n...\r\n\r\n示例\r\nconst automator = require('miniprogram-automator')\r\n\r\nautomator\r\n    .launch({\r\n        cliPath: '/Applications/wechatwebdevtools.app/Contents/MacOS/cli', // 工具 cli 位置（绝对路径）\r\n        projectPath: 'path/to/project', // 项目文件地址（绝对路径）\r\n    })\r\n    .then(async miniProgram => {\r\n        const page = await miniProgram.reLaunch('/pages/index/index')\r\n        await page.waitFor(500)\r\n        const element = await page.$('.banner')\r\n        console.log(await element.attribute('class'))\r\n        await element.tap()\r\n        await miniProgram.close()\r\n    })\r\n复制代码综上所述，我们选择使用官方维护的 SDK —— miniprogram-automator 开发小程序的自动化测试工具，通过 SDK 提供的一系列 API ，实现访问目标页面、模拟异常场景、生成截图的过程自动化。最后再通过人工比对截图，判断页面降级处理是否符合预预期、用户体验是否友好。\r\n实现方案\r\n原来的容灾演习过程：\r\n小程序的通信方式改成 HTTPS ，通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降级处理符合预期。\r\n现阶段的容灾演习自动化方案：\r\n我们将容灾演习过程分为自动化流程和人工操作两部分。\r\n自动化流程：\r\n\r\n启动微信开发者工具（开发版）;\r\n访问目标页面，模拟用户点击、滑动等行为；\r\n模拟异常场景：拦截网络请求，修改接口返回数据（接口返回 500、异常数据等）；\r\n生成截图。\r\n\r\n人工操作：\r\n自动化脚本执行完毕后，人工比对各个场景的截图，判断是否符合预期。\r\n方案流程图：\r\n\r\n开发实录\r\n快速创建测试用例\r\n为了提高测试脚本的可维护性、扩展性，我们将测试用例的信息都配置到 JSON 文件中，这样编写测试脚本的时候，我们只需关注测试流程的实现。\r\n测试用例 JSON 数据配置包括公用数据（global）和私有数据：\r\n公用数据（global）：各测试用例都需要用到的数据，如：模拟访问的目标页面地址、名字、描述、设备类型等。\r\n私有数据： 各测试用例特定的数据，如测试模块信息、api 地址、测试场景、预期结果、截图名字等数据。\r\n{\r\n  \"global\": {\r\n    \"url\": \"/pages/index/index\",\r\n    \"pageName\": \"index\",\r\n    \"pageDesc\": \"首页\",\r\n    \"device\": \"iPhone X\"\r\n  },\r\n  \"homePageApi\": {\r\n    \"id\": 1,\r\n    \"module\": \"home_page_api\",\r\n    \"moduleDesc\": \"首页主接口\",\r\n    \"api\": \"https://xxx\",\r\n    \"operation\": \"模拟响应码 500\",\r\n    \"expectRules\": [\r\n      \"1. 有缓存数据，显示容灾兜底数据\",\r\n      \"2. 请求容灾接口，显示容灾兜底数据\",\r\n      \"3. 容灾接口异常，显示信异常息、刷新按钮\",\r\n      \"4. 恢复网络，点击刷新按钮，显示正常数据\"\r\n    ],\r\n    \"screenshot\": [\r\n      {\r\n        \"name\": \"normal\",\r\n        \"desc\": \"正常场景\"\r\n      },\r\n      {\r\n        \"name\": \"500_cache\",\r\n        \"desc\": \"有缓存-主接口返回500\"\r\n      },\r\n      {\r\n        \"name\": \"500_no_cache\",\r\n        \"desc\": \"无缓存-主接口返回500-容灾兜底数据\"\r\n      },\r\n      {\r\n        \"name\": \"500_no_cache_500_disaster\",\r\n        \"desc\": \"无缓存-主接口返回500-容灾兜底接口返回500\"\r\n      },\r\n      {\r\n        \"name\": \"500_no_cache_recover\",\r\n        \"desc\": \"无缓存-返回500-恢复网络\"\r\n      }\r\n    ]\r\n  },\r\n  …\r\n}\r\n复制代码编写测试脚本\r\n我们以京喜首页主接口的测试用例为例子，通过模拟主接口返回 500 响应码的异常场景，验证主接口的异常处理机制是否完善、用户体验是否友好。\r\n预期效果：\r\n\r\n主接口异常，有缓存数据，显示缓存数据\r\n主接口异常，无缓存数据，则请求容灾接口，显示容灾兜底数据\r\n主接口、容灾接口异常，无缓存数据，显示信异常息、刷新按钮\r\n恢复网络，点击刷新按钮，显示正常数据\r\n\r\n测试流程：\r\n\r\n场景实现：\r\n根据测试流程以及配置的测试用例信息，编写测试脚本，模拟测试用例场景:\r\n\r\n访问页面\r\n\r\nconst miniProgram = await automator.launch({\r\n      cliPath: '/Applications/wechatwebdevtools.app/Contents/MacOS/cli', // 开发者工具命令行工具（绝对路径）\r\n      projectPath: 'jx_project', // 项目地址（绝对路径）\r\n\r\n})\r\nawait miniProgram.reLaunch('/pages/index/index')\r\n复制代码\r\n生成截图\r\n\r\nawait miniProgram.screenshot({\r\n    path: 'jx_weapp_index_home_page_500.png'\r\n})\r\n\r\n复制代码\r\n模拟异常数据\r\n\r\nconst getMockData = (url, mockType, mockValue) => {\r\n    const result = {\r\n      data: 'test',\r\n      cookies: [],\r\n      header: {},\r\n      statusCode: 200,\r\n    }\r\n\r\n    switch (mockType) {\r\n      case 'data':\r\n        result.data = getMockResponse(url, mockValue) // 修改返回数据\r\n        break\r\n      case 'cookies':\r\n        result.cookies = mockValue // 修改返回数据\r\n        break\r\n      case 'header':\r\n        result.header = mockValue // 修改返回响应头\r\n        break\r\n      case 'statusCode':\r\n        result.statusCode = mockValue // 修改返回响应头\r\n        break\r\n    }\r\n\r\n    return {\r\n      rule: url,\r\n      result\r\n    }\r\n  }\r\n\r\n // 修改本地存储数据\r\n const mockValue = {\r\n     data: {\r\n         modules: [{\r\n            tpl:'3000',\r\n            content: []\r\n         }]\r\n     }\r\n }\r\n const mockData =  [\r\n    getMockData(api1, 'statusCode', 500), // 模拟接口返回 500\r\n    getMockData(api2, 'data', mockValue) // 模拟接口返回异常数据\r\n    ...\r\n ]\r\n \r\n复制代码\r\n拦截接口请求，修改返回数据\r\n\r\nconst interceptAPI = async (miniProgram, url, mockData) => {\r\n    try {\r\n      await miniProgram.mockWxMethod(\r\n        'request',\r\n        function(obj, data) { // 处理返回函数\r\n          for (let i = 0, len = data.length; i < len; i++) {\r\n            const item = data[i]\r\n            // 命中规则的返回 mockData\r\n            if (obj.url.indexOf(item.rule) > -1) {\r\n              return item.result\r\n            }\r\n          }\r\n          // 没命中规则的真实访问后台\r\n          return new Promise(resolve => {\r\n            obj.success = res => resolve(res)\r\n            obj.fail = res => resolve(res)\r\n            / origin 指向原始方法\r\n            this.origin(obj)\r\n          })\r\n        },\r\n        mockData, // 传入 mock 数据\r\n      )\r\n\r\n    } catch (e) {\r\n      console.error(`拦截【${url}】API报错`)\r\n      console.error(e)\r\n    }\r\n  }\r\n\r\nawait interceptAPI(interceptAPI, url, mockData)\r\n复制代码\r\nminiProgram.mockWxMethod：覆盖 wx 对象上指定方法的调用结果。利用该 API，可以覆盖 wx.request API，拦截网络请求，修改返回数据。\r\n目前是本地存储一份接口返回的 JSON 数据，通过修改本地的 JSON 数据生成 mockData。若需要修改接口实时返回的数据，可在 obj.success 中获取实时数据并修改。\r\n\r\n\r\n清除缓存\r\n\r\ntry {\r\n    await miniProgram.callWxMethod('clearStorage')\r\n} catch (e) {\r\n    await console.log(`清除缓存报错: `)\r\n    await console.log(e)\r\n}\r\n复制代码\r\n点击刷新按钮\r\n\r\nconst page = await miniProgram.currentPage()\r\nconst $refreshBtn = await page.$('.page-error__refresh-btn') // 同 WXSS，仅支持部分 CSS 选择器\r\nawait $refreshBtn.tap()\r\n复制代码\r\n取消拦截，恢复网络\r\n\r\nconst cancelInterceptAPI = async (miniProgram) => {\r\n    try {\r\n      await miniProgram.restoreWxMethod('request') // 重置 wx.request ，消除 mockWxMethod 调用的影响。\r\n    } catch (e) {\r\n      console.error(`取消拦截【${url}】API报错`)\r\n      console.error(e)\r\n    }\r\n}\r\n\r\nawait cancelInterceptAPI(miniProgram)\r\n\r\n复制代码启动自动化测试\r\n由于第一阶段的测试工具尚未平台化，先通过在终端输入命令行，运行脚本的方式，启动自动化测试。\r\n在项目的 package.json 文件中，使用 scripts 字段定义脚本命令：\r\n \"scripts\": {\r\n    \"start\": \"node pages/index/index.js\"\r\n  },\r\n复制代码运行环境：\r\n\r\n安装 Node.js 并且版本大于 8.0\r\n基础库版本为 2.7.3 及以上\r\n开发者工具版本为 1.02.1907232 及以上\r\n\r\n运行：\r\n在终端切入到项目根目录路径，输入以下命令行，就可以启动测试工具，运行测试脚本。\r\n$ npm run start\r\n复制代码测试结果\r\n\r\n运行脚本示例：\r\n使用 SDK，你必须知道 Shadow DOM\r\n当我们想控制小程序页面时，需获取页面实例 page，利用 page 提供的方法控制页面内的元素。\r\n比如，当我们想点击页面中搜索框时，我们一般会这么做：\r\n const page = await miniProgram.currentPage()\r\n const $searchBar = await page.$('search-bar')\r\n await $searchBar.tap()\r\n复制代码但这样真的可行吗？答案是：\r\n试试就知道了。\r\n运行这段测试脚本后生成的截图：\r\n\r\n我们得到的结果是：根本没有触发点击事件。\r\nShadow DOM：\r\n它是 HTML 的一个规范，它允许在文档( document )渲染时插入一颗DOM元素子树，但是这个子树不在主 DOM 树中。\r\n它允许浏览器开发者封装自己的 HTML 标签、css 样式和特定的 javascript 代码、同时开发人员也可以创建类似  <input>、<video>、<audio> 等、这样的自定义的一级标签。创建这些标签内容相关的 API，可以被叫做 Web Component。\r\nShadow DOM 的关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。\r\n\r\nShadow host: 一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。它是 Shadow DOM 的一个宿主元素。比如：<input />、<audio>、<video>  标签，就是 Shadow DOM 的宿主元素。\r\nShadow tree: Shadow DOM 内部的 DOM 树。\r\nShadow root: Shadow DOM 的根节点。通过 createShadowRoot 返回的文档片段被称为 shadow-root , 它和它的后代元素，都会对用户隐藏。\r\n\r\n回到我们刚刚的问题：\r\n由于小程序使用了 Shadow DOM，因此我们不能直接通过 page 实例获取到搜索框真实 DOM。我们看到的页面中渲染的搜索框，实际上是一个 Shadow DOM。因此，我们必须先获取到搜索框 Shadow DOM 的宿主元素，并通过宿主元素获取到搜索框真实的 DOM，最后触发真实 DOM 的点击事件。\r\n  const page = await miniProgram.currentPage()\r\n  const $searchBarShadow = await page.$('search-bar')\r\n  const $searchBar = await $searchBarShadow.$('.search-bar')\r\n  const { height } = await $searchBar.size()\r\n复制代码运行这段测试脚本后生成的截图：\r\n\r\n从截图可以看到，触发了搜索框的点击事件。\r\n更多测试场景实现\r\n1. 下拉刷新\r\nconst pullDownRefresh = async (miniProgram) => {\r\n    try {\r\n      await miniProgram.callWxMethod('startPullDownRefresh')\r\n    } catch (e) {\r\n      console.error('下拉刷新操作失败')\r\n      console.error(e)\r\n    }\r\n}\r\n复制代码2. 滚动到指定 DOM\r\nconst page = await miniProgram.currentPage() // 获取页面实例\r\nconst $recommendTabShadow = await page.$('recommend-tab') // 获取Shadow DOM\r\nconst $recommendTab = await $recommendTabShadow.$('.recommend') // 获取真实 DOM\r\nconst { top } = await $recommendTab.offset() // 获取DOM 定位\r\nawait miniProgram.pageScrollTo(top) // 滚动到指定DOM\r\n复制代码3. 事件\r\n\r\n日志打印；\r\n监听页面崩溃事件\r\n\r\n// 日志打印时触发\r\nminiProgram.on('console', msg => {\r\n    console.log(msg.type, msg.args)\r\n  })\r\n})\r\n\r\n// 页面 JS 出错时触发\r\npage.on('error', (e) => {\r\n    console.log(e)\r\n})\r\n复制代码结语\r\n第一阶段的小程序自动化测试之路告一段落。和 H5 自动化测试一样，容灾演习已实现了半自动化，可通过在终端运行测试脚本，模拟异常场景自动生成截图，再配合人工比对截图操作，判断演习结果是否符合预期。目前已投入到每个月的容灾演习中使用。\r\n由于 H5 和小程序的差异比较大，第一阶段的自动化测试分两端进行，测试脚本语法也是截然不同，需要同时维护两套测试工具。为了降低维护成本，提升测试脚本的开发效率，我们正在研发第二阶段的自动化测试工具，一套代码支持两端测试，目前已经进入内测阶段。更多彩蛋，敬请期待第二阶段自动化测试工具——多端自动化测试 SDK 。\r\n\r\n欢迎关注凹凸实验室博客：aotu.io\r\n或者关注凹凸实验室公众号（AOTULabs），不定时推送文章"}
{"title": "58安居客小程序平台化与多小程序开发探索与实践 ", "author": "Rolan", "date": "2020-7-16 00:46", "content": "导语本文分享58安居客小程序团队在小程序向平台化转型、多小程序同步开发过程中遇到的问题、解决方案与实践。背景在提效、服务进阶的大背景下，为了让同一支团队，把一个业务做精做深，提高研发效率，HBG的产研团队，进行了新的划分：分线开发。分线开发以后，安居客二手房前端团队要维护小程序从 1 变成 4 个。小程序技术栈安居客微信小程序微信原生开发安居客百度小程序百度原生开发58二手房小程序mpvue58同城小程序房产二手房业务插件方式接入，技术不限与此同时，随着移动互联网的流量红利逐步减少，小程序无疑是新的流量风口，为了抢占更多免费流量，推动业务快速发展，产品希望我们安居客微信、百度小程序可以同步开发，以及未来可以支持更多小程序，如快应用等。在多小程序技术框架不同、业务逻辑不同、基础能力不同的情况下，给我们的小程序开发带来了以下挑战：1、在人力不变的情况下，我们要如何支持多个小程序业务需求快速迭代？2、作为平台方，我们要如何与业务方协作开发？3、如何支持房产垂直业务在其他小程序平移？面对这种变化，我们联合房产各业务前端、产品、UED、QA等多个团队，一起发起了小程序七巧板项目，也开启了58安居客小程序打怪升级刷新副本之路，接下来我将娓娓道来我们是如何刷新副本的。现状分析与设计1、 现状分析面对多小程序同步开发的需求，我们应该如何做呢？1） 方案一：按照小程序端配备开发资源，迭代开发速度不变，人力需要成倍增加。虽然技术不用做大的改动，但是人力成本太高。2） 方案二：做技术升级改造，实现技术栈业务的统一。房产小程序其中包含了很多业务（租房、商业地产、二手房、新房），几百个页面，大家都停下业务去做技术栈的统一，显然是不现实的。考虑到这些实际情况，技术方案上只能考虑边做业务边重构，逐步去做统一。2、 整体设计从业务方的角度来看，我们希望所有小程序平台尽可能提供相同的通用能力，减少业务的适配，业务开发只需关心业务开发，以及实现多小程序端的适配。从平台方的角度来说，尽可能为业务方提供便利，减少兼容和适配成本。针对以上情况，我们做出如下设计：小程序七巧板架构图不难看出：1） 作为平台方，我们有以下任务：A、多小程序提供统一通用平台能力接口，即宿主环境。B、统一基础能力，减少宿主环境的适配C、统一宿主小程序，从而达到可以快速落地其他小程序目标。2） 作为业务方，实现二手房业务可在多小程序同步开发。为了支持业务的快速落地，所以我们把平台建设优先级排在第一位。接下来我将从平台化以及二手房业务适配多小程序开发两个维度来阐述。小程序平台化建设1、 确认业务方接入方式截止到目前为止，仅微信平台支持插件，百度和轻应用等暂不支持插件。考虑到插件和分包的特点以及各业务实际情况，作为平台方我们插件和分包的接入方式均做了支持。业务方可根据自身业务场景，选择合适的接入方式。2、 确认平台通用能力宿主环境要解决什么问题？1） 提供平台基础能力和公共方法的调用2）抹平不同平台的差异3） 支持业务插件和分包无缝切换4） 一套代码在宿主环境中一次测试，多端上线梳理清楚我们要做什么之后，紧接着进入紧锣密鼓的调研设计中，通过全方位调研我们得知， 58同城微信小程序已经有开发过宿主环境，但无通用SDK。房产的宿主环境要兼容房产多个小程序之间的差异，有很重业务属性，也不能复用58同城宿主。所以最终我们的宿主环境设计如下：1） 支持新老开发方式共存，推荐使用基于宿主环境开发2） API方法名、出参、入参和58同城小程序宿主保持一致3） 安居客特有业务，加入新的API4） 提供完整demo、完善的文档、测试环境3、 技术选型工欲善其事必先利其器，要同时开发多个小程序以及未来可能要支持更多小程序，借助一些优秀的框架进行开发，一定会事半功倍。调研了Taro、WePY、uni-app、mpvue、chameleon、百度小程序转换工具以及其他工具，结合团队实际情况，最后我们选择Taro作为我们的开发框架。选择Taro的主要原因：1） 支持逐步替换，降低项目风险2） 团队有React 开发经验，也要维护部分React Native业务，技术栈尽量统一3） 支持动态编译、条件编译，可实现定制化58、安居客主题皮肤4） 提供转换工具，可把现有微信小程序直接转成 Taro，降低迁移成本5） 库维护更新比较稳定，社区活跃4、 小程序基础能力统一随着宿主环境需求分析、技术选型、开发完成以及配合业务方接入过程中，为了减少业务方的适配，我们通用能力做了三个统一：1） 账号体系：统一接入云账号，统一账号体系2） 微聊：统一多小程序微聊接入方式和版本以及通用能力，减少宿主和业务的适配3） 与TEG在云账号、微聊等基础公共能力上，尽量保持多小程序在接入方式、接口设计上统一，减少接入成本。5、 小程序性能优化前期我们以宿主环境的开发、支持业务快速接入为主，随着业务逐步灰度接入，小程序的包大小也越来越大，性能问题也越来越明显，以微信小程序为例，我们发现：1） 小程序包大小越来越大2） 小程序下载耗时明显增加3） 小程序启动耗时明显增加那么如何优化呢？通读了一遍官网的性能优化文档，总结出性能优化的三大块1） 包体积优化（分包、图片CDN、延迟非必须插件、分包预加载等）2） 请求优化（请求次数、请求阶段等）3） 首次渲染优化（setData优化、DOM渲染优化等）问题又来了，如何来找出我们的小程序，这三大块需要优化的具体影响点在哪里？在开发工具中使用help()方法，使用其中的openVendor方法打开开发工具在小程序框架所在目录。其中有包括以基础库命名的目录和其他帮助文件。如其中有两个工具wcc和wcsc。wcc工具可把 wxml 转换为对应的 JS 函数$gwx(path, global)，wcsc 可将 wxss 转换为 css。而基础库目录包括WAService.js 和 WAWebview.js 文件。结合开发者工具命令行中使用document.head可以查看小程序的整个启动流程大致如下：结合微信包的启动流程和微信开发工具的Sources、Audits面板进行性能分析。我们发现可以通过以下几种方式来进行了优化：1） 减少包的文件大小A、小程序本地图片一律替换成从CDN加载B、在平台化过程中，随着业务接入、灰度、全量上线，及时下掉老代码C、删除历史无用代码D、延迟第三方依赖的加载2） 优化首屏数据请求，来加速首屏速度选择。首屏 非 必须 的数据，延迟加载3） 优化 setData存储和调用A、减少 setData 的频繁调用B、减少 data 上的数据冗余，非必要数据不要在 data 上存储接下来，以安居客微信小程序为例，介绍一下针对延迟第三方依赖的加载，我们是如何做优化的：1） 业务插件肯定是要延迟加载的，插件在各业务分包引入，这点毋庸置疑2） 账号体系，我们是直接对接云账号的插件，最开始的做法是在主包中直接引入，文件比较大（434kb）。后续，云账号插件做了重构和升级，文件大小：80.5kb，并且支持分包引入。进而，我们升级了云账号插件版本、以分包的方式引入云账号插件。最终，主包大小减少了 434kb。3） 微聊，安居客微信小程序最开始引入的是微聊 JS SDK、自己实现 UI，文件大小：20kb。为了统一多小程序微聊通用能力和复用微聊插件现有卡片功能，我们决定微聊统一接入微聊插件，微聊插件大小：335kb。那我们应该如何引入微聊SDK呢？显而易见，2种方案：A、直接在主包中引入微聊插件，对主包大小影响比较大，首页、房源列表等可以拿到微聊消息数，现有功能不会受到影响。B、不在主包中引入微聊插件，首页、房源列表等业务拿不到微聊消息数。首页、房源列表效果图如下图，那我们该怎么办呢？图左是首页，图右是二手房房源列表针对上述问题和业务场景与微聊开发沟通，他们可以提供一个消息总数的接口，但是这个消息总数和微聊插件的总数可能不一致，业务上需要做一下降级，与产品一起沟通之后，也能接受这部分的降级。所以，最后微聊插件SDK，我们以分包的方式做了接入，尽可能的保证了主包的大小以及下载速度。其他优化，就不在这里一一展开了，通过以上初步优化，我们可以看到启动耗时时间、初次渲染时间有了明显的下降，下图是我们优化后小程序性能变化，后面我们将持续优化，为用户提供更好的用户体验。小程序下载耗时小程序初次渲染耗时6、 规范化、流程化俗话说的好，打江山容易守江山难，这句话在我们小程序平台化的过程中也适用。通过一系列开发和技术方案的落地，我们提供了宿主环境和完整的接入文档、开发demo。配合房产各个业务方完成了首次接入，希望后面不费吹灰之力的更新版本即可。然而理想是丰满的，现实很骨感，比如以下问题：1） 开发过程中遇到宿主环境的Bug找谁解决2） 平台方测试和业务方测试如何配合3） 业务方测试完成后如何交接给平台方4） 谁负责上线，新的需求怎么对接等等通过解决这些问题并且实际落地实施，我们一起梳理一套完善的标准和规划的开发流程，通过流程的规范化、标准化，来保证我们项目高效开发、沟通、以及项目的顺利上线。二手房业务跨平台开发随着平台化的标准化、统一和完善，不难看出，只要58二手房小程序也接入标准的宿主接口，那么二手房业务要适配的小程序的能力基本上就统一了，接下来只需要考虑业务的实现即可。图左58二手房房源列表，图右安居客二手房房源列表通过以上图片对比，我们发现业务逻辑差异较大，想要同步开发还存在不少困难，经过与产品、UED一起沟通协商，58、安居客保证页面结构统一，支持业务、皮肤差异性。借助Taro支持多小程序转换，考虑如何实现定制皮肤与实现业务差异化即可。整体设计如下：打包和集成1、多程序打包1） 打包配置我们按平台、终端打包需要，在 package.json 增加对应 scripts，然后利用 cross-env这个包来设置环境变量，比如在打包安居客微信小程序的时候，设置环境变量 WEAPP=anjuke，代码如下：{  \"scripts\": {    \"build:weapp\": \"taro build --type weapp\",    \"dev:weapp\": \"npm run build:weapp -- --watch\",    \"build:anjuke\": \"cross-env WEAPP=anjuke && npm run build:weapp\",    \"dev:anjuke\": \"cross-env WEAPP=anjuke && npm run dev:weapp\"  }}然后在config/index.js里面利用环境变量加载对应小程序的自定义配置，具体代码代码如下：const WEAPP = process.env.WEAPP ? process.env.WEAPP : 'anjuke'module.exports = function(merge) {    return merge({}, config, require(`./${WEAPP}`));};此处 config 代表打包通用配置以及默认配置。如 babel、源码目录等。为了让每个平台、终端打包出来的代码大小都是最优的，利用配置defineConstants 属性配置编译时的全局变量，从而实现小程序按照平台、终端、功能差异上实现条件编译。我们的实践是按照业务平台、平台属性、小程序终端做了划分：const config = {    defineConstants: {        PLATFORM, // 网站平台 anjuke 或 58        PLATFORM_ABBR, // 小程序名字简写，用来区分同平台同类型小程序        RUN_END, // 运行端 weapp、swan、quickapp                IS_AJK, // 是否是 anjuke        IS_WUBA, // 是否是 58        IS_WEAPP, // 是否是 微信        IS_SWAN, // 是否是 百度        IS_QUICK_APP // 是否是 快应用    }}在编译的时候，根据目标小程序的特性，为上面变量注入对应的值。2） 皮肤差异化二手房业务要同时支持58同城、安居客两个平台。二者之间页面结构是一致的，但各自有些主题色，我们将主题色提取成Sass变量，在编译打包时，按照平台引入平台主题色，从而达到换肤的功能。比如在安居客小程序打包是通过plugins引入安居客主题色：const path = require(\"path\");module.exports = {    plugins: {        sass: {            resource: [                \"src/scss/ajktheme.scss\"            ],            projectDirectory: path.resolve(__dirname, \"..\")        }    }};2、 API 适配平台、业务差异58、安居客在业务上存在诸多差异，如账号鉴权、城市、房源展示逻辑等，为了保证小程序在多平台、多终端通用功能统一、前端数据展示逻辑统一，API 接口做了平台、业务、端的兼容，统一了数据接口格式，间接的支持了小程序一套代码在多平台、多端运行。目前我们的落地方案：1） 按照业务平台划分 API 域名，如安居客小程序接口使用anjuke.om域名，58小程序接口使用58.com域名2） 按照公参区分终端，如我们通过weapp 公参区分是百度、微信还是其他小程序以房源列表为例，之前安居客和58房源展示逻辑、扣费逻辑、API接口数据格式等各不相同，重构之后，API根据域名封装业务逻辑，统一接口数据输出格式，比如前端获取列表数据代码如下：import { fetchList } from \"./api\";fetchList({    page: this.list.page,    page_size: PAGE_SIZE,    user_id: userInfo.userId || \"\",    open_id: userInfo.openId || \"\",    union_id: userInfo.udid || \"\",    ...this.filterOptions}).then(res => {    // do some thing})然后我们在 api.js 底层针对58、安居客平台适配一下API接口域名，代码如下：import { base } from './config';const urlBase = isOldAjk => {  if (IS_WUBA) return base.wbBase;  if (isOldAjk) return base.oldAjkBase;  if (IS_AJK) return base.ajkBase;};通过API 适配平台、业务逻辑的差异，使前端逻辑在多小程序之间保持独立、统一，从而达到多小程序平移的目的，前端专注于数据展示和交互即可。3、中间层屏蔽环境、平台差异同一套代码要运行在多个小程序上，虽然宿主提供了通用标准的能力，但是还有一些差异在短期没有办法解决。为了让同一代码可以在多个小程序之间无缝平移，必然要引用一些中间层屏蔽底层和环境的差异，简化业务调用方式，提高开发效率。以跳转协议为例，房产二手房的业务要分别以插件的方式集成在58同城微信小程序、以分包的形式集成在安居客微信小程序，那插件和分包在路径跳转方面是不同，为此，有了我们的跳转中间层：export const goToPage = (wx, params, type) => {    if (MAIN.Common.isWubaPlugin()) {        let isObject = typeof params === 'object';        let entry = isObject ? params : { url: params };        entry.url = `plugin-private://${ pluginId }` + entry.url;        MAIN.Common.goToPage(wx, entry, type);    } else {        MAIN.Common.goToPage(wx, params, type);    }};4、 统一跳转协议、跳转协议动态下发现有的多个小程序，之前页面的路由均不一样，在路由跳转管理上、维护和开发成本很高。针对这个问题，我们做了以下几步做了优化提效：1） 新开发页面多小程序路由保持统一2） 借鉴58APP协议下发机制，跳转协议统一改为后端下发这样不仅解决了路由管理维护成本，而且支持更精细化的灰度，做到优雅降级。在我们业务统一逐步切换中，灰度必不可少，有完善的灰度降级方案，也有助于最大限度的降低影响。具体到业务场景中：以微信小程序为例，提交版本给小程序审核需要时间，在从发版到更新到所有用户，最长需要 24 小时。如果我们新改版的页面上线了，突然发现某些机型打开白页。我们可以快速将下发协议成老页面，甚至换成一个H5的页面，把损失降低到最小。总结和展望回顾过去，通过半年多技术和业务的升级和统一。安居客实现了微信、百度、快应用等小程序的平台化，支持房产垂直业务在多小程序上实现无缝平移，可以快速落地生成更多的小程序，同时二手房核心业务完成在多小程序的同步开发，大幅度的提升了小程序开发效率，在小程序的流量风口上为业务落地做好后勤保障。接下来我们会持续优化小程序性能、完善性能监控、JS错误监控等。拥抱公司小程序协同项目，持续完善安居客小程序平台建设，为业务快速接入、落地做好准备。写到最后安居客小程序实现平台化以及实现二手房核心业务重构与顺利落地，离不开其他前端、后端、QA等兄弟团队的支持与积极配合，另一方面，在我们统一小程序基础功能，如云账号、微聊等方面，也离不开 TEG同学的大力支持与帮助，因此在此对你们说一声感谢。个人能力也有限，如果大家发现文章中的错误或者实现方案上的不完美，欢迎交流指正。参考文献1、https://developers.weixin.qq.com/miniprogram/dev/framework/2、https://nervjs.github.io/taro/docs/config.html3、https://developers.weixin.qq.com/miniprogram/dev/framework/audits/performance.html作者简介李永超，58集团/资深前端工程师。张素沙，58集团/高级前端工程师。阅读推荐"}
{"title": "微信小程序 - 暗黑模式（深色模式） ", "author": "Rolan", "date": "2020-7-16 00:52", "content": "最近暗黑模式成为了潮流，微信小程序也推出了暗黑模式适配，下面来记录一个下适配暗黑模式。效果图：一、实现1、开启暗黑模式在 app.json 中配置 \"darkmode\": true// app.json{    ...    \"darkmode\": true}2、配置主题文件在根目录新建主题配置文件 theme.json, 并在 app.json 中配置路径引入// app.json{    ...    \"themeLocation\": \"theme.json\"}theme.json配置文件一共分为两个属性，light 和 dark，分别正常模式和暗黑模式。theme.json 示例如下（仅供参考）：// theme.json{  \"light\": {    \"navBackgroundColor\": \"#ffffff\",    \"navTextStyle\": \"black\"  },  \"dark\": {    \"navBackgroundColor\": \"#000000\",    \"navTextStyle\": \"white\"  }}必须存在 light 和 dark 两个属性，里层命名自定义，没有严格要求。 3、在app.json中应用配置属性在配置属性以 @开头拼接theme.json中自定义的名字写入配置，示例如下// app.json{  ...  \"window\": {    \"navigationBarBackgroundColor\": \"@navBackgroundColor\",    \"navigationBarTitleText\": \"小书包大梦想\",    \"navigationBarTextStyle\": \"@navTextStyle\"  },  \"darkmode\": true,  \"themeLocation\": \"theme.json\"}配置完些，接着手机开启暗黑模式（深色模式）后，小程序会根据你配置的颜色进行转换。 4、wxss样式适配暗黑模式wxss中，支持通过媒体查询 prefers-color-scheme 适配不同主题。如下样式会在正常模式下页面背景为灰白色，暗黑模式下为黑色。/* 正常模式下应用的样式 */page{    background: #f1f1f1;}  /* 暗黑模式下应用的样式 */@media (prefers-color-scheme: dark) {  page{    background: #000000;  }} ————————————————原文：https://blog.csdn.net/ZXW_Future/java/article/details/106246715"}
{"title": "在 2020 年，谈小程序框架该如何选择 ", "author": "Rolan", "date": "2020-7-17 00:32", "content": "微信并不是第一个做小程序的 App，而是做小程序最有优势的 App，比如高流量、用户较长的停留时间等等。站在微信的视角，小程序从业务形式上更像是公众号开发的演变产物。在更早的时候，微信通过 sdk 的形式，增强了开发者开发公众号网页的能力。小程序的诞生是微信本身迈向平台化超级 App 的 业务 行为，并且帮助用户更好的实现了「轻量级 Web App」。微信小程序诞生之初就自己定义了一套”标准“，与前端已有的生态格格不入，最开始的框架甚至没有组件、没有 npm，和 Web 生态严重脱节。由于特殊的双线程模型与四不像的语法，开发者苦不堪言。小程序的 开放 只是对三方业务的开放而已。蜂拥而至的效仿其它厂商看到了小程序业务的开放性，试图也能够做成平台型 App。支付宝小程序、百度小程序、淘宝小程序、360小程序、快应用......它们中的大多数都不约而同的选择了和微信类似的架构、框架，而这更多的不是从技术角度去做的决定，而是想尽可能蹭微信小程序的福利，让开发者可以更快的投放到自己的平台。当然，其中有两个稍显不同。一个是早期的淘宝小程序，它不仅支持 axml 的写法，同时还支持 sfc -- 用 Vue 来开发，这个架构更大程度上让开发者有了选择的权利，并且能够更好地连接已有的前端生态。另一个是快应用，也是用类似 Vue 的语法来开发，但是略显畸形的是它自己又造了一套标准，更像是对 Vue 进行了魔改，开发者的开发成本并没有得到有效的提升。小程序框架选择小程序原生语法 and 增强型框架小程序原生语法是不是原生语法一定是被唾弃的。站在 2020 年这个时间节点上来说， 并不是这样 。单纯就微信小程序 or 支付宝小程序而言，目前的小程序生态是完完全全足够开发者利用前端已有的部分生态来开发出符合预期的应用的。与早期 npm 能力的缺失、只能通过模板渲染实现组件化相比而言。现在的小程序已经能够做到前端工程化，并且植入前端生态中已有的一些理念，例如状态管理、CLI 工程化等等。也就是说，当业务的需求只有投放到微信小程序或者支付宝小程序的时候，原生语法完完全全可以成为前端程序员们的一个选择。你可以组件化你的项目，你可以手写一个或者使用社区已有的状态管理库来颗粒化管理组件状态，你甚至还可以直接用 TypeScript 来编写你的应用。总之，你几乎可以把你所习惯的东西都带到小程序这个域里。渐进增强型框架所谓渐进增强型框架，更多的还是在小程序引入 npm 之后，有了更加开放的能力所带来的收益。这类框架一般依然是以小程序原生语法为主，只是在逻辑层引入了增强语法来优化应用性能或者提供更便捷的使用方法，以腾讯开源的 omix 框架为例，先简单看一下它的用法：逻辑层create.Page(store, {\r\n  // 声明依赖\r\n  use: ['logs'],\r\n  computed: {\r\n    logsLength() {\r\n      return this.logs.length\r\n    }\r\n  },\r\n  onLoad: function () {\r\n    //响应式，自动更新视图\r\n    this.store.data.logs = (wx.getStorageSync('logs') || []).map(log => {\r\n      return util.formatTime(new Date(log))\r\n    })\r\n    setTimeout(() => {\r\n      //响应式，自动更新视图\r\n      this.store.data.logs[0] = 'Changed!'\r\n    }, 1000)\r\n  }\r\n})\r\n复制代码视图层<view class=\"container log-list\">\r\n  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">\r\n    <text class=\"log-item\">{{index + 1}}. {{log}}</text>\r\n  </block>\r\n</view>\r\n复制代码先不谈它的语法是否符合直觉或者好用。简单来说，它整体 保留小程序已有的语法 。但是在此基础之上，对它进行了扩充和增强，比如引入了 Vue 中比较有代表性的 computed ，比如能够直接通过 this.store.data.logs[0] = 'Changed' 修改状态。可以说是在小程序原生半 Vue 半 React 的语法（此处 半 只是数量词）背景下，彻底将其 Vue 化的一种方案。使用增强型框架最大的好处是，你可以在只引入极少依赖，并且保留对小程序认知的情况下，用更加 舒爽 的语法来写代码。这类框架对于目标只投放到特定平台小程序的开发者或者非专业前端而言是比较好的选择之一。因为你只需要关注很少的新增文档和小程序自身的文档就足够了。毕竟在推动某项技术的过程中，团队的学习成本也是需要考虑的。转换类框架相比于渐进增强型框架，转换类框架的使命是完全不同的。转换类框架的使命是让开发者 几乎不用感受 小程序原生语法，更大程度对接前端已有生态，并且可以实现**「一码多端」 的业务诉求，只是最后的 构建产物**为小程序代码。随着这几年的发展，转换类框架大的方面分为两种 -- 编译时/运行时。下文会分别针对两种方案进行分析。Rax 编译时/Taro 2.0顾名思义，编译时方案的核心是通过编译分析的方式，将开发者写的代码转换成小程序原生语法。这里以 Rax 编译时和 Taro 2.0 为例，面向开发者的语法是类 React 语法，开发者通过写有一定语法限制的 React 代码，最后转换产物 1:1 转换成对应的小程序代码。以一段简单的代码为例：Rax：import { createElement, useEffect, useState } from 'rax';\r\nimport View from 'rax-view';\r\n\r\nexport default function Home() {\r\n  const [name, setName] = useState('world');\r\n  useEffect(() => {\r\n    console.log('Here is effect.');\r\n  }, [])\r\n  return <View>Hello {name}</View>;\r\n}\r\n复制代码转换之后的小程序代码：逻辑层import { __create_component__, useEffect, useState } from 'jsx2mp-runtime/dist/ali.esm.js'\r\n\r\nfunction Home() {\r\n  const [name, setName] = useState('world');\r\n  useEffect(() => {\r\n    console.log('Here is effect.');\r\n  }, []);\r\n  \r\n  this._updateData({\r\n    _d0: name\r\n  });\r\n}\r\n\r\nComponent(__create_component__(Home));\r\n复制代码视图层<block a:if=\"{{$ready}}\">\r\n  <view class=\"__rax-view\">{{_d0}}</view>\r\n</block>\r\n复制代码编译时方案最大的特点就是，开发者虽然写的是类 React 语法，但是转换后的代码和渐进增强型框架非常类似。开发者可以比较清晰的看出编译前后代码的 对应关系 。简单来说，编译时方案会通过 AST 分析，将开发者写的 JSX 中 return 的模板部分构建到视图层，剩余部分代码保留，然后通过运行时垫片模拟 React 接口的表现。以一个简单的 return <View>Hello world</View> 为例，如果想要提取到 <View>Hello world</View> ，你可以写这段解析代码：// 省略定义 babel parser 和包装 traverse 的部分\r\nconst code = fs.readFileSync(FILE_PATH);\r\nconst ast = parser(code);\r\ntraverse(ast, {\r\n  ReturnStatement(path) {\r\n    const targetNodePath = path.get('argument');\r\n    if (targetNodePath.isJSXElement()) {\r\n      // 如果 return 的子元素是一个 JSX Element 就收集 or 处理一下\r\n    }\r\n  }\r\n})\r\n复制代码targetNodePath 就是 <View>Hello world</View> 的节点路径，关于 AST 相关的文章可以自行搜索一下，babel 的 handle book 已经比较详细了，再加上这个 辅助网站 基本是没有什么门槛的。但是这个方案其实是存在明显的优势和劣势的。优势运行时性能损耗低目标代码明确，开发者所写即所得运行时、编译时优化在这个方案中，你可以轻易的做到和渐进增强型框架一样的效果，即给予开发者 更多的语法支持 以及 默认的性能优化处理 ，比如避免多次 setData ，亦或是长列表优化等等。劣势语法限制高由于需要完全命中开发者在模板部分所用到的所有语法，这就对编译时框架的实现者有相当高的要求。因为大部分前端开发者们其实已经对灵活的语法有一定的依赖性，比如会使用高阶组件，比如在条件判断的时候写很多 return 等等。进一步的，由于是 1:1 编译转换，开发者在开发的时候还是不得不去遵循小程序的开发规范，比如一个文件中定义只能定义一个组件之类的。目前在阿里巴巴集团内部，Rax 的这套编译时方案 已经落地了很多业务 ，包括「电影演出」小程序等，从开发者的实践来看，如果能够掌握编译时开发的技巧，即保证最终 return 的模板的简洁性，语法限制其实还是在可以接受的范围内的。Rax 运行时/Remax/Taro Next运行时方案相比于上面的编译时方案，最大的优势是可以 几乎没有任何语法约束 的去完成代码编写。这对于开发者而言，无疑是最大的吸引力，高阶组件用起来！ createProtal 用起来！但是在小程序领域上暂时还不可能存在这么好的事情，这也是小程序原生语法最后的 执拗 。没有语法限制带来的更多的性能上的牺牲，这个与运行时方案的实现方式有很大的关系，接下来我详细介绍一下。从渲染的角度来看，这套方案更贴近于 富文本 渲染。逻辑层将一个和节点渲染信息相关的 组件树 传递给视图层，视图层通过节点类型判断然后进行视图渲染。下面这个图简要的描述了一下整个过程：虽然只用了 维护 两个字，但是逻辑层做的事情其实比较复杂。首先要做的是，去处理节点间的关系，去模拟 appendChild / removeChild / updateNode 等各个行为来操作 VDOM 树。其次比较重要的是去模拟事件，在逻辑层每一个节点类会继承自 EventTarget 基类，这个和 W3C 是一样的，然后通过 nodeId 作为标识去收集需要监听的事件，当视图层通过 action 触发了某个节点的事件之后，再通过原生小程序事件中的 event.currentTarget.dataset.nodeId 获取到目标节点的 id，最终触发目标回调。由于本文篇幅问题，不会更加详细的介绍其中的各个部分更加具体的实现，感兴趣的同学可以通过 Rax 的源码或者 npm init rax demo 起一个项目通过最终的产物来研究整个原理。在目前这个阶段，即使是运行时方案，也有不同的实现思路。以 Kbone (Rax 运行时方案是从 Kbone 改造而来) 和 Taro Next 都是通过模拟 Web 环境来彻底对接前端生态，而 Remax 只是简单的通过 react reconciler 连接 React 和小程序。从业务诉求来看，笔者认为，Rax 和 Taro Next 可能会比 Remax 更加开放。首先，需要考虑是三部分的诉求，（1）毫无语法限制，既然已经没有了语法限制，为什么不能用前端更加熟悉的方式来开发，即拥有操作 DOM 的权利；（2）不和 DSL 耦合，尽管在阿里巴巴集团内，对 React 的认可度更高，但是从实现原理上来看，和某个框架进行强绑定一定不是最优解；（3）旧有的 Web 业务迁移，今天我们所面对的开发者，很多都是因为业务压力或者其他情况需要将原有的 Web 页面迁移到小程序上，那么用模拟 Web 环境这套方案是最好不过了，根据我们的测试，大部分业务几乎可以无缝迁移过来。害！说了这么多漂亮话，运行时方案 真的很香 ，但这 并不是救世主 ，我来说说它的劣势。**劣势 1：**数据传输量大，我们需要将完整的组件树在逻辑层传输到视图层；**劣势 2：**页面上存在大量的监听器，每一个组件都需要无时无刻监听所有的事件，在事件不断触发的过程中，通过 nodeId 筛选出真正需要触发的事件；**劣势 3：**模板递归渲染，如果使用原生语法，原生框架可以在渲染前就知道页面大概的结构，来对渲染进行优化，但是如果仅仅只是通过类似 <view a:if=\"{{node.tagName === 'view'}}\"></view> 这样的信息，是很难判断页面的真实结构的。组合鱼和熊掌虽然不能兼得，但是可以各要一半~再次强调，本文 不是广告文 。如果编译时和运行时方案共存呢？基于淘系前端 高度现代的工程化 积累，开发者已经习惯通过区块来组建项目。更得益于，Rax 在编译时和运行时方案都有所积累，我们希望能够将运行时方案和编译时方案组合使用。对于基础复杂或者对于性能有要求的模块通过编译时实现。然后再通过 npm 包的形式，引入到运行时的项目中去，从而有效降低了运行时方案的性能损耗，并且能保证绝大部分的业务场景可以用 无限制 的语法完成，而开发者所面对的都是 Rax DSL。用一个 Demo 来看下：// 这是一个倒计时组件，通过编译时实现，然后发布为 rax-taobao-countdown\r\nimport { createElement } from 'rax';\r\nimport View from 'rax-view';\r\n\r\nfunction CountDown(props) {\r\n  // 省略各种逻辑...\r\n  return <View>{day}:{hours}:{minutes}:{seconds}</View>\r\n}\r\n\r\nexport default CountDown;\r\n复制代码// 运行时项目\r\nimport { createElement } from 'rax';\r\nimport CountDown from 'rax-taobao-countdown';\r\n\r\nfunction Home() {\r\n  return <CountDown now={Date.now()} />\r\n}\r\n复制代码假设，我们这个倒计时组件结构非常复杂，并且要求极高的交互性。那么，开发者可以通过编译时方案开发一个高性能 CountDown 组件，然后在运行时项目中引入使用。此时，视图层所得到的节点树信息大致如下：{\r\n  \"tagName\": \"custom-component\",\r\n  \"type\": \"element\",\r\n  \"behavior\": \"CountDown\",\r\n  \"children\": []\r\n}\r\n复制代码而不会有更多更深层结构的节点信息，有效避免刚刚说的运行时方案中存在的劣势。Web 才是未来小程序原生语法 绝对不是 小程序 or 下一代的渲染方案。通过微信小程序现有的语法规范来对开发者进行 绑架 ，只会让更多的人想突破围城。微信小程序似乎已经意识到了这一点，从目前的迭代来看，微信小程序引入了越来越多 Web 已有的东西，包括通过 wxs 在视图层就可以一定程度上操作 DOM，甚至获取到逻辑层组件实例等等，这个可以给现有的转换类框架提供更多的可能性。但是，如果小程序如果一开始设计的不这么糟糕呢，我们可能会失业（开个玩笑）？对于业务的开发者而言，「一码多端」才是效率最大化的。今天的业务需求可能只是投放到小程序容器，明天的需求可能就是投放到 Web，未来甚至 是 Flutter。Web 是最贴近前端开发者的，有组织保障（W3C）的规范。所以，站在 2020 年这个时间点，无论是框架提供者，还是业务开发者都应该更多的从标准的角度思考问题，这样才能让业务代码有更多的可能性。总结距离小程序诞生已经过去很多年，2020 年应该如何选择业务合适的小程序框架，这个需要开发者衡量利弊之后再做出选择。因为每个业务的形式不同，应用的存活时间也不相同，根据自己的需要选择可能才是最好的，本文只是从一个全局的视角对所有类型的框架进行分析，希望能够让正在看文章的你，不那么纠结~"}
